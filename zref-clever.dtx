% \iffalse meta-comment
%
% File: zref-clever.dtx
%
% This file is part of the LaTeX package "zref-clever".
%
% Copyright (C) 2021  Gustavo Barros
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file:
%
%    https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
%
% This work is "maintained" (as per LPPL maintenance status) by
% Gustavo Barros.
%
% This work consists of the files zref-clever.dtx,
%                                 zref-clever.ins,
%                                 zref-clever.tex,
%                                 zref-clever-code.tex,
%           and the derived files zref-clever.sty and
%                                 zref-clever.pdf,
%                                 zref-clever-code.pdf.
%
% The released version of this package is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the package can be found at
%
%    https://github.com/gusbrs/zref-clever
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}
% Have \GetFileInfo pick up date and version data
\usepackage{zref-clever}
\NewDocumentCommand\opt{m}{\texttt{#1}}
\MakeShortVerb{\|}
\begin{document}
  \DocInput{zref-clever.dtx}
\end{document}
%</driver>
% \fi
%
%
% \begin{documentation}
%
% \section{Introduction}
%
%
%
%
% \section{Loading the package}
%
%
%
%
%
%
%
%
% \section{Dependencies}
%
%
%
%
%
%
%
%
% \section{User interface}
%
%
%
%
%
%
%
%
% \section{Options}
%
%
%
%
%
%
%
% \section{Reference Types}
% \label{sec:reference-types}
%
% A ``reference type'' is the basic \pkg{zref-clever} setup unit for
% specifying how a cross-reference group of a certain kind is to be typeset.
% Though, usually, it will have the same name as the underlying \LaTeX{}
% \emph{counter}, they are conceptually different.  \pkg{zref-clever} defines
% \emph{reference types} and an association between each \emph{counter} and
% its \emph{type}, it does not define the counters themselves, which are
% defined by your document.  One \emph{reference type} can be associated with
% one or more \emph{counters}, and a \emph{counter} can be associated with
% different \emph{types} at different points in your document.  But each label
% is stored with only one \emph{type}, as specified by the counter-type
% association at the moment it is set, and that determines how the reference
% to that label is typeset.  References to different \emph{counters} of the
% same \emph{type} are grouped together, and treated alike by \cs{zcref}.  A
% \emph{reference type} may exist even when the \emph{counter} it is
% associated with is not actually defined, and this inconsequential.  In
% practice, the contrary may also happen, a \emph{counter} may be defined but
% we have no \emph{type} for it, but this must be handled by \pkg{zref-clever}
% as a ``missing type'' error (at least, if we try to refer to it).
%
% A \emph{reference type} can be associated with multiple counters because we
% may want to refer to different document elements, with different
% \emph{counters}, with a single name, as a single \emph{type}.  One prominent
% case of this are sectioning commands.  \cs{section}, \cs{subsection}, and
% \cs{subsubsection} have each their counter, but we'd like to refer to all of
% them by ``section''.  The same for \cs{paragraph} and \cs{subparagraph}.
%
% There are also cases in which we may want to use different \emph{reference
% types} to refer to document objects sharing the same \emph{counter}.
% Notably, the environments created with \LaTeX{}'s \cs{newtheorem} command
% and the \cs{appendix}.
%
%
%
% \section{Limitations}
%
%
%
%
%
%
% \section{Acknowledgments}
%
%
%
%
%
%
%
% \section{Change history}
%
%
% A change log with relevant changes for each version, eventual upgrade
% instructions, and upcoming changes, is maintained in the package's
% repository, at
% \url{https://github.com/gusbrs/zref-clever/blob/main/CHANGELOG.md}.
%
%
%
%
% \end{documentation}
%
%
% \begin{implementation}
%
% \section{Initial setup}
%
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=zrefclever>
%    \end{macrocode}
%
%
% Taking a stance on backward compatibility of the package.  During initial
% development, we have used freely recent features of the kernel (albeit
% refraining from \pkg{l3candidates}, even though I'd have loved to have used
% \cs{bool_case_true:}\dots{}).  We presume \pkg{xparse} (which made to the
% kernel in the 2020-10-01 release), and \pkg{expl3} as well (which made to
% the kernel in the 2020-02-02 release).  We also just use UTF-8 for the
% translations (which became the default input encoding in the 2018-04-01
% release).  Hence, since we would not be able to go much backwards without
% special handling anyway, we make the cut with the inclusion of the new hook
% management system (\pkg{ltcmdhooks}), which is bound to be useful for our
% purposes, and was released with the 2021-06-01 kernel.
%    \begin{macrocode}
\providecommand\IfFormatAtLeastTF{\@ifl@t@r\fmtversion}
\IfFormatAtLeastTF{2021-06-01}
  {}
  {%
    \PackageError{zref-clever}{LaTeX kernel too old}
      {%
        'zref-clever' requires a LaTeX kernel newer than 2021-06-01.%
        \MessageBreak Loading will abort!%
      }%
    \endinput
  }%
%    \end{macrocode}
%
%
% Identify the package.
%    \begin{macrocode}
\ProvidesExplPackage {zref-clever} {2021-09-13} {0.1.0-alpha}
  {Clever LaTeX cross-references based on zref}
%    \end{macrocode}
%
%
% \section{Dependencies}
%
%
% Required packages.  Besides these, \pkg{zref-hyperref} may also be required
% depending on the presence of \pkg{hyperref} itself and on the \opt{hyperref}
% option.
%
%    \begin{macrocode}
\RequirePackage { zref-base }
\RequirePackage { zref-user }
\RequirePackage { zref-counter }
\RequirePackage { zref-abspage }
\RequirePackage { translations }
%    \end{macrocode}
%
%
% \section{\pkg{zref} setup}
%
%
% For the purposes of the package, we need to store some information with the
% labels, some of it standard, some of it not so much.  So, we have to setup
% \pkg{zref} to do so.
%
% Some basic properties are handled by \pkg{zref} itself, or some of its
% modules.  The \texttt{page} and \texttt{counter} properties are respectively
% provided by modules \pkg{zref-base} and \pkg{zref-counter}.  The
% \pkg{zref-abspage} provides the \texttt{abspage} property which gives us a
% safe and easy way to sort labels for page references.
%
% But the reference itself, stored by \pkg{zref-base} in the \texttt{default}
% property, is somewhat a disputed real estate.  In particular, the use of
% \cs{labelformat} (previously from \pkg{varioref}, now in the kernel) will
% include there the reference ``prefix'' and complicate the job we are trying
% to do here.  Hence, we isolate \cs{the}\meta{counter} and store it ``clean''
% in \texttt{zc@thecnt} for reserved use.  Based on the definition of
% \cs{@currentlabel} done inside \cs{refstepcounter} in `texdoc source2e',
% section `ltxref.dtx'.  We just drop the \cs{p@...} prefix.
%
%    \begin{macrocode}
\zref@newprop { zc@thecnt } { \use:c { the \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@thecnt }
%    \end{macrocode}
%
%
% Much of the work of \pkg{zref-clever} relies on the association between a
% label's ``counter'' and its ``type'' (see the User manual section on
% ``Reference types'').  Superficially examined, one might think this relation
% could just be stored in a global property list, rather than in the label
% itself.  However, there are cases in which we want to distinguish different
% types for the same counter, depending on the document context.  Hence, we
% need to store the ``type'' of the ``counter'' for each ``label''.  In
% setting this, the presumption is that the label's type has the same name as
% its counter, unless it is specified otherwise by the \opt{countertype}
% option, as stored in \cs{l_@@_counter_type_prop}.
%
%    \begin{macrocode}
\zref@newprop { zc@type }
  {
    \prop_if_in:NVTF \l_@@_counter_type_prop \@currentcounter
      {
        \exp_args:NNe \prop_item:Nn
          \l_@@_counter_type_prop { \@currentcounter }
      }
      { \@currentcounter }
  }
\zref@addprop \ZREF@mainlist { zc@type }
%    \end{macrocode}
%
%
% Since the \texttt{zc@thecnt} and \texttt{page} properties store the
% ``\emph{printed} representation'' of their respective counters, for sorting
% and compressing purposes, we are also interested in their numeric values.
% So we store them in \texttt{zc@cntval} and \texttt{zc@pgval}.  For this, we
% use \cs{c@}\meta{counter}, which contains the counter's numerical value (see
% `texdoc source2e', section `ltcounts.dtx').
%    \begin{macrocode}
\zref@newprop { zc@cntval } [0] { \int_use:c { c@ \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@cntval }
\zref@newprop* { zc@pgval } [0] { \int_use:c { c@page } }
\zref@addprop \ZREF@mainlist { zc@pgval }
%    \end{macrocode}
%
%
% However, since many counters (may) get reset along the document, we require
% more than just their numeric values.  We need to know the reset chain of a
% given counter, in order to sort and compress a group of references.  Also
% here, the ``printed representation'' is not enough, not only because it is
% easier to work with the numeric values but, given we occasionally group
% multiple counters within a single type, sorting this group requires to know
% the actual counter reset chain (the counters' names and values).  Indeed,
% the set of counters grouped into a single type cannot be arbitrary: all of
% them must belong to the same reset chain, and must be nested within each
% other (they cannot even just share the same parent).
%
% Furthermore, even if it is true that most of the definitions of counters,
% and hence of their reset behavior is likely to be defined in the preamble,
% this is not necessarily true.  Users can create counters, newtheorems
% mid-document, and alter their reset behavior along the way.  Was that not
% the case, we could just store the desired information at
% \texttt{begindocument} in a variable and retrieve it when needed.  But since
% it is, we need to store the information with the label, with the values as
% current when the label is set.
%
% Though counters can be reset at any time, and in different ways at that, the
% most important use case is the automatic resetting of counters when some
% other counter is stepped, as performed by the standard mechanisms of the
% kernel (optional argument of \cs{newcounter}, \cs{@addtoreset},
% \cs{counterwithin} and related infrastructure).  The canonical optional
% argument of \cs{newcounter} establishes that the counter being created (the
% mandatory argument) gets reset every time the ``enclosing counter'' gets
% stepped (this is called in the usual sources ``within-counter'', ``old
% counter'', ``supercounter'' etc.).  This information is a little trickier to
% get.  For starters, the counters which may reset the current counter are not
% retrievable from the counter itself, because this information is stored with
% the counter that does the resetting, not with the one that gets reset (the
% list is stored in \cs{cl@}\meta{counter} with format
% |\@elt{countera}\@elt{counterb}\@elt{counterc}|, see section `ltcounts.dtx'
% in `source2e').  Besides, there may be a chain of resetting counters, which
% must be taken into account: if `counterC' gets reset by `counterB', and
% `counterB' gets reset by `counterA', stepping the latter affects all three
% of them.
%
% The procedure below examines a set of counters, those included in
% \cs{l_@@_counter_resetters_seq}, and for each of them retrieves the set of
% counters it resets, as stored in \cs{cl@}\meta{counter}, looking for the
% counter for which we are trying to set a label (\cs{@currentcounter}, passed
% as an argument to the functions).  There is one relevant caveat to this
% procedure: \cs{l_@@_counter_resetters_seq} is populated by hand with the
% ``usual suspects'', there is no way (that I know of) to ensure it is
% exhaustive.  However, it is not that difficult to create a reasonable
% ``usual suspects'' list which, of course, should include the counters for
% the sectioning commands to start with, and it is easy to add more counters
% to this list if needed, with the option \opt{counterresetters}.
% Unfortunately, not all counters are created alike, or reset alike.  Some
% counters, even some kernel ones, get reset by other mechanisms (notably, the
% \texttt{enumerate} environment counters do not use the regular counter
% machinery for resetting on each level, but are nested nevertheless by other
% means).  Therefore, inspecting \cs{cl@}\meta{counter} cannot possibly fully
% account for all of the automatic counter resetting which takes place in the
% document.  And there's also no other ``general rule'' we could grab on for
% this, as far as I know.  So we provide a way to manually tell
% \pkg{zref-clever} of these cases, by means of the \opt{counterresetby}
% option, whose information is stored in \cs{l_@@_counter_resetby_prop}.  This
% manual specification has precedence over the search through
% \cs{l_@@_counter_resetters_seq}, and should be handled with care, since
% there is no possible verification mechanism for this.
%
%
% \begin{macro}[EXP]
%   {
%     \@@_get_enclosing_counters:n ,
%     \@@_get_enclosing_counters_value:n ,
%   }
%     Recursively generate a \emph{sequence} of ``enclosing counters'' and
%     values, for a given \meta{counter} and leave it in the input stream.
%     These functions must be expandable, since they get called from
%     \cs{zref@newprop} and are the ones responsible for generating the
%     desired information when the label is being set.  Note that the order in
%     which we are getting this information is reversed, since we are
%     navigating the counter reset chain bottom-up.  But it is very hard to do
%     otherwise here where we need expandable functions, and easy to handle at
%     the reading side.
%     \begin{syntax}
%       \cs{@@_get_enclosing_counters:n} \Arg{counter}
%       \cs{@@_get_enclosing_counters_value:n} \Arg{counter}
%     \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \@@_get_enclosing_counters:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \@@_counter_reset_by:n {#1} }
        \@@_get_enclosing_counters:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
\cs_new:Npn \@@_get_enclosing_counters_value:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \int_use:c { c@ \@@_counter_reset_by:n {#1} } }
        \@@_get_enclosing_counters_value:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
%    \end{macrocode}
%
% Both \texttt{e} and \texttt{f} expansions work for this particular recursive
% call.  I'll stay with the \texttt{e} variant, since conceptually it is what
% I want (\texttt{x} itself is not expandable), and this package is anyway not
% compatible with older kernels for which the performance penalty of the
% \texttt{e} expansion would ensue (see also
% \url{https://tex.stackexchange.com/q/611370/#comment1529282_611385}, thanks
% Enrico Gregorio, aka `egreg').
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_get_enclosing_counters:n { V , e }
\cs_generate_variant:Nn \@@_get_enclosing_counters_value:n { V , e }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[EXP]{\@@_counter_reset_by:n}
%   Auxiliary function for \cs{@@_get_enclosing_counters:n} and
%   \cs{@@_get_enclosing_counters_value:n}.  They are broken in parts to be
%   able to use the expandable mapping functions.  \cs{@@_counter_reset_by:n}
%   leaves in the stream the ``enclosing counter'' which resets
%   \meta{counter}.
%   \begin{syntax}
%     \cs{@@_counter_reset_by:n} \Arg{counter}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \@@_counter_reset_by:n #1
  {
    \bool_if:nTF
      { \prop_if_in_p:Nn \l_@@_counter_resetby_prop {#1} }
      { \prop_item:Nn  \l_@@_counter_resetby_prop {#1} }
      {
        \seq_map_tokens:Nn \l_@@_counter_resetters_seq
          { \@@_counter_reset_by_aux:nn {#1} }
      }
  }
\cs_new:Npn \@@_counter_reset_by_aux:nn #1#2
  {
    \cs_if_exist:cT { c@ #2 }
      {
        \tl_if_empty:cF { cl@ #2 }
          {
            \tl_map_tokens:cn { cl@ #2 }
              { \@@_counter_reset_by_auxi:nnn {#2} {#1} }
          }
      }
  }
\cs_new:Npn \@@_counter_reset_by_auxi:nnn #1#2#3
  {
    \str_if_eq:nnT {#2} {#3}
      { \tl_map_break:n { \seq_map_break:n {#1} } }
  }
%    \end{macrocode}
% \end{macro}
%
%
% Finally, we create the \texttt{zc@enclcnt} and \texttt{zc@enclval}
% properties, and add them to the \texttt{main} property list.
%    \begin{macrocode}
\zref@newprop { zc@enclcnt }
  { \@@_get_enclosing_counters:V \@currentcounter }
\zref@newprop { zc@enclval }
  { \@@_get_enclosing_counters_value:V \@currentcounter }
\zref@addprop \ZREF@mainlist { zc@enclcnt }
\zref@addprop \ZREF@mainlist { zc@enclval }
%    \end{macrocode}
%
%
% Another piece of information we need is the page numbering format being used
% by \cs{thepage}, so that we know when we can (or not) group a set of page
% references in a range.  Unfortunately, \texttt{page} is not a typical
% counter in ways which complicates things.  First, it does commonly get reset
% along the document, not necessarily by the usual counter reset chains, but
% rather with \cs{pagenumbering} or variations thereof.  Second, the format of
% the page number commonly changes in the document (roman, arabic, etc.), not
% necessarily, though usually, together with a reset.  Trying to ``parse''
% \cs{thepage} to retrieve such information is bound to go wrong: we don't
% know, and can't know, what is within that macro, and that's the business of
% the user, or of the documentclass, or of the loaded packages.  The technique
% used by \pkg{cleveref}, which we borrow here, is simple and smart: store
% with the label what \cs{thepage} would return, if the counter \cs{c@page}
% was ``\(1\)''.  That does not allow us to \emph{sort} the references,
% luckily however, we have \texttt{abspage} which solves this problem.  But we
% can decide whether two labels can be compressed into a range or not based on
% this format: if they are identical, we can compress them, otherwise, we
% can't.  To do so, we locally redefine \cs{c@page} to return ``1'', thus
% avoiding any global spillovers of this trick.  Since this operation is not
% expandable we cannot run it directly from the property definition.  Hence,
% we use a shipout hook, and set \cs{g_@@_page_format_tl}, which can then be
% retrieved by the starred definition of |\zref@newprop*{zc@pgfmt}|.
%
%    \begin{macrocode}
\tl_new:N \g_@@_page_format_tl
\cs_new_protected:Npx \@@_page_format_aux: { \int_eval:n { 1 } }
\AddToHook { shipout / before }
  {
    \group_begin:
    \cs_set_eq:NN \c@page \@@_page_format_aux:
    \exp_args:NNx \tl_gset:Nn \g_@@_page_format_tl { \thepage }
    \group_end:
  }
\zref@newprop* { zc@pgfmt } { \g_@@_page_format_tl }
\zref@addprop \ZREF@mainlist { zc@pgfmt }
%    \end{macrocode}
%
%
% Still another property which we don't need to handle at the data provision
% side, but need to cater for at the retrieval side, is the \texttt{url}
% property (or the equivalent \texttt{urluse}) from the \pkg{zref-xr} module,
% which is added to the labels imported from external documents, and needed to
% construct hyperlinks to them.
%
%
%
% \section{Plumbing}
%
%
% \subsection{Messages}
%
%
%    \begin{macrocode}
\msg_new:nnn { zref-clever } { option-not-type-specific }
  {
    Option~'#1'~is~not~type-specific~\msg_line_context:.~
    Set~it~in~'\exp_not:N \zcDeclareTranslations'~before~first~'type'~switch~
    or~as~package~option.
  }
\msg_new:nnn { zref-clever } { option-only-type-specific }
  {
    No~type~specified~for~option~'#1'~\msg_line_context:.~
    Set~it~after~'type'~switch~or~in~'\exp_not:N \zcRefTypeSetup'.
  }
\msg_new:nnn  { zref-clever } { key-requires-value }
  { The~'#1'~key~'#2'~requires~a~value. }
\msg_new:nnn { zref-clever } { missing-zref-titleref }
  {
    Option~'ref=title'~requested~\msg_line_context:.~
    But~package~'zref-titleref'~is~not~loaded,~falling-back~to~default~'ref'.
  }
\msg_new:nnn { zref-clever } { hyperref-preamble-only }
  {
    Option~'hyperref'~only~available~in~the~preamble. \iow_newline:
    Use~the~starred~version~of~'\noexpand\zcheck'~instead.
  }
\msg_new:nnn { zref-clever } { missing-hyperref }
  { Missing~'hyperref'~package. \iow_newline: Setting~'hyperref=false'. }
\msg_new:nnn { zref-check } { check-document-only }
  { Option~'check'~only~available~in~the~document. }
\msg_new:nnn { zref-clever } { missing-zref-check }
  {
    Option~'check'~requested~\msg_line_context:.~
    But~package~'zref-check'~is~not~loaded,~can't~run~the~checks.
  }
\msg_new:nnn { zref-clever } { counters-not-nested }
  { Counters~not~nested~for~labels~'#1'~and~'#2'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-type }
  { Reference~type~undefined~for~label~'#1'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-name }
  { Name~undefined~for~type~'#1'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { single-element-range }
  { Range~for~type~'#1'~resulted~in~single~element~\msg_line_context:. }
%    \end{macrocode}
%
%
%
% \subsection{\pkg{translations}}
%
%
% Some wrappers around \pkg{translations} functions, so that we can generate
% variants with expansion control for arguments, or for convenience.
%
%
% \begin{macro}{\@@_if_transl:nnTF}
%   Conditional to check if a translation of \meta{key} exists for language
%   \meta{lang}.
%   \begin{syntax}
%     \cs{@@_if_transl:nnTF} \Arg{lang} \Arg{key} \Arg{true} \Arg{false}
%   \end{syntax}
%  \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_transl:nn #1#2 { TF }
  {
    \IfTranslation {#1} {#2}
      { \prg_return_true:  }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \@@_if_transl:nn { xx } { TF }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_get_transl:nnn}
%   Retrieves the translation of \meta{key} for the language \meta{lang} and
%   saves it in \meta{macro}.
%   \begin{syntax}
%     \cs{@@_get_transl:nnn} \Arg{macro} \Arg{lang} \Arg{key}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_transl:nnn #1#2#3
  { \SaveTranslationFor{#1}{#2}{#3} }
\cs_generate_variant:Nn \@@_get_transl:nnn { nxx }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_declare_transl:nnn}
%   Defines the translation of \meta{key} for the language \meta{lang}.  The
%   \meta{key} here is the full key, including package prefix, type, and
%   internal key name (i.e. the ``key'' from the perspective of
%   \pkg{translations}).
%   \begin{syntax}
%     \cs{@@_declare_transl:nnn} \Arg{lang} \Arg{key} \Arg{translation}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_declare_transl:nnn #1#2#3
  { \declaretranslation {#1} {#2} {#3} }
\cs_generate_variant:Nn \@@_declare_transl:nnn { xxn }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_declare_fallback_transl:nn}
%   Defines the default fallback translation of \meta{key} for the language
%   \meta{lang}.  The \meta{key} here is the internal key name (i.e. the name
%   of the option).
%   \begin{syntax}
%     \cs{@@_declare_fallback_transl:nn} \Arg{key} \Arg{translation}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_declare_fallback_transl:nn #1#2
  { \declaretranslationfallback { zrefclever-default- #1 } {#2} }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}[int]{\zcDicDefaultTransl, \zcDicTypeTransl}
%   Functions for providing translations in dictionary files.  We refrain from
%   using \texttt{expl3} names and ``atletter'', so that we don't have to
%   control catcodes in those files (as far as I can tell, \pkg{translations}
%   itself doesn't cater for this), even if these commands are only really
%   meant for internal use.  The \meta{key} here is always the internal key
%   name (i.e. the name of the option).  The language does not need to be
%   specified, it is automatically retrieved from the dictionary's declaration
%   done by \cs{ProvideDictionaryFor}.  Since \cs{ProvideDictTranslation} is
%   restricted by \pkg{translations} to the preamble, we inherit this
%   restriction here.
%   \begin{syntax}
%     \cs{zcDicDefaultTransl} \marg{key} \marg{translation}
%     \cs{zcDicTypeTransl} \marg{type} \marg{key} \marg{translation}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcDicDefaultTransl { m m }
  { \ProvideDictTranslation { zrefclever-default- #1 } {#2} }
\NewDocumentCommand \zcDicTypeTransl { m m m }
  { \ProvideDictTranslation { zrefclever-type- #1 - #2 } {#3} }
\@onlypreamble \zcDicDefaultTransl
\@onlypreamble \zcDicTypeTransl
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Options}
%
%
% \subsubsection{Auxiliary}
%
%
% \begin{macro}{\@@_prop_put_non_empty:Nnn}
%   If \meta{value} is empty, remove \meta{key} from \meta{property list}.
%   Otherwise, add \meta{key} = \meta{value} to \meta{property list}.
%   \begin{syntax}
%     \cs{@@_prop_put_non_empty:Nnn} \meta{property list} \Arg{key} \Arg{value}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_prop_put_non_empty:Nnn #1#2#3
  {
    \tl_if_empty:nTF {#3}
      { \prop_remove:Nn #1 {#2} }
      { \prop_put:Nnn #1 {#2} {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{\opt{countertype} option}
%
% \cs{l_@@_counter_type_prop} is used by \texttt{zc@type} property, and stores
% a mapping from ``counter'' to ``reference type''.  Only those counters whose
% type name is different from that of the counter need to be specified, since
% \texttt{zc@type} presumes the counter as the type if the counter is not
% found in \cs{l_@@_counter_type_prop}.
%
%    \begin{macrocode}
\prop_new:N \l_@@_counter_type_prop
\keys_define:nn { zref-clever / label }
  {
    countertype .code:n =
      {
        \keyval_parse:nnn
          {
            \msg_warning:nnnn { zref-clever }
              { key-requires-value } { countertype }
          }
          {
            \@@_prop_put_non_empty:Nnn
              \l_@@_counter_type_prop
          }
          {#1}
      } ,
    countertype .value_required:n = true ,
    countertype .initial:n =
      {
        subsection    = section ,
        subsubsection = section ,
        subparagraph  = paragraph ,
        enumi         = item ,
        enumii        = item ,
        enumiii       = item ,
        enumiv        = item ,
      } ,
  }
%    \end{macrocode}
%
%
% \subsubsection{\opt{counterresetters} option}
%
% \cs{l_@@_counter_resetters_seq} is used by \cs{@@_counter_reset_by:n} to
% populate the \texttt{zc@enclcnt} and \texttt{zc@enclval} properties, and
% stores the list of counters which are potential ``enclosing counters'' for
% other counters.  This option is constructed such that users can only
% \emph{add} items to the variable.  There would be little gain and some risk
% in allowing removal, and the syntax of the option would become unnecessarily
% more complicated.  Besides, users can already override, for any particular
% counter, the search done from the set in \cs{l_@@_counter_resetters_seq}
% with the \opt{counterresetby} option.
%
%    \begin{macrocode}
\seq_new:N \l_@@_counter_resetters_seq
\keys_define:nn { zref-clever / label }
  {
    counterresetters .code:n =
      {
        \clist_map_inline:nn {#1}
          {
            \seq_if_in:NnF \l_@@_counter_resetters_seq {##1}
              {
                \seq_put_right:Nn
                  \l_@@_counter_resetters_seq {##1}
              }
          }
      } ,
    counterresetters .initial:n =
      {
        part ,
        chapter ,
        section ,
        subsection ,
        subsubsection ,
        paragraph ,
        subparagraph ,
      },
    typesort .value_required:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{counterresetby} option}
%
% \cs{l_@@_counter_resetby_prop} is used by \cs{@@_counter_reset_by:n} to
% populate the \texttt{zc@enclcnt} and \texttt{zc@enclval} properties, and
% stores a mapping from counters to the counter which resets each of them.
% This mapping has precedence in \cs{@@_counter_reset_by:n} over the search
% through \cs{l_@@_counter_resetters_seq}.
%
%    \begin{macrocode}
\prop_new:N \l_@@_counter_resetby_prop
\keys_define:nn { zref-clever / label }
  {
    counterresetby .code:n =
      {
        \keyval_parse:nnn
          {
            \msg_warning:nnn { zref-clever }
              { key-requires-value } { counterresetby }
          }
          {
            \@@_prop_put_non_empty:Nnn
              \l_@@_counter_resetby_prop
          }
          {#1}
      } ,
    counterresetby .value_required:n = true ,
    counterresetby .initial:n =
      {
%    \end{macrocode}
% The counters for the \texttt{enumerate} environment do not use the regular
% counter machinery for resetting on each level, but are nested nevertheless
% by other means, treat them as exception.
%    \begin{macrocode}
        enumii  = enumi   ,
        enumiii = enumii  ,
        enumiv  = enumiii ,
      } ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{ref} option}
%
% \cs{l_@@_ref_property_tl} stores the property to which the reference is
% being made.  Currently, we restrict \texttt{ref=} to these two (or three)
% alternatives -- \texttt{zc@thecnt}, \texttt{page}, and \texttt{title} if
% \pkg{zref-titleref} is loaded --, but there might be a case for making this
% more flexible.  The infrastructure can already handle receiving an arbitrary
% property, as long as one is satisfied with sorting and compressing from the
% default counter.  If more flexibility is granted, one thing \emph{must} be
% handled at this point: the existence of the property itself, as far as
% \pkg{zref} is concerned.  This because typesetting relies on the check
% \cs{zref@ifrefcontainsprop}, which \emph{presumes} the property is defined
% and silently expands the \emph{true} branch if it is not (see
% \url{https://github.com/ho-tex/zref/issues/13}, thanks Ulrike Fischer).
% Therefore, before adding anything to \cs{l_@@_ref_property_tl}, check if
% first here with \cs{zref@ifpropundefined}: close it at the door.
%
%
%    \begin{macrocode}
\tl_new:N \l_@@_ref_property_tl
\keys_define:nn { zref-clever / reference }
  {
    ref .choice: ,
    ref / zc@thecnt .code:n =
      { \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt } } ,
    ref / page .code:n =
      { \tl_set:Nn \l_@@_ref_property_tl { page } } ,
    ref / title .code:n =
      {
        \AddToHook { begindocument }
          {
            \@ifpackageloaded { zref-titleref }
              { \tl_set:Nn \l_@@_ref_property_tl { title } }
              {
                \msg_warning:nn { zref-clever } { missing-zref-titleref }
                \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt }
              }
          }
      } ,
    ref .initial:n = zc@thecnt ,
    ref .value_required:n = true ,
    page .meta:n = { ref = page },
    page .value_forbidden:n = true ,
  }
\AddToHook { begindocument }
  {
    \@ifpackageloaded { zref-titleref }
      {
        \keys_define:nn { zref-clever / reference }
          {
            ref / title .code:n =
              { \tl_set:Nn \l_@@_ref_property_tl { title } }
          }
      }
      {
        \keys_define:nn { zref-clever / reference }
          {
            ref / title .code:n =
              {
                \msg_warning:nn { zref-clever } { missing-zref-titleref }
                \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt }
              }
          }
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{typeset} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_ref_bool
\bool_new:N \l_@@_typeset_name_bool
\keys_define:nn { zref-clever / reference }
  {
    typeset .choice: ,
    typeset / both .code:n =
      {
        \bool_set_true:N \l_@@_typeset_ref_bool
        \bool_set_true:N \l_@@_typeset_name_bool
      } ,
    typeset / ref .code:n =
      {
        \bool_set_true:N \l_@@_typeset_ref_bool
        \bool_set_false:N \l_@@_typeset_name_bool
      } ,
    typeset / name .code:n =
      {
        \bool_set_false:N \l_@@_typeset_ref_bool
        \bool_set_true:N \l_@@_typeset_name_bool
      } ,
    typeset .initial:n = both ,
    typeset .value_required:n = true ,

    noname .meta:n = { typeset = ref },
    noname .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{sort} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_sort_bool
\keys_define:nn { zref-clever / reference }
  {
    sort .bool_set:N = \l_@@_typeset_sort_bool ,
    sort .initial:n = true ,
    sort .default:n = true ,
    nosort .meta:n = { sort = false },
    nosort .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{typesort} option}
%
% \cs{l_@@_typesort_seq} is stored reversed, since the sort priorities are
% computed in the negative range in \cs{@@_sort_default_different_types:nn},
% so that we can implicitly rely on `0' being the ``last value'', and spare
% creating an integer variable using \cs{seq_map_indexed_inline:Nn}.
%
%    \begin{macrocode}
\seq_new:N \l_@@_typesort_seq
\keys_define:nn { zref-clever / reference }
  {
    typesort .code:n =
      {
        \seq_set_from_clist:Nn \l_@@_typesort_seq {#1}
        \seq_reverse:N \l_@@_typesort_seq
      } ,
    typesort .initial:n =
      { part , chapter , section , paragraph },
    typesort .value_required:n = true ,
    notypesort .code:n =
      { \seq_clear:N \l_@@_typesort_seq } ,
    notypesort .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{comp} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_compress_bool
\keys_define:nn { zref-clever / reference }
  {
    comp .bool_set:N = \l_@@_typeset_compress_bool ,
    comp .initial:n = true ,
    comp .default:n = true ,
    nocomp .meta:n = { comp = false },
    nocomp .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{range} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_range_bool
\keys_define:nn { zref-clever / reference }
  {
    range .bool_set:N = \l_@@_typeset_range_bool ,
    range .initial:n = false ,
    range .default:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{hyperref} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_use_hyperref_bool
\bool_new:N \l_@@_warn_hyperref_bool
\keys_define:nn { zref-clever / reference }
  {
    hyperref .choice: ,
    hyperref / auto .code:n =
      {
        \bool_set_true:N \l_@@_use_hyperref_bool
        \bool_set_false:N \l_@@_warn_hyperref_bool
      } ,
    hyperref / true .code:n =
      {
        \bool_set_true:N \l_@@_use_hyperref_bool
        \bool_set_true:N \l_@@_warn_hyperref_bool
      } ,
    hyperref / false .code:n =
      {
        \bool_set_false:N \l_@@_use_hyperref_bool
        \bool_set_false:N \l_@@_warn_hyperref_bool
      } ,
    hyperref .initial:n = auto ,
    hyperref .default:n = auto
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\AddToHook { begindocument }
  {
    \@ifpackageloaded { hyperref }
      {
        \bool_if:NT \l_@@_use_hyperref_bool
          { \RequirePackage { zref-hyperref } }
      }
      {
        \bool_if:NT \l_@@_warn_hyperref_bool
          { \msg_warning:nn { zref-clever } { missing-hyperref } }
        \bool_set_false:N \l_@@_use_hyperref_bool
      }
    \keys_define:nn { zref-clever / reference }
      {
        hyperref .code:n =
          { \msg_warning:nn { zref-clever } { hyperref-preamble-only } }
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{nameinlink} option}
%
%    \begin{macrocode}
\str_new:N \l_@@_nameinlink_str
\keys_define:nn { zref-clever / reference }
  {
    nameinlink .choice: ,
    nameinlink / true .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { true } } ,
    nameinlink / false .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { false } } ,
    nameinlink / single .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { single } } ,
    nameinlink / tsingle .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { tsingle } } ,
    nameinlink .initial:n = tsingle ,
    nameinlink .default:n = true ,
  }
%    \end{macrocode}
%
%
% \subsubsection{\opt{cap} and \opt{capfirst} options}
%
%    \begin{macrocode}
\bool_new:N \l_@@_capitalize_bool
\bool_new:N \l_@@_capitalize_first_bool
\keys_define:nn { zref-clever / reference }
  {
    cap .bool_set:N = \l_@@_capitalize_bool ,
    cap .initial:n = false ,
    cap .default:n = true ,
    nocap .meta:n = { cap = false },
    nocap .value_forbidden:n = true ,

    capfirst .bool_set:N = \l_@@_capitalize_first_bool ,
    capfirst .initial:n = false ,
    capfirst .default:n = true ,

    C .meta:n =
      { capfirst = true , noabbrevfirst = true },
    C .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
% \subsubsection{\opt{abbrev} and \opt{noabbrevfirst} options}
%
%    \begin{macrocode}
\bool_new:N \l_@@_abbrev_bool
\bool_new:N \l_@@_noabbrev_first_bool
\keys_define:nn { zref-clever / reference }
  {
    abbrev .bool_set:N = \l_@@_abbrev_bool ,
    abbrev .initial:n = false ,
    abbrev .default:n = true ,
    noabbrev .meta:n = { abbrev = false },
    noabbrev .value_forbidden:n = true ,

    noabbrevfirst .bool_set:N = \l_@@_noabbrev_first_bool ,
    noabbrevfirst .initial:n = false ,
    noabbrevfirst .default:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{lang} option}
%
% \cs{l_@@_current_language_tl} is an internal alias for \pkg{translations}'s
% internal macro \cs{@trnslt@current@language} which, in turn, is an alias for
% \cs{languagename} used by both \pkg{babel} and \pkg{polyglossia}, but
% \pkg{translations} ensures it always exists, even if no language package is
% loaded.  \cs{l_@@_main_language_tl} is an internal alias for \pkg{babel}'s
% \cs{bbl@main@language} or for \pkg{polyglossia}'s \cs{xpg@main@language}, as
% the case may be.  \cs{l_@@_ref_language_tl} is the internal variable which
% stores the language in which the reference is to be made.
%
% The overall setup here seems a little roundabout, but this is actually
% required.  In the preamble, we (potentially) don't yet have values for the
% ``main'' and ``current'' document languages, this must be retrieved at a
% \texttt{begindocument/before} hook.  And it must be \texttt{before}, since
% \cs{LoadDictionaryFor} is preamble only.  The \texttt{begindocument/before}
% hook is responsible to get values for \cs{l_@@_main_language_tl} and
% \cs{l_@@_current_language_tl} and load \pkg{zref-clever} dictionaries for
% all languages loaded by \pkg{babel} or \pkg{polyglossia}, or directly
% specified by the user.  After this information is retrieved, the preamble
% options are executed, and this is handled by the internal
% \texttt{zref-clever/reflanguage} hook, which is called at this point.  This
% hook handles two things: it executes the preamble options and, in sequence,
% it redefines the \texttt{lang} option key, since in the document body, we
% can handle ``main'' and ``current'' language options immediately.  This
% redefinition is added to the \texttt{zref-clever/reflanguage} hook, but
% \cs{AtEndOfPackage} so that it comes after \cs{ProcessKeysOptions}.  In
% other words, this is how we ensure the preamble options are executed before
% the \texttt{lang} key is redefined.
%
% For the \pkg{babel} and \pkg{polyglossia} variables which store the ``main''
% and ``current'' languages, see \url{https://tex.stackexchange.com/a/233178},
% including comments, particularly the one by Javier Bezos.  For the
% \pkg{babel} and \pkg{polyglossia} variables which store the list of loaded
% languages, see \url{https://tex.stackexchange.com/a/281220}, including
% comments, particularly PLK's.
%
%    \begin{macrocode}
\tl_new:N \l_@@_ref_language_tl
\tl_new:N \l_@@_main_language_tl
\tl_new:N \l_@@_current_language_tl
\NewHook { zref-clever / reflanguage }
\keys_define:nn { zref-clever / reference }
  {
    lang .code:n =
      {
        \AddToHook { zref-clever / reflanguage }
          {
            \str_case:nnF {#1}
              {
                { main }
                {
                  \tl_set_eq:NN \l_@@_ref_language_tl
                    \l_@@_main_language_tl
                }

                { current }
                {
                  \tl_set_eq:NN \l_@@_ref_language_tl
                    \l_@@_current_language_tl
                }
              }
              {
                \tl_set:Nn \l_@@_ref_language_tl {#1}
%    \end{macrocode}
% If the user specified a language in the preamble, make sure it is loaded.
% There's no need to worry with redundancy with \pkg{babel} and
% \pkg{polyglosssia} loaded languages, since \cs{LoadDictionaryFor} does not
% reload a dictionary if it's already been loaded.
%    \begin{macrocode}
                \exp_args:Nx \file_if_exist:nTF
                  { zref-clever- \@trnslt@language {#1} .trsl }
                  { \LoadDictionaryFor {#1} { zref-clever } }
                  {
                    \exp_args:Nx \file_if_exist:nT
                      { zref-clever- \baselanguage {#1} .trsl }
                      { \LoadDictionaryFor {#1} { zref-clever } }
                  }
              }
          }
      } ,
    lang .initial:n = main ,
    lang .value_required:n = true ,
  }
%    \end{macrocode}
%
%
% Redefinition of the \texttt{lang} key option for the document body.
%    \begin{macrocode}
\AtEndOfPackage
  {
    \AddToHook { zref-clever / reflanguage }
      {
        \keys_define:nn { zref-clever / reference }
          {
            lang .code:n =
              {
                \str_case:nnF {#1}
                  {
                    { main }
                    {
                      \tl_set_eq:NN \l_@@_ref_language_tl
                        \l_@@_main_language_tl
                    }

                    { current }
                    {
                      \tl_set_eq:NN \l_@@_ref_language_tl
                        \l_@@_current_language_tl
                    }
                  }
                  { \tl_set:Nn \l_@@_ref_language_tl {#1} }
              } ,
            lang .value_required:n = true ,
          }
      }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\AddToHook { begindocument / before }
  {
    \tl_set_eq:NN \l_@@_current_language_tl
      \@trnslt@current@language
    \@ifpackageloaded{babel}
      {
        \tl_set_eq:NN \l_@@_main_language_tl
          \bbl@main@language
        \clist_map_inline:Nn \bbl@loaded
          {
%    \end{macrocode}
% Funny enough, \pkg{translations} also loads its basic dictionaries for all
% languages loaded by \pkg{babel} or \pkg{polyglossia}.  First, there is no
% way to disable this, even if we don't need them at all here.  Second,
% \pkg{translations} sends messages of its own missing dictionaries to
% \texttt{info} and everyone else's to \texttt{warning}\dots{} So we have to
% control ourselves for missing dictionaries and load them only if available.
%    \begin{macrocode}
            \exp_args:Nx \file_if_exist:nTF
              { zref-clever- \@trnslt@language {#1} .trsl }
              { \LoadDictionaryFor {#1} { zref-clever } }
              {
                \exp_args:Nx \file_if_exist:nT
                  { zref-clever- \baselanguage {#1} .trsl }
                  { \LoadDictionaryFor {#1} { zref-clever } }
              }
          }
      }
      {
        \@ifpackageloaded{polyglossia}
          {
            \tl_set_eq:NN \l_@@_main_language_tl
              \xpg@main@language
            \clist_map_inline:Nn \xpg@loaded
              {
                \exp_args:Nx \file_if_exist:nTF
                  { zref-clever- \@trnslt@language {#1} .trsl }
                  { \LoadDictionaryFor {#1} { zref-clever } }
                  {
                    \exp_args:Nx \file_if_exist:nT
                      { zref-clever- \baselanguage {#1} .trsl }
                      { \LoadDictionaryFor {#1} { zref-clever } }
                  }
              }
          }
          {
            \tl_set:Nn \l_@@_main_language_tl { english }
            \LoadDictionaryFor { english } { zref-clever }
          }
      }
%    \end{macrocode}
% \emph{Then} we execute the package options stored in the
% \texttt{zref-clever/reflanguage} hook.
%    \begin{macrocode}
    \UseHook { zref-clever / reflanguage }
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{font} option}
%
%    \begin{macrocode}
\tl_new:N \l_@@_ref_typeset_font_tl
\keys_define:nn { zref-clever / reference }
  { font .tl_set:N = \l_@@_ref_typeset_font_tl }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{note} option}
%
%    \begin{macrocode}
\tl_new:N \l_@@_zcref_note_tl
\keys_define:nn { zref-clever / reference }
  {
    note .tl_set:N = \l_@@_zcref_note_tl ,
    note .value_required:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection{\opt{check} option}
%
% Integration with \pkg{zref-check}.
%
%    \begin{macrocode}
\bool_new:N \l_@@_zrefcheck_available_bool
\bool_new:N \l_@@_zcref_with_check_bool
\keys_define:nn { zref-clever / reference }
  {
    check .code:n =
      { \msg_warning:nn { zref-clever } { check-document-only } } ,
  }
\AddToHook { begindocument }
  {
    \@ifpackageloaded { zref-check }
      {
        \bool_set_true:N \l_@@_zrefcheck_available_bool
        \keys_define:nn { zref-clever / reference }
          {
            check .code:n =
              {
                \bool_set_true:N \l_@@_zcref_with_check_bool
                \keys_set:nn { zref-check / zcheck } {#1}
              }
          }
      }
      {
        \bool_set_false:N \l_@@_zrefcheck_available_bool
        \keys_define:nn { zref-clever / reference }
          {
            check .code:n =
              { \msg_warning:nn { zref-clever } { missing-zref-check } }
          }
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection{Reference options}
% \label{sec:reference-options}
%
% This is a set of options related to reference typesetting which receive
% equal treatment and, hence, are handled in batch.  Since we are dealing with
% options to be passed to \cs{zcref} or to \cs{zcsetup} or at load time, only
% not necessarily type-specific options are pertinent here.  However, they
% \emph{may} either be type-specific or language-specific, and thus must be
% stored in a property list, \cs{l_@@_ref_options_prop}, in order to be
% retrieved from the option \emph{name} by \cs{@@_get_option_with_transl:nN}
% and \cs{@@_get_option_plain:nN} according to context and precedence rules.
%
% The keys are set so that any value, including an empty one, is added to
% \cs{l_@@_ref_options_prop}, while a key with \emph{no value} removes the
% property from the list, so that these options can then fall back to lower
% precedence levels settings.  For discussion about the used technique, see
% Section~\ref{sec:zcreftypesetup}.
%
%    \begin{macrocode}
\prop_new:N \l_@@_ref_options_prop
\clist_map_inline:nn
  {
%    \end{macrocode}
% Not type-specific options.
%    \begin{macrocode}
    tpairsep ,
    tlistsep ,
    tlastsep ,
    notesep ,
%    \end{macrocode}
% Possibly type-specific options.
%    \begin{macrocode}
    namefont ,
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    reffont ,
    refpre ,
    refpos ,
    reffont-in ,
    refpre-in ,
    refpos-in ,
  }
  {
    \keys_define:nn { zref-clever / reference }
      {
        #1 .default:V = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              { \prop_remove:Nn \l_@@_ref_options_prop {#1} }
              { \prop_put:Nnn \l_@@_ref_options_prop {#1} {##1} }
          } ,
      }
  }
%    \end{macrocode}
%
%
%
% \subsection{\cs{zcsetup}}
%
% The options have been separated in two different groups, so that we
% can potentially apply them selectively to different contexts: \texttt{label}
% and \texttt{reference}.  Currently, the only use of this selection is the
% ability to exclude label related options from the \cs{zcref}'s options.
% Anyway, for load-time package options and for \cs{zcsetup} we want the whole
% set, so we aggregate the two into \texttt{zref-clever/zcsetup}, and use that
% here.
%
%    \begin{macrocode}
\keys_define:nn { }
  {
    zref-clever / zcsetup .inherit:n = zref-clever / label ,
    zref-clever / zcsetup .inherit:n = zref-clever / reference ,
  }
%    \end{macrocode}
%
% \begin{macro}[int]{\zcsetup}
%   Provide \cs{zcsetup}.
%    \begin{macrocode}
\NewDocumentCommand \zcsetup { m }
  { \keys_set:nn { zref-clever / zcsetup } {#1} }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Package options}
%
% Process load-time package options
% (\url{https://tex.stackexchange.com/a/15840}).
%    \begin{macrocode}
\RequirePackage { l3keys2e }
\ProcessKeysOptions { zref-clever / zcsetup }
%    \end{macrocode}
%
%
%
% \section{Reference format}
%
% Formatting how the reference is to be typeset is, quite naturally, a big
% part of the user interface of \pkg{zref-clever}.  In this area, we tried to
% balance ``flexibility'' and ``user friendliness''.  But the former does
% place a big toll overall, since there are indeed many places where tweaking
% may be desired, and the settings may depend on at least two important
% dimensions of variation: the reference type and the language.  Combination
% of those necessarily makes for a large set of possibilities.  Hence, the
% attempt here is to provide a rich set of ``handles'' for fine tuning the
% reference format but, at the same time, do not \emph{require} detailed setup
% by the users, unless they really want it.
%
% With that in mind, we have settled with an user interface for reference
% formatting which allows settings to be done in different scopes, with more
% or less overarching effects, and some precedence rules to regulate the
% relation of settings given in each of these scopes.  There are four scopes
% in which reference formatting can be specified by the user, in the following
% precedence order: i) as general \emph{options}; ii) as \emph{type-specific
% options}; iii) as \emph{language-specific and type-specific translations};
% and iv) as \emph{default translations} (that is, language-specific but not
% type-specific).  These precedence rules are handled / enforced in
% \cs{@@_get_option_with_transl:nN} and \cs{@@_get_option_plain:nN}, which are
% the basic functions to retrieve proper values for reference format settings.
%
% General ``options'' (i) can be given by the user in the optional argument of
% \cs{zcref}, but just as well in \cs{zcsetup} or as package options at
% load-time (see Section~\ref{sec:reference-options}).  ``Type-specific
% options'' (ii) are handled by \cs{zcRefTypeSetup}.  ``Language-specific
% translations'', be they ``type-specific'' (iii) or ``default'' (iv) have
% their user interface in \cs{zcDeclareTranslations}, and have their values
% populated by the package's dictionaries.
%
% Not all reference format specifications can be given in all of these
% scopes.  Some of them can't be type-specific, others must be type-specific,
% so the set available in each scope depends on the pertinence of the case.
%
% The package itself places the default setup for reference formatting at low
% precedence levels, and the users can easily and conveniently override them
% as desired.  Indeed, I expect most of the users' needs to be normally
% achievable with the general options and type-specific options, since
% references will normally be typeset in a single language (the document's
% main language) and, hence, multiple translations don't need to be provided.
%
%
% \begin{variable}
%   {
%     \l_@@_setup_type_tl ,
%     \l_@@_setup_language_tl ,
%   }
%     Store type and language in use in \cs{zcRefTypeSetup} and
%     \cs{zcDeclareTranslations}.
%    \begin{macrocode}
\tl_new:N \l_@@_setup_type_tl
\tl_new:N \l_@@_setup_language_tl
%    \end{macrocode}
% \end{variable}
%
%
%
% \subsection{\cs{zcRefTypeSetup}}
% \label{sec:zcreftypesetup}
%
% \cs{zcRefTypeSetup} is the main user interface for ``type-specific''
% reference formatting.  Settings done by this command have a higher
% precedence than any translation, hence they override any language-specific
% setting, either done at \cs{zcDeclareTranslations} or by the package's
% dictionaries.  On the other hand, they have a lower precedence than non
% type-specific general options.  The \meta{options} should be given in the
% usual \texttt{key=val} format.  The \meta{type} does not need to pre-exist,
% the property list variable to store the properties for the type gets created
% if need be.
%
% \begin{macro}[int]{\zcRefTypeSetup}
%   \begin{syntax}
%     \cs{zcRefTypeSetup} \marg{type} \marg{options}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcRefTypeSetup { m m }
  {
    \prop_if_exist:cF { l_@@_type_ #1 _options_prop }
      { \prop_new:c { l_@@_type_ #1 _options_prop } }
    \tl_set:Nn \l_@@_setup_type_tl {#1}
    \keys_set:nn { zref-clever / typesetup } {#2}
  }
%    \end{macrocode}
% \end{macro}
%
%
% Inside \cs{zcRefTypeSetup} any of the options \emph{can} receive empty
% values, and those values, if they exist in the property list, will override
% translations, regardless of their emptiness.  In principle, we could live
% with the situation of, once a setting has been made in
% \cs{l_@@_type_<type>_options_prop} or in \cs{l_@@_ref_options_prop} it stays
% there forever, and can only be overridden by a new value at the same
% precedence level or a higher one.  But it would be nice if an user can
% ``unset'' an option at either of those scopes to go back to the lower
% precedence level of the translations at any given point.  So both in
% \cs{zcRefTypeSetup} and in setting reference options (see
% Section~\ref{sec:reference-options}), we leverage the distinction of an
% ``empty valued key'' (|key=| or |key={}|) from a ``key with no value''
% (|key|).  This distinction is captured internally by the lower-level key
% parsing, but must be made explicit at \cs{keys_set:nn} by means of the
% \texttt{.default:V} property of the key in \cs{keys_define:nn}.  For the
% technique and some discussion about it, see
% \url{https://tex.stackexchange.com/q/614690} (thanks Jonathan P.\ Spratte,
% aka `Skillmon', and Phelype Oleinik) and
% \url{https://github.com/latex3/latex3/pull/988}.
%
%    \begin{macrocode}
\clist_map_inline:nn
  {
%    \end{macrocode}
% Not type-specific options.
%    \begin{macrocode}
    tpairsep ,
    tlistsep ,
    tlastsep ,
    notesep ,
  }
  {
    \keys_define:nn { zref-clever / typesetup }
      {
        #1 .code:n =
          {
            \msg_warning:nnn { zref-clever }
              { option-not-type-specific } {#1}
          } ,
      }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\clist_map_inline:nn
  {
%    \end{macrocode}
% Possibly type-specific options.
%    \begin{macrocode}
    namefont ,
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    reffont ,
    refpre ,
    refpos ,
    reffont-in ,
    refpre-in ,
    refpos-in ,
%    \end{macrocode}
% Necessarily type-specific options.
%    \begin{macrocode}
    Name-sg ,
    name-sg ,
    Name-pl ,
    name-pl ,
    Name-sg-ab ,
    name-sg-ab ,
    Name-pl-ab ,
    name-pl-ab ,
  }
  {
    \keys_define:nn { zref-clever / typesetup }
      {
        #1 .default:V = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              {
                \prop_remove:cn
                  {
                    l_@@_type_
                    \l_@@_setup_type_tl _options_prop
                  }
                  {#1}
              }
              {
                \prop_put:cnn
                  {
                    l_@@_type_
                    \l_@@_setup_type_tl _options_prop
                  }
                  {#1} {##1}
              }
          } ,
      }
  }
%    \end{macrocode}
%
%
%
% \subsection{\cs{zcDeclareTranslations}}
%
% \cs{zcDeclareTranslations} is the main user interface for
% ``language-specific'' reference formatting, be it ``type-specific'' or not.
% The difference between the two cases is captured by the \texttt{type} key,
% which works as a sort of a ``switch''.  Inside the \meta{options} argument
% of \cs{zcDeclareTranslations}, any options made before the first
% \texttt{type} key declare ``default'' (non type-specific) translations.
% When the \texttt{type} key is given with a value, the options following it
% will set ``type-specific'' translations for that type.  The current type can
% be switched off by an empty \texttt{type} key.
%
% \begin{macro}[int]{\zcDeclareTranslations}
%   \begin{syntax}
%     \cs{zcDeclareTranslations} \marg{language} \marg{options}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcDeclareTranslations { m m }
  {
    \tl_set:Nn \l_@@_setup_language_tl {#1}
    \tl_clear:N \l_@@_setup_type_tl
    \keys_set:nn { zref-clever / translations } {#2}
  }
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\keys_define:nn { zref-clever / translations }
  {
    type .code:n =
      {
        \tl_if_empty:nTF {#1}
          { \tl_clear:N \l_@@_setup_type_tl }
          {
            \prop_if_exist:cF { l_@@_type_ #1 _options_prop }
              { \prop_new:c { l_@@_type_ #1 _options_prop } }
            \tl_set:Nn \l_@@_setup_type_tl {#1}
          }
      } ,
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\clist_map_inline:nn
  {
%    \end{macrocode}
% Not type-specific options.
%    \begin{macrocode}
    tpairsep ,
    tlistsep ,
    tlastsep ,
    notesep ,
  }
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \@@_declare_transl:xxn
                  { \l_@@_setup_language_tl }
                  { zrefclever-default- #1 } {##1}
              }
              {
                \msg_warning:nnn { zref-clever }
                  { option-not-type-specific } {#1}
              }
          } ,
      }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\clist_map_inline:nn
  {
%    \end{macrocode}
% Possibly type-specific options.
%    \begin{macrocode}
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    refpre ,
    refpos ,
    refpre-in ,
    refpos-in ,
  }
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \@@_declare_transl:xxn
                  { \l_@@_setup_language_tl }
                  { zrefclever-default- #1 } {##1}
              }
              {
                \@@_declare_transl:xxn
                  { \l_@@_setup_language_tl }
                  { zrefclever-type- \l_@@_setup_type_tl - #1 } {##1}
              }
          } ,
      }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\clist_map_inline:nn
  {
%    \end{macrocode}
% Necessarily type-specific options.
%    \begin{macrocode}
    Name-sg ,
    name-sg ,
    Name-pl ,
    name-pl ,
    Name-sg-ab ,
    name-sg-ab ,
    Name-pl-ab ,
    name-pl-ab ,
  }
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \msg_warning:nnn { zref-clever }
                  { option-only-type-specific } {#1}
              }
              {
                \@@_declare_transl:xxn
                  { \l_@@_setup_language_tl }
                  { zrefclever-type- \l_@@_setup_type_tl - #1 } {##1}
              }
          } ,
      }
  }
%    \end{macrocode}
%
%
%
% \section{User interface}
%
% \subsection{\cs{zcref}}
%
%
% \begin{macro}[int]{\zcref}
%   \begin{syntax}
%     \cs{zcref}\meta{*}\oarg{options}\marg{labels}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcref { s O { } m }
  { \zref@wrapper@babel \@@_zcref:nnn {#3} {#1} {#2} }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_zcref:nnnn}
%   An intermediate internal function, which does the actual heavy lifting,
%   and places \Arg{labels} as first argument, so that it can be protected by
%   \cs{zref@wrapper@babel} in \cs{zcref}.
%   \begin{syntax}
%     \cs{@@_zcref:nnnn} \Arg{labels} \Arg{*} \Arg{options}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_zcref:nnn #1#2#3
  {
    \group_begin:
%    \end{macrocode}
% Set options.
%    \begin{macrocode}
      \keys_set:nn { zref-clever / reference } {#3}
%    \end{macrocode}
% Store arguments values.
%    \begin{macrocode}
      \seq_set_from_clist:Nn \l_@@_zcref_labels_seq {#1}
      \bool_set:Nn \l_@@_link_star_bool {#2}
%    \end{macrocode}
% Integration with \pkg{zref-check}.
%    \begin{macrocode}
      \bool_lazy_and:nnT
        { \l_@@_zrefcheck_available_bool }
        { \l_@@_zcref_with_check_bool }
        { \zrefcheck_zcref_beg_label: }
%    \end{macrocode}
% Sort the labels.
%    \begin{macrocode}
      \bool_lazy_or:nnT
        { \l_@@_typeset_sort_bool }
        { \l_@@_typeset_range_bool }
        { \@@_sort_labels: }
%    \end{macrocode}
% Typeset the references.
%    \begin{macrocode}
      \@@_typeset_refs:
%    \end{macrocode}
% Typeset \texttt{note}.
%    \begin{macrocode}
      \l_@@_notesep_tl
      \l_@@_zcref_note_tl
%    \end{macrocode}
% Integration with \pkg{zref-check}.
%    \begin{macrocode}
      \bool_lazy_and:nnT
        { \l_@@_zrefcheck_available_bool }
        { \l_@@_zcref_with_check_bool }
        {
          \zrefcheck_zcref_end_label_maybe:
          \zrefcheck_zcref_run_checks_on_labels:n
            { \l_@@_zcref_labels_seq }
        }
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_zcref_labels_seq, \l_@@_link_star_bool}
%    \begin{macrocode}
\seq_new:N \l_@@_zcref_labels_seq
\bool_new:N \l_@@_link_star_bool
%    \end{macrocode}
% \end{variable}
%
%
%
% \subsection{\cs{zcpageref}}
%
%
% \begin{macro}[int]{\zcpageref}
%   \begin{syntax}
%     \cs{zcpageref}\meta{*}\oarg{options}\marg{labels}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcpageref { s O { } m }
  {
    \IfBooleanTF {#1}
      { \zcref*[#2, ref = page] {#3} }
      { \zcref [#2, ref = page] {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Sorting}
%
%
% \begin{variable}
%   {
%     \l_@@_label_a_tl ,
%     \l_@@_label_b_tl ,
%     \l_@@_label_type_a_tl ,
%     \l_@@_label_type_b_tl ,
%     \l_@@_label_enclcnt_a_tl ,
%     \l_@@_label_enclcnt_b_tl ,
%     \l_@@_label_enclval_a_tl ,
%     \l_@@_label_enclval_b_tl
%   }
% Aux variables, for use in sorting and typesetting.  I could probably let go
% some of them in favor of \texttt{tmpa}/\texttt{tmpb}, but they do improve
% code readability.
%    \begin{macrocode}
\tl_new:N \l_@@_label_a_tl
\tl_new:N \l_@@_label_b_tl
\tl_new:N \l_@@_label_type_a_tl
\tl_new:N \l_@@_label_type_b_tl
\tl_new:N \l_@@_label_enclcnt_a_tl
\tl_new:N \l_@@_label_enclcnt_b_tl
\tl_new:N \l_@@_label_enclval_a_tl
\tl_new:N \l_@@_label_enclval_b_tl
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\int_new:N \l_@@_sort_prior_a_int
\int_new:N \l_@@_sort_prior_b_int
%    \end{macrocode}
%
%
% \begin{variable}{\l_@@_sort_decided_bool}
%   Auxiliary variable for \cs{@@_sort_default:nn}, signals if the sorting
%   between two labels has been decided or not.
%    \begin{macrocode}
\bool_new:N \l_@@_sort_decided_bool
%    \end{macrocode}
% \end{variable}
%
%
% Variant not provided by the kernel.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_reverse_items:n { V }
%    \end{macrocode}
%
%
% \begin{macro}{\@@_label_type_put_new_right:n}
%   Auxiliary function used to store ``new'' label types (in order) as the
%   sorting proceeds.  It is expected to be run inside \cs{@@_sort_labels:},
%   and stores new types in \cs{l_@@_label_types_seq}.
%   \begin{syntax}
%     \cs{@@_label_type_put_new_right:n} \Arg{label}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_label_type_put_new_right:n #1
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \tl_if_empty:NF \l_@@_label_type_a_tl
      {
        \seq_if_in:NVF
          \l_@@_label_types_seq
          \l_@@_label_type_a_tl
          {
            \seq_put_right:NV \l_@@_label_types_seq
              \l_@@_label_type_a_tl
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_label_types_seq}
%   Stores the order in which reference types appear in the label list
%   supplied by the user in \cs{zcref}.  This order is required as a ``last
%   resort'' sort criterion between the reference types, for use in
%   \cs{@@_sort_default:nn}.
%    \begin{macrocode}
\seq_new:N \l_@@_label_types_seq
%    \end{macrocode}
% \end{variable}
%
%
%
%
% \begin{macro}{\@@_sort_labels:}
%   The main sorting function.  It does not receive arguments, but it is
%   expected to be run inside \cs{@@_zcref:nnnn} where a number of environment
%   variables are to be set appropriately.  In particular,
%   \cs{l_@@_zcref_labels_seq} should contain the labels received as argument
%   to \cs{zcref}, and the function performs its task by sorting this
%   variable.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_labels:
  {
%    \end{macrocode}
% Store label types sequence.
%    \begin{macrocode}
    \seq_clear:N \l_@@_label_types_seq
    \tl_if_eq:NnF \l_@@_ref_property_tl { page }
      {
        \seq_map_function:NN \l_@@_zcref_labels_seq
          \@@_label_type_put_new_right:n
      }
%    \end{macrocode}
% Sort.
%    \begin{macrocode}
    \seq_sort:Nn \l_@@_zcref_labels_seq
      {
        \zref@ifrefundefined {##1}
          {
            \zref@ifrefundefined {##2}
              {
                % Neither label is defined.
                \sort_return_same:
              }
              {
                % The second label is defined, but the first isn't, leave the
                % undefined first (to be more visible).
                \sort_return_same:
              }
          }
          {
            \zref@ifrefundefined {##2}
              {
                % The first label is defined, but the second isn't, bring the
                % second forward.
                \sort_return_swapped:
              }
              {
                % The interesting case: both labels are defined.  The
                % reference to the "default" property/counter or to the page
                % are quite different from our perspective, they rely on
                % different fields and even use different information for
                % sorting, so we branch them here to specialized functions.
                \tl_if_eq:NnTF \l_@@_ref_property_tl { page }
                  { \@@_sort_page:nn {##1} {##2} }
                  { \@@_sort_default:nn {##1} {##2} }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_sort_default:nn}
%   The heavy-lifting function for sorting of existing labels for ``default''
%   references (that is, a standard reference, not to ``page'').  This
%   function is expected to be called within the sorting loop of
%   \cs{@@_sort_labels:} and receives the pair of labels being considered for
%   a change of order or not.  It should \emph{always} ``return'' either
%   \cs{sort_return_same:} or \cs{sort_return_swapped:}.
%   \begin{syntax}
%     \cs{@@_sort_default:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_default:nn #1#2
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_type_b_tl
      { \zref@extractdefault {#2} { zc@type } { \c_empty_tl } }

    \bool_if:nTF
      {
        % The second label has a type, but the first doesn't, leave the
        % undefined first (to be more visible).
        \tl_if_empty_p:N \l_@@_label_type_a_tl &&
        ! \tl_if_empty_p:N \l_@@_label_type_b_tl
      }
      { \sort_return_same: }
      {
        \bool_if:nTF
          {
            % The first label has a type, but the second doesn't, bring the
            % second forward.
            ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
            \tl_if_empty_p:N \l_@@_label_type_b_tl
          }
          { \sort_return_swapped: }
          {
            \bool_if:nTF
              {
                % The interesting case: both labels have a type...
                ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
                ! \tl_if_empty_p:N \l_@@_label_type_b_tl
              }
              {
                % Here we send this to a couple of auxiliary functions for no
                % other reason than to keep this long function a little less
                % unreadable.
                \tl_if_eq:NNTF
                  \l_@@_label_type_a_tl
                  \l_@@_label_type_b_tl
                  {
                    % ...and it's the same type.
                    \@@_sort_default_same_type:nn {#1} {#2}
                  }
                  {
                    % ...and they are different types.
                    \@@_sort_default_different_types:nn {#1} {#2}
                  }
              }
              {
                % Neither of the labels has a type.  We can't do much of
                % meaningful here, but if it's the same counter, compare it.
                \exp_args:Nxx \tl_if_eq:nnTF
                  { \zref@extractdefault {#1} { counter } { } }
                  { \zref@extractdefault {#2} { counter } { } }
                  {
                    \int_compare:nNnTF
                      { \zref@extractdefault {#1} { zc@cntval } {-1} }
                        >
                      { \zref@extractdefault {#2} { zc@cntval } {-1} }
                      { \sort_return_swapped: }
                      { \sort_return_same:    }
                  }
                  { \sort_return_same: }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_sort_default_same_type:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_default_same_type:nn #1#2
  {
    \tl_set:Nx \l_@@_label_enclcnt_a_tl
      { \zref@extractdefault {#1} { zc@enclcnt } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclcnt_a_tl
      { \tl_reverse_items:V \l_@@_label_enclcnt_a_tl }
    \tl_set:Nx \l_@@_label_enclcnt_b_tl
      { \zref@extractdefault {#2} { zc@enclcnt } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclcnt_b_tl
      { \tl_reverse_items:V \l_@@_label_enclcnt_b_tl }
    \tl_set:Nx \l_@@_label_enclval_a_tl
      { \zref@extractdefault {#1} { zc@enclval } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclval_a_tl
      { \tl_reverse_items:V \l_@@_label_enclval_a_tl }
    \tl_set:Nx \l_@@_label_enclval_b_tl
      { \zref@extractdefault {#2} { zc@enclval } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclval_b_tl
      { \tl_reverse_items:V \l_@@_label_enclval_b_tl }

    \bool_set_false:N \l_@@_sort_decided_bool
    % CHECK should I replace the tmp variables here?
    \tl_clear:N \l_tmpa_tl
    \tl_clear:N \l_tmpb_tl
    \bool_until_do:Nn \l_@@_sort_decided_bool
      {
        \tl_set:Nx \l_tmpa_tl
          { \tl_head:N \l_@@_label_enclcnt_a_tl }
        \tl_set:Nx \l_tmpb_tl
          { \tl_head:N \l_@@_label_enclcnt_b_tl }

        \bool_if:nTF
          {
            % Both are empty, meaning: neither labels have any (further)
            % ``enclosing counters'' (left).
            \tl_if_empty_p:V \l_tmpa_tl &&
            \tl_if_empty_p:V \l_tmpb_tl
          }
          {
            \exp_args:Nxx \tl_if_eq:nnTF
              { \zref@extractdefault {#1} { counter } { } }
              { \zref@extractdefault {#2} { counter } { } }
              {
                \bool_set_true:N \l_@@_sort_decided_bool
                \int_compare:nNnTF
                  { \zref@extractdefault {#1} { zc@cntval } {-1} }
                    >
                  { \zref@extractdefault {#2} { zc@cntval } {-1} }
                  { \sort_return_swapped: }
                  { \sort_return_same:    }
              }
              {
                \msg_warning:nnnn { zref-clever }
                  { counters-not-nested } {#1} {#2}
                \bool_set_true:N \l_@@_sort_decided_bool
                \sort_return_same:
              }
          }
          {
            \bool_if:nTF
              {
                % `a' is empty (and `b' is not), meaning: `b' is (possibly)
                % nested in `a'.
                \tl_if_empty_p:V \l_tmpa_tl
              }
              {
                \tl_set:Nx \l_tmpa_tl
                  { {\zref@extractdefault {#1} { counter } { }} }
                \exp_args:NNx \tl_if_in:NnTF
                  \l_@@_label_enclcnt_b_tl { \l_tmpa_tl }
                  {
                    \bool_set_true:N \l_@@_sort_decided_bool
                    \sort_return_same:
                  }
                  {
                    \msg_warning:nnnn { zref-clever }
                      { counters-not-nested } {#1} {#2}
                    \bool_set_true:N \l_@@_sort_decided_bool
                    \sort_return_same:
                  }
              }
              {
                \bool_if:nTF
                  {
                    % `b' is empty (and `a' is not), meaning: `a' is
                    % (possibly) nested in `b'.
                    \tl_if_empty_p:V \l_tmpb_tl
                  }
                  {
                    \tl_set:Nx \l_tmpb_tl
                      { {\zref@extractdefault {#2} { counter } { }} }
                    \exp_args:NNx \tl_if_in:NnTF
                      \l_@@_label_enclcnt_a_tl { \l_tmpb_tl }
                      {
                        \bool_set_true:N \l_@@_sort_decided_bool
                        \sort_return_swapped:
                      }
                      {
                        \msg_warning:nnnn { zref-clever }
                          { counters-not-nested } {#1} {#2}
                        \bool_set_true:N \l_@@_sort_decided_bool
                        \sort_return_same:
                      }
                  }
                  {
                    % Neither is empty, meaning: we can (possibly) compare the
                    % values of the current enclosing counter in the loop, if
                    % they are equal, we are still in the loop, if they are
                    % not, a sorting decision can be made directly.
                    \tl_if_eq:NNTF \l_tmpa_tl \l_tmpb_tl
                      {
                        \int_compare:nNnTF
                          { \tl_head:N \l_@@_label_enclval_a_tl }
                            =
                          { \tl_head:N \l_@@_label_enclval_b_tl }
                          {
                            \tl_set:Nx \l_@@_label_enclcnt_a_tl
                              { \tl_tail:N \l_@@_label_enclcnt_a_tl }
                            \tl_set:Nx \l_@@_label_enclcnt_b_tl
                              { \tl_tail:N \l_@@_label_enclcnt_b_tl }
                            \tl_set:Nx \l_@@_label_enclval_a_tl
                              { \tl_tail:N \l_@@_label_enclval_a_tl }
                            \tl_set:Nx \l_@@_label_enclval_b_tl
                              { \tl_tail:N \l_@@_label_enclval_b_tl }
                          }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \int_compare:nNnTF
                              { \tl_head:N \l_@@_label_enclval_a_tl }
                                >
                              { \tl_head:N \l_@@_label_enclval_b_tl }
                              { \sort_return_swapped: }
                              { \sort_return_same:    }
                          }
                      }
                      {
                        \msg_warning:nnnn { zref-clever }
                          { counters-not-nested } {#1} {#2}
                        \bool_set_true:N \l_@@_sort_decided_bool
                        \sort_return_same:
                      }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_sort_default_different_types:nn}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_default_different_types:nn #1#2
  {
    \int_zero:N \l_@@_sort_prior_a_int
    \int_zero:N \l_@@_sort_prior_b_int
    % \cs{l_@@_typesort_seq} was stored in reverse sequence, and
    % we compute the sort priorities in the negative range, so that we can
    % implicitly rely on `0' being the ``last value''.
    \seq_map_indexed_inline:Nn \l_@@_typesort_seq
      {
        \tl_if_eq:nnTF {##2} {{othertypes}}
          {
            \int_compare:nNnT { \l_@@_sort_prior_a_int } = { 0 }
              { \int_set:Nn \l_@@_sort_prior_a_int { - ##1 } }
            \int_compare:nNnT { \l_@@_sort_prior_b_int } = { 0 }
              { \int_set:Nn \l_@@_sort_prior_b_int { - ##1 } }
          }
          {
            \tl_if_eq:NnTF \l_@@_label_type_a_tl {##2}
              { \int_set:Nn \l_@@_sort_prior_a_int { - ##1 } }
              {
                \tl_if_eq:NnT \l_@@_label_type_b_tl {##2}
                  { \int_set:Nn \l_@@_sort_prior_b_int { - ##1 } }
              }
          }
      }
    \bool_if:nTF
      {
        \int_compare_p:nNn
          { \l_@@_sort_prior_a_int } <
          { \l_@@_sort_prior_b_int }
      }
      { \sort_return_same: }
      {
        \bool_if:nTF
          {
            \int_compare_p:nNn
              { \l_@@_sort_prior_a_int } >
              { \l_@@_sort_prior_b_int }
          }
          { \sort_return_swapped: }
          {
            % Sort priorities are equal for different types: the type that
            % occurs first in 'labels', as given by the user, is kept (or
            % brought) forward.
            \seq_map_inline:Nn \l_@@_label_types_seq
              {
                \tl_if_eq:NnTF \l_@@_label_type_a_tl {##1}
                  { \seq_map_break:n { \sort_return_same: } }
                  {
                    \tl_if_eq:NnT \l_@@_label_type_b_tl {##1}
                      { \seq_map_break:n { \sort_return_swapped: } }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_sort_page:nn}
%   The sorting function for sorting of existing labels for references to
%   ``page''.  This function is expected to be called within the sorting loop
%   of \cs{@@_sort_labels:} and receives the pair of labels being considered
%   for a change of order or not.  It should \emph{always} ``return'' either
%   \cs{sort_return_same:} or \cs{sort_return_swapped:}.  Compared to the
%   sorting of default labels, this is a piece of cake (thanks to
%   \texttt{abspage}).
%   \begin{syntax}
%     \cs{@@_sort_page:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_page:nn #1#2
  {
    \int_compare:nNnTF
      { \zref@extractdefault {#1} { abspage } {-1} }
        >
      { \zref@extractdefault {#2} { abspage } {-1} }
      { \sort_return_swapped: }
      { \sort_return_same:    }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Typesetting}
%
%
% About possible alternatives to signal compression inhibition for individual
% labels, see \url{https://tex.stackexchange.com/q/611370} (thanks Enrico
% Gregorio, Phelype Oleinik, and Steven B.\ Segletes).  Yet another
% alternative would be to receive an optional argument with the label(s) not
% to be compressed.  This would be a repetition, but would keep the syntax
% ``clean''.  All in all, and rethinking this here, probably the best is
% simply to not allow individual inhibition of compression.  We can already
% control compression of each individual call of \cs{zcref} with existing
% options, this should be enough.  I don't think the small extra flexibility
% this would grant is worth the syntax disruption it entails.  Anyway, I have
% kept a ``handle'' to deal with this in case the need arises, in the form of
% \cs{l_@@_range_inhibit_next_bool}, which is currently no-op, but is in
% place.
%
%
% \subsection*{Variables}
%
% \begin{variable}{\l_@@_typeset_last_bool, \l_@@_last_of_type_bool}
%   Auxiliary variables for \cs{@@_typeset_refs:}.
%   \cs{l_@@_typeset_last_bool} signals if the label list is over so that we
%   can leave the loop.  \cs{l_@@_last_of_type_bool} signals if we are
%   processing the last label of the current reference type.
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_last_bool
\bool_new:N \l_@@_last_of_type_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_typeset_labels_seq ,
%     \l_@@_typeset_queue_prev_tl ,
%     \l_@@_typeset_queue_curr_tl ,
%     \l_@@_type_first_label_tl ,
%     \l_@@_type_first_label_type_tl
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:}.  They store, respectively
%   the ``previous'' and the ``current'' reference type information while they
%   are being processed, since we cannot typeset them directly, given we can
%   only know certain things when the (next) type list is over.  The ``queue''
%   stores all references but the first of the type, and they are stored ready
%   to be typeset.  The ``first_label'' stores the \emph{label} of the first
%   reference for the type, because the name can only be determined at the
%   end, and its (potential) hyperlink must be handled at that point.
%    \begin{macrocode}
\seq_new:N \l_@@_typeset_labels_seq
\tl_new:N \l_@@_typeset_queue_prev_tl
\tl_new:N \l_@@_typeset_queue_curr_tl
\tl_new:N \l_@@_type_first_label_tl
\tl_new:N \l_@@_type_first_label_type_tl
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}
%   {
%     \l_@@_label_count_int ,
%     \l_@@_type_count_int ,
%   }
%   Main counters for \cs{@@_typeset_refs:}.  They track the state of the
%   parsing of the labels list.  \cs{l_@@_label_count_int} is stepped for every
%   reference/label in the list, and reset at the start of a new type.
%   \cs{l_@@_type_count_int} is stepped at every reference type change.
%    \begin{macrocode}
\int_new:N \l_@@_label_count_int
\int_new:N \l_@@_type_count_int
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}
%   {
%     \l_@@_range_count_int ,
%     \l_@@_range_same_count_int ,
%     \l_@@_range_beg_label_tl ,
%     \l_@@_next_maybe_range_bool ,
%     \l_@@_next_is_same_bool ,
%     \l_@@_range_inhibit_next_bool
%   }
%   Range related auxiliary variables for \cs{@@_typeset_refs:}.
%   \cs{l_@@_range_count_int} counts how many references/labels are in the
%   current ongoing range.  \cs{l_@@_range_same_count_int} counts how many of
%   the references in the current ongoing range are repeated ones.
%   \cs{l_@@_range_beg_label_tl} stores the label of the reference that starts
%   a range.  \cs{l_@@_next_maybe_range_bool} signals whether the next element
%   is in sequence to the current one.  \cs{l_@@_next_is_same_bool} signals
%   whether the next element repeats the current one.
%   \cs{l_@@_range_inhibit_next_bool} allows to control/track compression
%   inhibition of the next label.
%    \begin{macrocode}
\int_new:N \l_@@_range_count_int
\int_new:N \l_@@_range_same_count_int
\tl_new:N \l_@@_range_beg_label_tl
\bool_new:N \l_@@_next_maybe_range_bool
\bool_new:N \l_@@_next_is_same_bool
\bool_new:N \l_@@_range_inhibit_next_bool
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}{}
%   Aux variables for \cs{@@_typeset_refs:}.  Store separators and refpre/pos
%   options.
%    \begin{macrocode}
\tl_new:N \l_@@_namefont_tl
\tl_new:N \l_@@_reffont_out_tl
\tl_new:N \l_@@_reffont_in_tl

\tl_new:N \l_@@_namesep_tl
\tl_new:N \l_@@_rangesep_tl
\tl_new:N \l_@@_pairsep_tl
\tl_new:N \l_@@_listsep_tl
\tl_new:N \l_@@_lastsep_tl
\tl_new:N \l_@@_tpairsep_tl
\tl_new:N \l_@@_tlistsep_tl
\tl_new:N \l_@@_tlastsep_tl
\tl_new:N \l_@@_notesep_tl
\tl_new:N \l_@@_refpre_out_tl
\tl_new:N \l_@@_refpos_out_tl
\tl_new:N \l_@@_refpre_in_tl
\tl_new:N \l_@@_refpos_in_tl
%    \end{macrocode}
% \end{variable}
%
%
%
% \begin{variable}
%   {
%     \l_@@_type_name_tl ,
%     \l_@@_name_in_link_bool ,
%     \l_@@_name_format_tl ,
%     \l_@@_name_format_fallback_tl
%   }
%   Auxiliary variables for \cs{@@_get_ref_first:} and
%   \cs{@@_type_name_setup:}.
%    \begin{macrocode}
\tl_new:N \l_@@_type_name_tl
\bool_new:N \l_@@_name_in_link_bool
\tl_new:N \l_@@_name_format_tl
\tl_new:N \l_@@_name_format_fallback_tl
%    \end{macrocode}
% \end{variable}
%
%
%
% \subsection*{Main functions}
%
% \begin{macro}{\@@_typeset_refs:}
%   Main typesetting function for \cs{zcref}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_refs:
  {
    \seq_set_eq:NN \l_@@_typeset_labels_seq \l_@@_zcref_labels_seq
    \tl_clear:N \l_@@_typeset_queue_prev_tl
    \tl_clear:N \l_@@_typeset_queue_curr_tl
    \tl_clear:N \l_@@_type_first_label_tl
    \tl_clear:N \l_@@_type_first_label_type_tl
    \tl_clear:N \l_@@_range_beg_label_tl
    \int_zero:N \l_@@_label_count_int
    \int_zero:N \l_@@_type_count_int
    \int_zero:N \l_@@_range_count_int
    \int_zero:N \l_@@_range_same_count_int

    % Get not-type-specific separators and refpre/pos options.
    \@@_get_option_with_transl:nN {tpairsep} \l_@@_tpairsep_tl
    \@@_get_option_with_transl:nN {tlistsep} \l_@@_tlistsep_tl
    \@@_get_option_with_transl:nN {tlastsep} \l_@@_tlastsep_tl
    \@@_get_option_with_transl:nN {notesep}  \l_@@_notesep_tl

    % Set the font option for this zcref call.
    \l_@@_ref_typeset_font_tl

    % Loop over the label list in sequence.
    \bool_set_false:N \l_@@_typeset_last_bool
    \bool_until_do:Nn \l_@@_typeset_last_bool
      {
        \seq_pop_left:NN \l_@@_typeset_labels_seq \l_@@_label_a_tl
        \seq_if_empty:NTF \l_@@_typeset_labels_seq
          {
            \tl_clear:N \l_@@_label_b_tl
            \bool_set_true:N \l_@@_typeset_last_bool
          }
          { \seq_get_left:NN \l_@@_typeset_labels_seq \l_@@_label_b_tl }

        \tl_if_eq:NnTF \l_@@_ref_property_tl { page }
          {
            \tl_set:Nn \l_@@_label_type_a_tl { page }
            \tl_set:Nn \l_@@_label_type_b_tl { page }
          }
          {
            \tl_set:Nx \l_@@_label_type_a_tl
              {
                \zref@extractdefault
                  { \l_@@_label_a_tl } { zc@type } { \c_empty_tl }
              }
            \tl_set:Nx \l_@@_label_type_b_tl
              {
                \zref@extractdefault
                  { \l_@@_label_b_tl } { zc@type } { \c_empty_tl }
              }
          }

        % First, we establish whether the ``current label'' (i.e. `a') is the
        % last one of its type.  This can happen because the ``next label''
        % (i.e. `b') is of a different type (or different definition status),
        % or because we are at the end of the list.
        \bool_if:NTF \l_@@_typeset_last_bool
          { \bool_set_true:N \l_@@_last_of_type_bool }
          {
            \zref@ifrefundefined { \l_@@_label_a_tl }
              {
                \zref@ifrefundefined { \l_@@_label_b_tl }
                  { \bool_set_false:N \l_@@_last_of_type_bool }
                  { \bool_set_true:N \l_@@_last_of_type_bool  }
              }
              {
                \zref@ifrefundefined { \l_@@_label_b_tl }
                  { \bool_set_true:N \l_@@_last_of_type_bool }
                  {
                    % Neither is undefined, we must check the types.
                    \bool_if:nTF
                      % Both empty: same ``type''.
                      {
                        \tl_if_empty_p:N \l_@@_label_type_a_tl &&
                        \tl_if_empty_p:N \l_@@_label_type_b_tl
                      }
                      { \bool_set_false:N \l_@@_last_of_type_bool }
                      {
                        \bool_if:nTF
                          % Neither empty: compare types.
                          {
                            ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
                            ! \tl_if_empty_p:N \l_@@_label_type_b_tl
                          }
                          {
                            \tl_if_eq:NNTF
                              \l_@@_label_type_a_tl \l_@@_label_type_b_tl
                              { \bool_set_false:N \l_@@_last_of_type_bool }
                              { \bool_set_true:N \l_@@_last_of_type_bool  }
                          }
                          % One empty, the other not: different ``types''.
                          { \bool_set_true:N \l_@@_last_of_type_bool }
                      }
                  }
              }
          }

        % Handle warnings in case of reference or type undefined.
        \zref@refused { \l_@@_label_a_tl }
        \zref@ifrefundefined { \l_@@_label_a_tl }
          {}
          {
            \tl_if_empty:NT \l_@@_label_type_a_tl
              {
                \msg_warning:nnx { zref-clever } { missing-type }
                  { \l_@@_label_a_tl }
              }
          }

        % Get type-specific separators, refpre/pos and font options, once per
        % type.
        \int_compare:nNnT { \l_@@_label_count_int } = { 0 }
          {
            \@@_get_option_plain:nN {namefont}        \l_@@_namefont_tl
            \@@_get_option_plain:nN {reffont}         \l_@@_reffont_out_tl
            \@@_get_option_plain:nN {reffont-in}      \l_@@_reffont_in_tl
            \@@_get_option_with_transl:nN {namesep}   \l_@@_namesep_tl
            \@@_get_option_with_transl:nN {rangesep}  \l_@@_rangesep_tl
            \@@_get_option_with_transl:nN {pairsep}   \l_@@_pairsep_tl
            \@@_get_option_with_transl:nN {listsep}   \l_@@_listsep_tl
            \@@_get_option_with_transl:nN {lastsep}   \l_@@_lastsep_tl
            \@@_get_option_with_transl:nN {refpre}    \l_@@_refpre_out_tl
            \@@_get_option_with_transl:nN {refpos}    \l_@@_refpos_out_tl
            \@@_get_option_with_transl:nN {refpre-in} \l_@@_refpre_in_tl
            \@@_get_option_with_transl:nN {refpos-in} \l_@@_refpos_in_tl
          }

        % Here we send this to a couple of auxiliary functions for no other
        % reason than to keep this long function a little less unreadable.
        \bool_if:NTF \l_@@_last_of_type_bool
          {
            % There exists no next label of the same type as the current.
            \@@_typeset_refs_aux_last_of_type:
          }
          {
            % There exists a next label of the same type as the current.
            \@@_typeset_refs_aux_not_last_of_type:
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_typeset_refs_aux_last_of_type:}
%   Handles typesetting of when the current label is the last of its type.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_refs_aux_last_of_type:
  {
    % Process the current label to the current queue.
    \int_case:nnF { \l_@@_label_count_int }
      {
        % It is the last label of its type, but also the first one, and that's
        % what matters here: just store it.
        { 0 }
        {
          \tl_set:NV \l_@@_type_first_label_tl \l_@@_label_a_tl
          \tl_set:NV \l_@@_type_first_label_type_tl \l_@@_label_type_a_tl
        }

        % The last is the second: we have a pair (if not repeated).
        { 1 }
        {
          \int_compare:nNnF { \l_@@_range_same_count_int } = {1}
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  \exp_not:V \l_@@_pairsep_tl
                  \@@_get_ref:V \l_@@_label_a_tl
                }
            }
        }
      }
      % If neither the first, nor the second: we have the last label
      % on the current type list (if not repeated).
      {
        \int_case:nnF { \l_@@_range_count_int }
          {
            % There was no range going on.
            {0}
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  \exp_not:V \l_@@_lastsep_tl
                  \@@_get_ref:V \l_@@_label_a_tl
                }
            }
            % Last in the range is also the second in it.
            {1}
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  % We know `range_beg_label' is not empty, since this is the
                  % second element in the range, but the third or more in the
                  % type list.
                  \exp_not:V \l_@@_listsep_tl
                  \@@_get_ref:V \l_@@_range_beg_label_tl
                  \int_compare:nNnF { \l_@@_range_same_count_int } = {1}
                    {
                      \exp_not:V \l_@@_lastsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
            }
          }
          % Last in the range is third or more in it.
          {
            \int_case:nnF
              { \l_@@_range_count_int - \l_@@_range_same_count_int }
              {
                % Repetition, not a range.
                {0}
                {
                  % If `range_beg_label' is empty, it means it was also the
                  % first of the type, and hence was already handled.
                  \tl_if_empty:VF \l_@@_range_beg_label_tl
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \exp_not:V \l_@@_lastsep_tl
                          \@@_get_ref:V \l_@@_range_beg_label_tl
                        }
                    }
                }
                % A ``range'', but with no skipped value, treat as list.
                {1}
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      % Ditto.
                      \tl_if_empty:VF \l_@@_range_beg_label_tl
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_range_beg_label_tl
                        }
                      \exp_not:V \l_@@_lastsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
              }
              {
                % An actual range.
                \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                  {
                    % Ditto.
                    \tl_if_empty:VF \l_@@_range_beg_label_tl
                      {
                        \exp_not:V \l_@@_lastsep_tl
                        \@@_get_ref:V \l_@@_range_beg_label_tl
                      }
                    \exp_not:V \l_@@_rangesep_tl
                    \@@_get_ref:V \l_@@_label_a_tl
                  }
              }
          }
      }

    % Handle ``range'' option.  The idea is simple: if the queue is not empty,
    % we replace it with the end of the range (or pair).  We can still
    % retrieve the end of the range from \cs{l_@@_label_a_tl} since we know to
    % be processing the last label of its type at this point.
    \bool_if:NT \l_@@_typeset_range_bool
      {
        \tl_if_empty:NTF \l_@@_typeset_queue_curr_tl
          {
            \zref@ifrefundefined { \l_@@_type_first_label_tl }
              { }
              {
                \msg_warning:nnx { zref-clever } { single-element-range }
                  { \l_@@_type_first_label_type_tl }
              }
          }
          {
            \bool_set_false:N \l_@@_next_maybe_range_bool
            \zref@ifrefundefined { \l_@@_type_first_label_tl }
              { }
              {
                \@@_labels_in_sequence:nn
                  { \l_@@_type_first_label_tl } { \l_@@_label_a_tl }
              }
            \tl_set:Nx \l_@@_typeset_queue_curr_tl
              {
                \bool_if:NTF \l_@@_next_maybe_range_bool
                  { \exp_not:V \l_@@_pairsep_tl }
                  { \exp_not:V \l_@@_rangesep_tl }
                \@@_get_ref:V \l_@@_label_a_tl
              }
          }
      }

    % Now that the type is finished, we can add the name and the first ref to
    % the queue.  Or, if ``typset'' option is not ``both'', handle it here
    % too.
    \@@_type_name_setup:
    \bool_if:nTF
      { \l_@@_typeset_ref_bool && \l_@@_typeset_name_bool }
      {
        \tl_put_left:Nx \l_@@_typeset_queue_curr_tl
          { \@@_get_ref_first: }
      }
      {
        \bool_if:nTF
          { \l_@@_typeset_ref_bool }
          {
            \tl_put_left:Nx \l_@@_typeset_queue_curr_tl
              { \@@_get_ref:V \l_@@_type_first_label_tl }
          }
          {
            \bool_if:nTF
              { \l_@@_typeset_name_bool }
              {
                \tl_set:Nx \l_@@_typeset_queue_curr_tl
                  {
                    \bool_if:NTF \l_@@_name_in_link_bool
                      {
                        \exp_not:N \group_begin:
                        \exp_not:V \l_@@_namefont_tl
                        % It's two '@s', but escaped for DocStrip.
                        \exp_not:N \hyper@@@@link
                          {
                            \zref@ifrefcontainsprop
                              { \l_@@_type_first_label_tl } { urluse }
                              {
                                \zref@extractdefault
                                  { \l_@@_type_first_label_tl }
                                  { urluse } {}
                              }
                              {
                                \zref@extractdefault
                                  { \l_@@_type_first_label_tl }
                                  { url } {}
                              }
                          }
                          {
                            \zref@extractdefault
                              { \l_@@_type_first_label_tl } { anchor } {}
                          }
                          { \exp_not:V \l_@@_type_name_tl }
                        \exp_not:N \group_end:
                      }
                      {
                        \exp_not:N \group_begin:
                        \exp_not:V \l_@@_namefont_tl
                        \exp_not:V \l_@@_type_name_tl
                        \exp_not:N \group_end:
                      }
                  }
              }
              {
                % This case would correspond to "typeset=none" but should not
                % happen, given the options are set up to typeset at least one
                % of "ref" or "name", but a sensible fallback, equal to the
                % behavior of ``both''.
                \tl_put_left:Nx
                  \l_@@_typeset_queue_curr_tl { \@@_get_ref_first: }
              }
          }
      }

    % Typeset the previous type, if there is one.
    \int_compare:nNnT { \l_@@_type_count_int } > { 0 }
      {
        \int_compare:nNnT { \l_@@_type_count_int } > { 1 }
          { \l_@@_tlistsep_tl }
        \l_@@_typeset_queue_prev_tl
      }

    % Wrap up loop, or prepare for next iteration.
    \bool_if:NTF \l_@@_typeset_last_bool
      {
        % We are finishing, typeset the current queue.
        \int_case:nnF { \l_@@_type_count_int }
          {
            % Single type.
            { 0 }
            { \l_@@_typeset_queue_curr_tl }
            % Pair of types.
            { 1 }
            {
              \l_@@_tpairsep_tl
              \l_@@_typeset_queue_curr_tl
            }
          }
          {
            % Last in list of types.
            \l_@@_tlastsep_tl
            \l_@@_typeset_queue_curr_tl
          }
      }
      {
        % There are further labels, set variables for next iteration.
        \tl_set_eq:NN
          \l_@@_typeset_queue_prev_tl \l_@@_typeset_queue_curr_tl
        \tl_clear:N \l_@@_typeset_queue_curr_tl
        \tl_clear:N \l_@@_type_first_label_tl
        \tl_clear:N \l_@@_type_first_label_type_tl
        \tl_clear:N \l_@@_range_beg_label_tl
        \int_zero:N \l_@@_label_count_int
        \int_incr:N \l_@@_type_count_int
        \int_zero:N \l_@@_range_count_int
        \int_zero:N \l_@@_range_same_count_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_typeset_refs_aux_not_last_of_type:}
%   Handles typesetting of when the current label is not the last of its type.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_refs_aux_not_last_of_type:
  {
    % Signal if next label may form a range with the current one (of
    % course, only considered if compression is enabled in the first
    % place).
    \bool_set_false:N \l_@@_next_maybe_range_bool
    \bool_set_false:N \l_@@_next_is_same_bool
    \bool_lazy_and:nnT
      { \l_@@_typeset_compress_bool }
      % Currently no-op, but kept as ``handle'' to inhibit compression of
      % individual labels.
      { ! \l_@@_range_inhibit_next_bool }
      {
        \zref@ifrefundefined { \l_@@_label_a_tl }
          { }
          {
            \@@_labels_in_sequence:nn
              { \l_@@_label_a_tl } { \l_@@_label_b_tl }
          }
      }

    % Process the current label to the current queue.
    \int_compare:nNnTF { \l_@@_label_count_int } = { 0 }
      {
        % Current label is the first of its type (also not the last, but it
        % doesn't matter here): just store the label.
        \tl_set:NV \l_@@_type_first_label_tl \l_@@_label_a_tl
        \tl_set:NV \l_@@_type_first_label_type_tl \l_@@_label_type_a_tl

        % If the next label may be part of a range, we set `range_beg_label'
        % to ``empty'' (we deal with it as the ``first'', and must do it
        % there, to handle hyperlinking), but also step the range counters.
        \bool_if:NT \l_@@_next_maybe_range_bool
          {
            \tl_clear:N \l_@@_range_beg_label_tl
            \int_incr:N \l_@@_range_count_int
            \bool_if:NT \l_@@_next_is_same_bool
              { \int_incr:N \l_@@_range_same_count_int }
         }
      }
      {
        % Current label is neither the first (nor the last) of its
        % type.
        \bool_if:NTF \l_@@_next_maybe_range_bool
          {
            % Starting, or continuing a range.
            \int_compare:nNnTF
              { \l_@@_range_count_int } = {0}
              {
                % There was no range going, we are starting one.
                \tl_set:NV \l_@@_range_beg_label_tl \l_@@_label_a_tl
                \int_incr:N \l_@@_range_count_int
                \bool_if:NT \l_@@_next_is_same_bool
                  { \int_incr:N \l_@@_range_same_count_int }
              }
              {
                % Second or more in the range, but not the last.
                \int_incr:N \l_@@_range_count_int
                \bool_if:NT \l_@@_next_is_same_bool
                  { \int_incr:N \l_@@_range_same_count_int }
              }
          }
          {
            % Next element is not in sequence, meaning: there was no range, or
            % we are closing one.
            \int_case:nnF { \l_@@_range_count_int }
              {
                % There was no range going on.
                {0}
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      \exp_not:V \l_@@_listsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
                % Last is second in the range: if `range_same_count' is also
                % `1', it's a repetition (drop it), otherwise, it's a ``pair
                % within a list'', treat as list.
                {1}
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      \tl_if_empty:VF \l_@@_range_beg_label_tl
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_range_beg_label_tl
                        }
                      \int_compare:nNnF { \l_@@_range_same_count_int } = {1}
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_label_a_tl
                        }
                    }
                }
              }
              {
                % Last is third or more in the range: if `range_count' and
                % `range_same_count' are the same, its a repetition (drop it),
                % if they differ by `1', its a list, if they differ by more,
                % it is a real range.
                \int_case:nnF
                  { \l_@@_range_count_int - \l_@@_range_same_count_int }
                  {
                    {0}
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \tl_if_empty:VF \l_@@_range_beg_label_tl
                            {
                              \exp_not:V \l_@@_listsep_tl
                              \@@_get_ref:V \l_@@_range_beg_label_tl
                            }
                        }
                    }
                    {1}
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \tl_if_empty:VF \l_@@_range_beg_label_tl
                            {
                              \exp_not:V \l_@@_listsep_tl
                              \@@_get_ref:V \l_@@_range_beg_label_tl
                            }
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_label_a_tl
                        }
                    }
                  }
                  {
                    \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                      {
                        \tl_if_empty:VF \l_@@_range_beg_label_tl
                          {
                            \exp_not:V \l_@@_listsep_tl
                            \@@_get_ref:V \l_@@_range_beg_label_tl
                          }
                        \exp_not:V \l_@@_rangesep_tl
                        \@@_get_ref:V \l_@@_label_a_tl
                      }
                  }
              }
            % Reset counters.
            \int_zero:N \l_@@_range_count_int
            \int_zero:N \l_@@_range_same_count_int
          }
      }
    % Step label counter for next iteration.
    \int_incr:N \l_@@_label_count_int
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection*{Aux functions}
%
%
% \begin{macro}{\@@_get_ref:n}
%   Auxiliary function to \cs{@@_typeset_refs:}.  Handles a complete
%   ``ref-block'', including ``pre'' and ``pos'' elements, and
%   \emph{hyperlinking}.  It does not handle the reference type ``name'', for
%   that use \cs{@@_get_ref_first:}.  It should get the reference with
%   \cs{zref@extractdefault} as usual but, if the reference is not available,
%   should put \cs{zref@default} on the stream protected, so that it can be
%   accumulated in the queue.  \cs{hyperlink} must also be protected from
%   expansion for the same reason.
%    \begin{macrocode}
\cs_new:Npn \@@_get_ref:n #1
  {
    \zref@ifrefcontainsprop {#1} { \l_@@_ref_property_tl }
      {
        \bool_if:nTF
          { \l_@@_use_hyperref_bool && ! \l_@@_link_star_bool }
          {
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_out_tl
            \exp_not:V \l_@@_refpre_out_tl
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_in_tl
            % It's two '@s', but escaped for DocStrip.
            \exp_not:N \hyper@@@@link
              {
                \zref@ifrefcontainsprop {#1} { urluse }
                  { \zref@extractdefault {#1} { urluse } {} }
                  { \zref@extractdefault {#1} { url } {} }
              }
              { \zref@extractdefault {#1} { anchor } {} }
              {
                \exp_not:V \l_@@_refpre_in_tl
                \zref@extractdefault {#1} { \l_@@_ref_property_tl } {}
                \exp_not:V \l_@@_refpos_in_tl
              }
            \exp_not:N \group_end:
            \exp_not:V \l_@@_refpos_out_tl
            \exp_not:N \group_end:
          }
          {
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_out_tl
            \exp_not:V \l_@@_refpre_out_tl
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_in_tl
            \exp_not:V \l_@@_refpre_in_tl
            \zref@extractdefault {#1} { \l_@@_ref_property_tl } {}
            \exp_not:V \l_@@_refpos_in_tl
            \exp_not:N \group_end:
            \exp_not:V \l_@@_refpos_out_tl
            \exp_not:N \group_end:
          }
      }
      { \exp_not:N \zref@default }
  }
\cs_generate_variant:Nn \@@_get_ref:n { V }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_type_name_setup:}
%   Auxiliary function to \cs{@@_typeset_refs:}.  Sets the type name variable
%   \cs{l_@@_type_name_tl}.  When it cannot be found, clears it.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_type_name_setup:
  {
    \zref@ifrefundefined { \l_@@_type_first_label_tl }
      { \tl_clear:N \l_@@_type_name_tl }
      {
        \tl_if_empty:nTF \l_@@_type_first_label_type_tl
          { \tl_clear:N \l_@@_type_name_tl }
          {
%    \end{macrocode}
% Determine whether we should use capitalization, abbreviation, and plural.
%    \begin{macrocode}
            \bool_lazy_or:nnTF
              { \l_@@_capitalize_bool }
              {
                \l_@@_capitalize_first_bool &&
                \int_compare_p:nNn { \l_@@_type_count_int } = { 0 }
              }
              { \tl_set:Nn \l_@@_name_format_tl {Name} }
              { \tl_set:Nn \l_@@_name_format_tl {name} }
            % If the queue is empty, we have a singular, otherwise, plural.
            \tl_if_empty:NTF \l_@@_typeset_queue_curr_tl
              { \tl_put_right:Nn \l_@@_name_format_tl { -sg } }
              { \tl_put_right:Nn \l_@@_name_format_tl { -pl } }
            \bool_lazy_and:nnTF
              { \l_@@_abbrev_bool }
              {
                ! \int_compare_p:nNn { \l_@@_type_count_int } = { 0 } ||
                ! \l_@@_noabbrev_first_bool
              }
              {
                \tl_set:NV \l_@@_name_format_fallback_tl \l_@@_name_format_tl
                \tl_put_right:Nn \l_@@_name_format_tl { -ab }
              }
              { \tl_clear:N \l_@@_name_format_fallback_tl }

            \tl_if_empty:NTF \l_@@_name_format_fallback_tl
              {
                \prop_get:cVNF
                  { l_@@_type_ \l_@@_type_first_label_type_tl _options_prop }
                  \l_@@_name_format_tl
                  \l_@@_type_name_tl
                  {
                    \@@_if_transl:xxTF
                      { \l_@@_ref_language_tl }
                      {
                        zrefclever-type- \l_@@_type_first_label_type_tl -
                        \l_@@_name_format_tl
                      }
                      {
                        \@@_get_transl:nxx { \l_@@_type_name_tl }
                          { \l_@@_ref_language_tl }
                          {
                            zrefclever-type- \l_@@_type_first_label_type_tl -
                            \l_@@_name_format_tl
                          }
                      }
                      {
                        \tl_clear:N \l_@@_type_name_tl
                        \msg_warning:nnx { zref-clever } { missing-name }
                          { \l_@@_type_first_label_type_tl }
                      }
                  }
              }
              {
                \prop_get:cVNF
                  { l_@@_type_ \l_@@_type_first_label_type_tl _options_prop }
                  \l_@@_name_format_tl
                  \l_@@_type_name_tl
                  {
                    \prop_get:cVNF
                      { l_@@_type_ \l_@@_type_first_label_type_tl _options_prop }
                      \l_@@_name_format_fallback_tl
                      \l_@@_type_name_tl
                      {
                        \@@_if_transl:xxTF
                          { \l_@@_ref_language_tl }
                          {
                            zrefclever-type- \l_@@_type_first_label_type_tl -
                            \l_@@_name_format_tl
                          }
                          {
                            \@@_get_transl:nxx { \l_@@_type_name_tl }
                              { \l_@@_ref_language_tl }
                              {
                                zrefclever-type- \l_@@_type_first_label_type_tl -
                                \l_@@_name_format_tl
                              }
                          }
                          {
                            \@@_if_transl:xxTF
                              { \l_@@_ref_language_tl }
                              {
                                zrefclever-type- \l_@@_type_first_label_type_tl -
                                \l_@@_name_format_fallback_tl
                              }
                              {
                                \@@_get_transl:nxx { \l_@@_type_name_tl }
                                  { \l_@@_ref_language_tl }
                                  {
                                    zrefclever-type- \l_@@_type_first_label_type_tl -
                                    \l_@@_name_format_fallback_tl
                                  }
                              }
                              {
                                \tl_clear:N \l_@@_type_name_tl
                                \msg_warning:nnx { zref-clever } { missing-name }
                                  { \l_@@_type_first_label_type_tl }
                              }
                          }
                      }
                  }
              }
          }
      }
%    \end{macrocode}
% Signal whether the type name is to be included in the hyperlink or not.
%    \begin{macrocode}
    \bool_lazy_any:nTF
      {
        { ! \l_@@_use_hyperref_bool }
        { \l_@@_link_star_bool }
        { \tl_if_empty_p:N \l_@@_type_name_tl }
        { \str_if_eq_p:Vn \l_@@_nameinlink_str { false } }
      }
      { \bool_set_false:N \l_@@_name_in_link_bool }
      {
        \bool_lazy_any:nTF
          {
            { \str_if_eq_p:Vn \l_@@_nameinlink_str { true } }
            {
              \str_if_eq_p:Vn \l_@@_nameinlink_str { tsingle } &&
              \tl_if_empty_p:N \l_@@_typeset_queue_curr_tl
            }
            {
              \str_if_eq_p:Vn \l_@@_nameinlink_str { single } &&
              \tl_if_empty_p:N \l_@@_typeset_queue_curr_tl &&
              \l_@@_typeset_last_bool &&
              \int_compare_p:nNn { \l_@@_type_count_int } = { 0 }
            }
          }
          { \bool_set_true:N \l_@@_name_in_link_bool }
          { \bool_set_false:N \l_@@_name_in_link_bool }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_get_ref_first:}
%   Auxiliary function to \cs{@@_typeset_refs:}.  Handles a complete
%   ``ref-block'', including ``pre'' and ``pos'' elements,
%   \emph{hyperlinking}, and the reference type ``name''.  For use on the
%   first reference of each type.
%    \begin{macrocode}
\cs_new:Npn \@@_get_ref_first:
  {
    \zref@ifrefundefined { \l_@@_type_first_label_tl }
      { \exp_not:N \zref@default }
      {
        \bool_if:NTF \l_@@_name_in_link_bool
          {
            \zref@ifrefcontainsprop
              { \l_@@_type_first_label_tl } { \l_@@_ref_property_tl }
              {
                % It's two '@s', but escaped for DocStrip.
                \exp_not:N \hyper@@@@link
                  {
                    \zref@ifrefcontainsprop
                      { \l_@@_type_first_label_tl } { urluse }
                      {
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { urluse } {}
                      }
                      {
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { url } {}
                      }
                  }
                  {
                    \zref@extractdefault { \l_@@_type_first_label_tl }
                      { anchor } {}
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_namefont_tl
                    \exp_not:V \l_@@_type_name_tl
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_namesep_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_out_tl
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_in_tl
                    \exp_not:V \l_@@_refpre_in_tl
                    \zref@extractdefault { \l_@@_type_first_label_tl }
                      { \l_@@_ref_property_tl } {}
                    \exp_not:V \l_@@_refpos_in_tl
                    \exp_not:N \group_end:
                    % hyperlink makes it's own group, we'd like to close the
                    % 'refpre-out' group after 'refpos-out', but... we close
                    % it here, and give the trailing 'refpos-out' its own
                    % group.  This will result that formatting given to
                    % 'refpre-out' will not reach 'refpos-out', but I see no
                    % alternative, and this has to be handled specially.
                    \exp_not:N \group_end:
                  }
                \exp_not:N \group_begin:
                % Ditto: special treatment.
                \exp_not:V \l_@@_reffont_out_tl
                \exp_not:V \l_@@_refpos_out_tl
                \exp_not:N \group_end:
              }
              {
                \exp_not:N \group_begin:
                \exp_not:V \l_@@_namefont_tl
                \exp_not:V \l_@@_type_name_tl
                \exp_not:N \group_end:
                \exp_not:V \l_@@_namesep_tl
                \exp_not:N \zref@default
              }
          }
          {
            \tl_if_empty:NTF \l_@@_type_name_tl
              {
                \exp_not:N \zref@default
                \exp_not:V \l_@@_namesep_tl
              }
              {
                \exp_not:N \group_begin:
                \exp_not:V \l_@@_namefont_tl
                \exp_not:V \l_@@_type_name_tl
                \exp_not:N \group_end:
                \exp_not:V \l_@@_namesep_tl
              }
            \zref@ifrefcontainsprop
              { \l_@@_type_first_label_tl } { \l_@@_ref_property_tl }
              {
                \bool_if:nTF
                  {
                    \l_@@_use_hyperref_bool &&
                    ! \l_@@_link_star_bool
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_out_tl
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_in_tl
                    % It's two '@s', but escaped for DocStrip.
                    \exp_not:N \hyper@@@@link
                      {
                        \zref@ifrefcontainsprop
                          { \l_@@_type_first_label_tl } { urluse }
                          {
                            \zref@extractdefault { \l_@@_type_first_label_tl }
                              { urluse } {}
                          }
                          {
                            \zref@extractdefault { \l_@@_type_first_label_tl }
                              { url } {}
                          }
                      }
                      {
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { anchor } {}
                      }
                      {
                        \exp_not:V \l_@@_refpre_in_tl
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { \l_@@_ref_property_tl } {}
                        \exp_not:V \l_@@_refpos_in_tl
                      }
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_refpos_out_tl
                    \exp_not:N \group_end:
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_out_tl
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_in_tl
                    \exp_not:V \l_@@_refpre_in_tl
                    \zref@extractdefault { \l_@@_type_first_label_tl }
                      { \l_@@_ref_property_tl } {}
                    \exp_not:V \l_@@_refpos_in_tl
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_refpos_out_tl
                    \exp_not:N \group_end:
                  }
              }
              { \exp_not:N \zref@default }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \begin{macro}{\@@_get_option_with_transl:nN}
%    \begin{macrocode}
% \Arg{option} \Arg{var to store result}
\cs_new_protected:Npn \@@_get_option_with_transl:nN #1#2
  {
    % First attempt options stored in \cs{l_@@_ref_options_prop}.
    \prop_get:NnNF \l_@@_ref_options_prop {#1} #2
      {
        % If not found, try the type specific options.
        \bool_lazy_all:nTF
          {
            { ! \tl_if_empty_p:N \l_@@_label_type_a_tl }
            {
              \prop_if_exist_p:c
                { l_@@_type_ \l_@@_label_type_a_tl _options_prop }
            }
            {
              \prop_if_in_p:cn
                { l_@@_type_ \l_@@_label_type_a_tl _options_prop } {#1}
            }
          }
          {
            \prop_get:cnN
              { l_@@_type_ \l_@@_label_type_a_tl _options_prop } {#1} #2
          }
          {
            % If not found, try the type specific translations.
            \@@_if_transl:xxTF
              { \l_@@_ref_language_tl }
              { zrefclever-type- \l_@@_label_type_a_tl - #1 }
              {
                \@@_get_transl:nxx {#2}
                  { \l_@@_ref_language_tl }
                  { zrefclever-type- \l_@@_label_type_a_tl - #1 }
              }
              {
                % If not found, try general translations.  We are not
                % controlling for their existence, but we must make sure all
                % options being retrieved with
                % \cs{@@_get_option_with_transl:nN} have their values set for
                % `English' and `fallback'.
                \@@_get_transl:nxx {#2}
                  { \l_@@_ref_language_tl }
                  { zrefclever-default- #1 }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_get_option_plain:nN}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_option_plain:nN #1#2
  {
    % First attempt options stored in \cs{l_@@_ref_options_prop}.
    \prop_get:NnNF \l_@@_ref_options_prop {#1} #2
      {
        % If not found, try the type specific options.
        \bool_lazy_and:nnTF
          { ! \tl_if_empty_p:N \l_@@_label_type_a_tl }
          {
            \prop_if_exist_p:c
              { l_@@_type_ \l_@@_label_type_a_tl _options_prop }
          }
          {
            \prop_get:cnNF
              { l_@@_type_ \l_@@_label_type_a_tl _options_prop } {#1} #2
              { \tl_clear:N #2 }
          }
          { \tl_clear:N #2 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_labels_in_sequence:nn}
%   Sets \cs{l_@@_next_maybe_range_bool} to true if label `1' comes in
%   immediate sequence from label `2'.  And sets both
%   \cs{l_@@_next_maybe_range_bool} and \cs{l_@@_next_is_same_bool} if the
%   labels are the ``same''.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_labels_in_sequence:nn #1#2
  {
    \tl_if_eq:NnTF \l_@@_ref_property_tl { page }
      {
        \exp_args:Nxx \tl_if_eq:nnT
          { \zref@extractdefault {#1} { zc@pgfmt } { } }
          { \zref@extractdefault {#2} { zc@pgfmt } { } }
          {
            \int_compare:nNnTF
              { \zref@extractdefault {#1} { zc@pgval } {-2} + 1 }
                =
              { \zref@extractdefault {#2} { zc@pgval } {-1} }
              { \bool_set_true:N \l_@@_next_maybe_range_bool }
              {
                \int_compare:nNnT
                  { \zref@extractdefault {#1} { zc@pgval } {-1} }
                    =
                  { \zref@extractdefault {#2} { zc@pgval } {-1} }
                  {
                    \bool_set_true:N \l_@@_next_maybe_range_bool
                    \bool_set_true:N \l_@@_next_is_same_bool
                  }
              }
          }
      }
      {
        \exp_args:Nxx \tl_if_eq:nnT
          { \zref@extractdefault {#1} { counter } { } }
          { \zref@extractdefault {#2} { counter } { } }
          {
            \exp_args:Nxx \tl_if_eq:nnT
              { \zref@extractdefault {#1} { zc@enclval } { } }
              { \zref@extractdefault {#2} { zc@enclval } { } }
              {
                \int_compare:nNnTF
                  { \zref@extractdefault {#1} { zc@cntval } {-2} + 1 }
                    =
                  { \zref@extractdefault {#2} { zc@cntval } {-1} }
                  { \bool_set_true:N \l_@@_next_maybe_range_bool }
                  {
                    \int_compare:nNnT
                      { \zref@extractdefault {#1} { zc@cntval } {-1} }
                        =
                      { \zref@extractdefault {#2} { zc@cntval } {-1} }
                      {
                        \bool_set_true:N \l_@@_next_maybe_range_bool
                        \bool_set_true:N \l_@@_next_is_same_bool
                      }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Special handling}
%
% This section is meant to aggregate any ``special handling'' needed for
% \LaTeX{} kernel features, document classes, and packages, needed for
% \pkg{zref-clever} to work properly with them.  It is not meant to be a
% ``kitchen sink of workarounds''.  Rather, I intend to keep this as lean as
% possible, trying to add things selectively when they are safe and
% reasonable.  And, hopefully, doing so by proper setting of
% \pkg{zref-clever}'s options, not by messing with other packages' code.  In
% particular, I do not mean to compensate for ``lack of support for
% \pkg{zref}'' by individual packages here, unless there is really no
% alternative.
%
%
% \subsection{\cs{appendix}}
%
%
% Another relevant use case of the same general problem of different types for
% the same counter is the \cs{appendix} which in some document classes,
% including the standard ones, change the sectioning commands looks but, of
% course, keep using the same counter (\file{book.cls} and \file{report.cls}
% reset counters \texttt{chapter} and \texttt{section} to 0, change
% \cs{@chapapp} to use \cs{appendixname} and use \cs{@Alph} for
% \cs{thechapter}; \file{article.cls} resets counters \texttt{section} and
% \texttt{subsection} to 0, and uses \cs{@Alph} for \cs{thesection};
% \file{memoir.cls}, \file{scrbook.cls} and \file{scrarticle.cls} do the same
% as their corresponding standard classes, and sometimes a little more, but
% what interests us here is pretty much the same; see also the \pkg{appendix}
% package).
%
%
%
% \subsection{\cs{newtheorem}}
%
%
%
%
%
% \subsection{\pkg{enumitem} package}
%
% TODO Option \opt{counterresetby} should probably be extended for
% \pkg{enumitem}, conditioned on it being loaded.
%
%
%
% \section{Translations}
%
% \DoNotIndex{\__zrefclever_declare_fallback_transl:nn}
% \DoNotIndex{\zcDicDefaultTransl}
% \DoNotIndex{\zcDicTypeTransl}
%
%
% \subsection{Fallback}
%
% All options retrieved with \cs{@@_get_option_with_transl:nN} must have their
% values set for `fallback', even if to empty values, since this is what will
% be retrieved if \pkg{babel} or \pkg{polyglossia} is loaded and sets a
% language which \pkg{zref-clever} does not know.  And \pkg{translations}
% typesets the \emph{key} as a last resource fallback, which we don't want to
% happen.  On the other hand, type-specific options are not looked for in
% `fallback'.
%
%    \begin{macrocode}
\@@_declare_fallback_transl:nn { namesep   } {\nobreakspace}
\@@_declare_fallback_transl:nn { pairsep   } {,~}
\@@_declare_fallback_transl:nn { listsep   } {,~}
\@@_declare_fallback_transl:nn { lastsep   } {,~}
\@@_declare_fallback_transl:nn { tpairsep  } {,~}
\@@_declare_fallback_transl:nn { tlistsep  } {,~}
\@@_declare_fallback_transl:nn { tlastsep  } {,~}
\@@_declare_fallback_transl:nn { notesep   } {~}
\@@_declare_fallback_transl:nn { rangesep  } {\textendash}
\@@_declare_fallback_transl:nn { refpre    } {}
\@@_declare_fallback_transl:nn { refpos    } {}
\@@_declare_fallback_transl:nn { refpre-in } {}
\@@_declare_fallback_transl:nn { refpos-in } {}
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%
%
% \subsection{English}
%
% All options retrieved with \cs{@@_get_option_with_transl:nN} must have their
% values set for `English', since this is what will be retrieved if no
% language package is loaded.  In other words, `English' is the
% \pkg{translations} equivalent of `fallback' when no language package is
% present.
%
%    \begin{macrocode}
%<*lang-english>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvideDictionaryFor{English}{zref-clever}

\zcDicDefaultTransl{namesep}{\nobreakspace}
\zcDicDefaultTransl{pairsep}{~and\nobreakspace}
\zcDicDefaultTransl{listsep}{,~}
\zcDicDefaultTransl{lastsep}{~and\nobreakspace}
\zcDicDefaultTransl{tpairsep}{~and\nobreakspace}
\zcDicDefaultTransl{tlistsep}{,~}
\zcDicDefaultTransl{tlastsep}{,~and\nobreakspace}
\zcDicDefaultTransl{notesep}{~}
\zcDicDefaultTransl{rangesep}{~to\nobreakspace}
\zcDicDefaultTransl{refpre}{}
\zcDicDefaultTransl{refpos}{}
\zcDicDefaultTransl{refpre-in}{}
\zcDicDefaultTransl{refpos-in}{}

\zcDicTypeTransl{part}{Name-sg}{Part}
\zcDicTypeTransl{part}{name-sg}{part}
\zcDicTypeTransl{part}{Name-pl}{Parts}
\zcDicTypeTransl{part}{name-pl}{parts}

\zcDicTypeTransl{chapter}{Name-sg}{Chapter}
\zcDicTypeTransl{chapter}{name-sg}{chapter}
\zcDicTypeTransl{chapter}{Name-pl}{Chapters}
\zcDicTypeTransl{chapter}{name-pl}{chapters}

\zcDicTypeTransl{section}{Name-sg}{Section}
\zcDicTypeTransl{section}{name-sg}{section}
\zcDicTypeTransl{section}{Name-pl}{Sections}
\zcDicTypeTransl{section}{name-pl}{sections}

\zcDicTypeTransl{paragraph}{Name-sg}{Paragraph}
\zcDicTypeTransl{paragraph}{name-sg}{paragraph}
\zcDicTypeTransl{paragraph}{Name-pl}{Paragraphs}
\zcDicTypeTransl{paragraph}{name-pl}{paragraphs}
\zcDicTypeTransl{paragraph}{Name-sg-ab}{Par.}
\zcDicTypeTransl{paragraph}{name-sg-ab}{par.}
\zcDicTypeTransl{paragraph}{Name-pl-ab}{Par.}
\zcDicTypeTransl{paragraph}{name-pl-ab}{par.}

\zcDicTypeTransl{appendix}{Name-sg}{Appendix}
\zcDicTypeTransl{appendix}{name-sg}{appendix}
\zcDicTypeTransl{appendix}{Name-pl}{Appendices}
\zcDicTypeTransl{appendix}{name-pl}{appendices}

\zcDicTypeTransl{page}{Name-sg}{Page}
\zcDicTypeTransl{page}{name-sg}{page}
\zcDicTypeTransl{page}{Name-pl}{Pages}
\zcDicTypeTransl{page}{name-pl}{pages}
\zcDicTypeTransl{page}{name-sg-ab}{p.}
\zcDicTypeTransl{page}{name-pl-ab}{pp.}

\zcDicTypeTransl{line}{Name-sg}{Line}
\zcDicTypeTransl{line}{name-sg}{line}
\zcDicTypeTransl{line}{Name-pl}{Lines}
\zcDicTypeTransl{line}{name-pl}{lines}

\zcDicTypeTransl{figure}{Name-sg}{Figure}
\zcDicTypeTransl{figure}{name-sg}{figure}
\zcDicTypeTransl{figure}{Name-pl}{Figures}
\zcDicTypeTransl{figure}{name-pl}{figures}
\zcDicTypeTransl{figure}{Name-sg-ab}{Fig.}
\zcDicTypeTransl{figure}{name-sg-ab}{fig.}
\zcDicTypeTransl{figure}{Name-pl-ab}{Figs.}
\zcDicTypeTransl{figure}{name-pl-ab}{figs.}

\zcDicTypeTransl{table}{Name-sg}{Table}
\zcDicTypeTransl{table}{name-sg}{table}
\zcDicTypeTransl{table}{Name-pl}{Tables}
\zcDicTypeTransl{table}{name-pl}{tables}

\zcDicTypeTransl{item}{Name-sg}{Item}
\zcDicTypeTransl{item}{name-sg}{item}
\zcDicTypeTransl{item}{Name-pl}{Items}
\zcDicTypeTransl{item}{name-pl}{items}

\zcDicTypeTransl{footnote}{Name-sg}{Footnote}
\zcDicTypeTransl{footnote}{name-sg}{footnote}
\zcDicTypeTransl{footnote}{Name-pl}{Footnotes}
\zcDicTypeTransl{footnote}{name-pl}{footnotes}

\zcDicTypeTransl{note}{Name-sg}{Note}
\zcDicTypeTransl{note}{name-sg}{note}
\zcDicTypeTransl{note}{Name-pl}{Notes}
\zcDicTypeTransl{note}{name-pl}{notes}

\zcDicTypeTransl{equation}{Name-sg}{Equation}
\zcDicTypeTransl{equation}{name-sg}{equation}
\zcDicTypeTransl{equation}{Name-pl}{Equations}
\zcDicTypeTransl{equation}{name-pl}{equations}
\zcDicTypeTransl{equation}{Name-sg-ab}{Eq.}
\zcDicTypeTransl{equation}{name-sg-ab}{eq.}
\zcDicTypeTransl{equation}{Name-pl-ab}{Eqs.}
\zcDicTypeTransl{equation}{name-pl-ab}{eqs.}
\zcDicTypeTransl{equation}{refpre-in}{(}
\zcDicTypeTransl{equation}{refpos-in}{)}

\zcDicTypeTransl{theorem}{Name-sg}{Theorem}
\zcDicTypeTransl{theorem}{name-sg}{theorem}
\zcDicTypeTransl{theorem}{Name-pl}{Theorems}
\zcDicTypeTransl{theorem}{name-pl}{theorems}

\zcDicTypeTransl{lemma}{Name-sg}{Lemma}
\zcDicTypeTransl{lemma}{name-sg}{lemma}
\zcDicTypeTransl{lemma}{Name-pl}{Lemmas}
\zcDicTypeTransl{lemma}{name-pl}{lemmas}

\zcDicTypeTransl{corollary}{Name-sg}{Corollary}
\zcDicTypeTransl{corollary}{name-sg}{corollary}
\zcDicTypeTransl{corollary}{Name-pl}{Corollaries}
\zcDicTypeTransl{corollary}{name-pl}{corollaries}

\zcDicTypeTransl{proposition}{Name-sg}{Proposition}
\zcDicTypeTransl{proposition}{name-sg}{proposition}
\zcDicTypeTransl{proposition}{Name-pl}{Propositions}
\zcDicTypeTransl{proposition}{name-pl}{propositions}

\zcDicTypeTransl{definition}{Name-sg}{Definition}
\zcDicTypeTransl{definition}{name-sg}{definition}
\zcDicTypeTransl{definition}{Name-pl}{Definitions}
\zcDicTypeTransl{definition}{name-pl}{definitions}

\zcDicTypeTransl{proof}{Name-sg}{Proof}
\zcDicTypeTransl{proof}{name-sg}{proof}
\zcDicTypeTransl{proof}{Name-pl}{Proofs}
\zcDicTypeTransl{proof}{name-pl}{proofs}

\zcDicTypeTransl{result}{Name-sg}{Result}
\zcDicTypeTransl{result}{name-sg}{result}
\zcDicTypeTransl{result}{Name-pl}{Results}
\zcDicTypeTransl{result}{name-pl}{results}

\zcDicTypeTransl{example}{Name-sg}{Example}
\zcDicTypeTransl{example}{name-sg}{example}
\zcDicTypeTransl{example}{Name-pl}{Examples}
\zcDicTypeTransl{example}{name-pl}{examples}

\zcDicTypeTransl{remark}{Name-sg}{Remark}
\zcDicTypeTransl{remark}{name-sg}{remark}
\zcDicTypeTransl{remark}{Name-pl}{Remarks}
\zcDicTypeTransl{remark}{name-pl}{remarks}

\zcDicTypeTransl{algorithm}{Name-sg}{Algorithm}
\zcDicTypeTransl{algorithm}{name-sg}{algorithm}
\zcDicTypeTransl{algorithm}{Name-pl}{Algorithms}
\zcDicTypeTransl{algorithm}{name-pl}{algorithms}

\zcDicTypeTransl{listing}{Name-sg}{Listing}
\zcDicTypeTransl{listing}{name-sg}{listing}
\zcDicTypeTransl{listing}{Name-pl}{Listings}
\zcDicTypeTransl{listing}{name-pl}{listings}

\zcDicTypeTransl{exercise}{Name-sg}{Exercise}
\zcDicTypeTransl{exercise}{name-sg}{exercise}
\zcDicTypeTransl{exercise}{Name-pl}{Exercises}
\zcDicTypeTransl{exercise}{name-pl}{exercises}

\zcDicTypeTransl{solution}{Name-sg}{Solution}
\zcDicTypeTransl{solution}{name-sg}{solution}
\zcDicTypeTransl{solution}{Name-pl}{Solutions}
\zcDicTypeTransl{solution}{name-pl}{solutions}
%    \end{macrocode}
%
%    \begin{macrocode}
%</lang-english>
%    \end{macrocode}
%
%
%
% \subsection{German}
%
%    \begin{macrocode}
%<*lang-german>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvideDictionaryFor{German}{zref-clever}

\zcDicDefaultTransl{namesep}{\nobreakspace}
\zcDicDefaultTransl{pairsep}{~und\nobreakspace}
\zcDicDefaultTransl{listsep}{,~}
\zcDicDefaultTransl{lastsep}{~und\nobreakspace}
\zcDicDefaultTransl{tpairsep}{~und\nobreakspace}
\zcDicDefaultTransl{tlistsep}{,~}
\zcDicDefaultTransl{tlastsep}{~und\nobreakspace}
\zcDicDefaultTransl{notesep}{~}
\zcDicDefaultTransl{rangesep}{~bis\nobreakspace}

\zcDicTypeTransl{part}{Name-sg}{Teil}
\zcDicTypeTransl{part}{name-sg}{Teil}
\zcDicTypeTransl{part}{Name-pl}{Teile}
\zcDicTypeTransl{part}{name-pl}{Teile}

\zcDicTypeTransl{chapter}{Name-sg}{Kapitel}
\zcDicTypeTransl{chapter}{name-sg}{Kapitel}
\zcDicTypeTransl{chapter}{Name-pl}{Kapitel}
\zcDicTypeTransl{chapter}{name-pl}{Kapitel}

\zcDicTypeTransl{section}{Name-sg}{Abschnitt}
\zcDicTypeTransl{section}{name-sg}{Abschnitt}
\zcDicTypeTransl{section}{Name-pl}{Abschnitte}
\zcDicTypeTransl{section}{name-pl}{Abschnitte}

\zcDicTypeTransl{paragraph}{Name-sg}{Absatz}
\zcDicTypeTransl{paragraph}{name-sg}{Absatz}
\zcDicTypeTransl{paragraph}{Name-pl}{Absätze}
\zcDicTypeTransl{paragraph}{name-pl}{Absätze}

\zcDicTypeTransl{appendix}{Name-sg}{Anhang}
\zcDicTypeTransl{appendix}{name-sg}{Anhang}
\zcDicTypeTransl{appendix}{Name-pl}{Anhänge}
\zcDicTypeTransl{appendix}{name-pl}{Anhänge}

\zcDicTypeTransl{page}{Name-sg}{Seite}
\zcDicTypeTransl{page}{name-sg}{Seite}
\zcDicTypeTransl{page}{Name-pl}{Seiten}
\zcDicTypeTransl{page}{name-pl}{Seiten}

\zcDicTypeTransl{line}{Name-sg}{Zeile}
\zcDicTypeTransl{line}{name-sg}{Zeile}
\zcDicTypeTransl{line}{Name-pl}{Zeilen}
\zcDicTypeTransl{line}{name-pl}{Zeilen}

\zcDicTypeTransl{figure}{Name-sg}{Abbildung}
\zcDicTypeTransl{figure}{name-sg}{Abbildung}
\zcDicTypeTransl{figure}{Name-pl}{Abbildungen}
\zcDicTypeTransl{figure}{name-pl}{Abbildungen}
\zcDicTypeTransl{figure}{Name-sg-ab}{Abb.}
\zcDicTypeTransl{figure}{name-sg-ab}{Abb.}
\zcDicTypeTransl{figure}{Name-pl-ab}{Abb.}
\zcDicTypeTransl{figure}{name-pl-ab}{Abb.}

\zcDicTypeTransl{table}{Name-sg}{Tabelle}
\zcDicTypeTransl{table}{name-sg}{Tabelle}
\zcDicTypeTransl{table}{Name-pl}{Tabellen}
\zcDicTypeTransl{table}{name-pl}{Tabellen}

\zcDicTypeTransl{item}{Name-sg}{Punkt}
\zcDicTypeTransl{item}{name-sg}{Punkt}
\zcDicTypeTransl{item}{Name-pl}{Punkte}
\zcDicTypeTransl{item}{name-pl}{Punkte}

\zcDicTypeTransl{footnote}{Name-sg}{Fußnote}
\zcDicTypeTransl{footnote}{name-sg}{Fußnote}
\zcDicTypeTransl{footnote}{Name-pl}{Fußnoten}
\zcDicTypeTransl{footnote}{name-pl}{Fußnoten}

\zcDicTypeTransl{note}{Name-sg}{Anmerkung}
\zcDicTypeTransl{note}{name-sg}{Anmerkung}
\zcDicTypeTransl{note}{Name-pl}{Anmerkungen}
\zcDicTypeTransl{note}{name-pl}{Anmerkungen}

\zcDicTypeTransl{equation}{Name-sg}{Gleichung}
\zcDicTypeTransl{equation}{name-sg}{Gleichung}
\zcDicTypeTransl{equation}{Name-pl}{Gleichungen}
\zcDicTypeTransl{equation}{name-pl}{Gleichungen}
\zcDicTypeTransl{equation}{refpre-in}{(}
\zcDicTypeTransl{equation}{refpos-in}{)}

\zcDicTypeTransl{theorem}{Name-sg}{Theorem}
\zcDicTypeTransl{theorem}{name-sg}{Theorem}
\zcDicTypeTransl{theorem}{Name-pl}{Theoreme}
\zcDicTypeTransl{theorem}{name-pl}{Theoreme}

\zcDicTypeTransl{lemma}{Name-sg}{Lemma}
\zcDicTypeTransl{lemma}{name-sg}{Lemma}
\zcDicTypeTransl{lemma}{Name-pl}{Lemmata}
\zcDicTypeTransl{lemma}{name-pl}{Lemmata}

\zcDicTypeTransl{corollary}{Name-sg}{Korollar}
\zcDicTypeTransl{corollary}{name-sg}{Korollar}
\zcDicTypeTransl{corollary}{Name-pl}{Korollare}
\zcDicTypeTransl{corollary}{name-pl}{Korollare}

\zcDicTypeTransl{proposition}{Name-sg}{Satz}
\zcDicTypeTransl{proposition}{name-sg}{Satz}
\zcDicTypeTransl{proposition}{Name-pl}{Sätze}
\zcDicTypeTransl{proposition}{name-pl}{Sätze}

\zcDicTypeTransl{definition}{Name-sg}{Definition}
\zcDicTypeTransl{definition}{name-sg}{Definition}
\zcDicTypeTransl{definition}{Name-pl}{Definitionen}
\zcDicTypeTransl{definition}{name-pl}{Definitionen}

\zcDicTypeTransl{proof}{Name-sg}{Beweis}
\zcDicTypeTransl{proof}{name-sg}{Beweis}
\zcDicTypeTransl{proof}{Name-pl}{Beweise}
\zcDicTypeTransl{proof}{name-pl}{Beweise}

\zcDicTypeTransl{result}{Name-sg}{Ergebnis}
\zcDicTypeTransl{result}{name-sg}{Ergebnis}
\zcDicTypeTransl{result}{Name-pl}{Ergebnisse}
\zcDicTypeTransl{result}{name-pl}{Ergebnisse}

\zcDicTypeTransl{example}{Name-sg}{Beispiel}
\zcDicTypeTransl{example}{name-sg}{Beispiel}
\zcDicTypeTransl{example}{Name-pl}{Beispiele}
\zcDicTypeTransl{example}{name-pl}{Beispiele}

\zcDicTypeTransl{remark}{Name-sg}{Bemerkung}
\zcDicTypeTransl{remark}{name-sg}{Bemerkung}
\zcDicTypeTransl{remark}{Name-pl}{Bemerkungen}
\zcDicTypeTransl{remark}{name-pl}{Bemerkungen}

\zcDicTypeTransl{algorithm}{Name-sg}{Algorithmus}
\zcDicTypeTransl{algorithm}{name-sg}{Algorithmus}
\zcDicTypeTransl{algorithm}{Name-pl}{Algorithmen}
\zcDicTypeTransl{algorithm}{name-pl}{Algorithmen}

\zcDicTypeTransl{listing}{Name-sg}{Listing} % CHECK
\zcDicTypeTransl{listing}{name-sg}{Listing} % CHECK
\zcDicTypeTransl{listing}{Name-pl}{Listings} % CHECK
\zcDicTypeTransl{listing}{name-pl}{Listings} % CHECK

\zcDicTypeTransl{exercise}{Name-sg}{Übungsaufgabe}
\zcDicTypeTransl{exercise}{name-sg}{Übungsaufgabe}
\zcDicTypeTransl{exercise}{Name-pl}{Übungsaufgaben}
\zcDicTypeTransl{exercise}{name-pl}{Übungsaufgaben}

\zcDicTypeTransl{solution}{Name-sg}{Lösung}
\zcDicTypeTransl{solution}{name-sg}{Lösung}
\zcDicTypeTransl{solution}{Name-pl}{Lösungen}
\zcDicTypeTransl{solution}{name-pl}{Lösungen}
%    \end{macrocode}
%
%    \begin{macrocode}
%</lang-german>
%    \end{macrocode}
%
%
%
% \subsection{French}
%
%    \begin{macrocode}
%<*lang-french>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvideDictionaryFor{French}{zref-clever}

\zcDicDefaultTransl{namesep}{\nobreakspace}
\zcDicDefaultTransl{pairsep}{~et\nobreakspace}
\zcDicDefaultTransl{listsep}{,~}
\zcDicDefaultTransl{lastsep}{~et\nobreakspace}
\zcDicDefaultTransl{tpairsep}{~et\nobreakspace}
\zcDicDefaultTransl{tlistsep}{,~}
\zcDicDefaultTransl{tlastsep}{~et\nobreakspace}
\zcDicDefaultTransl{notesep}{~}
\zcDicDefaultTransl{rangesep}{~à\nobreakspace}

\zcDicTypeTransl{part}{Name-sg}{Partie}
\zcDicTypeTransl{part}{name-sg}{partie}
\zcDicTypeTransl{part}{Name-pl}{Parties}
\zcDicTypeTransl{part}{name-pl}{parties}

\zcDicTypeTransl{chapter}{Name-sg}{Chapitre}
\zcDicTypeTransl{chapter}{name-sg}{chapitre}
\zcDicTypeTransl{chapter}{Name-pl}{Chapitres}
\zcDicTypeTransl{chapter}{name-pl}{chapitres}

\zcDicTypeTransl{section}{Name-sg}{Section}
\zcDicTypeTransl{section}{name-sg}{section}
\zcDicTypeTransl{section}{Name-pl}{Sections}
\zcDicTypeTransl{section}{name-pl}{sections}

\zcDicTypeTransl{paragraph}{Name-sg}{Paragraphe}
\zcDicTypeTransl{paragraph}{name-sg}{paragraphe}
\zcDicTypeTransl{paragraph}{Name-pl}{Paragraphes}
\zcDicTypeTransl{paragraph}{name-pl}{paragraphes}

\zcDicTypeTransl{appendix}{Name-sg}{Annexe}
\zcDicTypeTransl{appendix}{name-sg}{annexe}
\zcDicTypeTransl{appendix}{Name-pl}{Annexes}
\zcDicTypeTransl{appendix}{name-pl}{annexes}

\zcDicTypeTransl{page}{Name-sg}{Page}
\zcDicTypeTransl{page}{name-sg}{page}
\zcDicTypeTransl{page}{Name-pl}{Pages}
\zcDicTypeTransl{page}{name-pl}{pages}

\zcDicTypeTransl{line}{Name-sg}{Ligne}
\zcDicTypeTransl{line}{name-sg}{ligne}
\zcDicTypeTransl{line}{Name-pl}{Lignes}
\zcDicTypeTransl{line}{name-pl}{lignes}

\zcDicTypeTransl{figure}{Name-sg}{Figure}
\zcDicTypeTransl{figure}{name-sg}{figure}
\zcDicTypeTransl{figure}{Name-pl}{Figures}
\zcDicTypeTransl{figure}{name-pl}{figures}

\zcDicTypeTransl{table}{Name-sg}{Table}
\zcDicTypeTransl{table}{name-sg}{table}
\zcDicTypeTransl{table}{Name-pl}{Tables}
\zcDicTypeTransl{table}{name-pl}{tables}

\zcDicTypeTransl{item}{Name-sg}{Point}
\zcDicTypeTransl{item}{name-sg}{point}
\zcDicTypeTransl{item}{Name-pl}{Points}
\zcDicTypeTransl{item}{name-pl}{points}

\zcDicTypeTransl{footnote}{Name-sg}{Note}
\zcDicTypeTransl{footnote}{name-sg}{note}
\zcDicTypeTransl{footnote}{Name-pl}{Notes}
\zcDicTypeTransl{footnote}{name-pl}{notes}

\zcDicTypeTransl{note}{Name-sg}{Note}
\zcDicTypeTransl{note}{name-sg}{note}
\zcDicTypeTransl{note}{Name-pl}{Notes}
\zcDicTypeTransl{note}{name-pl}{notes}

\zcDicTypeTransl{equation}{Name-sg}{Équation}
\zcDicTypeTransl{equation}{name-sg}{équation}
\zcDicTypeTransl{equation}{Name-pl}{Équations}
\zcDicTypeTransl{equation}{name-pl}{équations}
\zcDicTypeTransl{equation}{refpre-in}{(}
\zcDicTypeTransl{equation}{refpos-in}{)}

\zcDicTypeTransl{theorem}{Name-sg}{Théorème}
\zcDicTypeTransl{theorem}{name-sg}{théorème}
\zcDicTypeTransl{theorem}{Name-pl}{Théorèmes}
\zcDicTypeTransl{theorem}{name-pl}{théorèmes}

\zcDicTypeTransl{lemma}{Name-sg}{Lemme}
\zcDicTypeTransl{lemma}{name-sg}{lemme}
\zcDicTypeTransl{lemma}{Name-pl}{Lemmes}
\zcDicTypeTransl{lemma}{name-pl}{lemmes}

\zcDicTypeTransl{corollary}{Name-sg}{Corollaire}
\zcDicTypeTransl{corollary}{name-sg}{corollaire}
\zcDicTypeTransl{corollary}{Name-pl}{Corollaires}
\zcDicTypeTransl{corollary}{name-pl}{corollaires}

\zcDicTypeTransl{proposition}{Name-sg}{Proposition}
\zcDicTypeTransl{proposition}{name-sg}{proposition}
\zcDicTypeTransl{proposition}{Name-pl}{Propositions}
\zcDicTypeTransl{proposition}{name-pl}{propositions}

\zcDicTypeTransl{definition}{Name-sg}{Définition}
\zcDicTypeTransl{definition}{name-sg}{définition}
\zcDicTypeTransl{definition}{Name-pl}{Définitions}
\zcDicTypeTransl{definition}{name-pl}{définitions}

\zcDicTypeTransl{proof}{Name-sg}{Démonstration}
\zcDicTypeTransl{proof}{name-sg}{démonstration}
\zcDicTypeTransl{proof}{Name-pl}{Démonstrations}
\zcDicTypeTransl{proof}{name-pl}{démonstrations}

\zcDicTypeTransl{result}{Name-sg}{Résultat}
\zcDicTypeTransl{result}{name-sg}{résultat}
\zcDicTypeTransl{result}{Name-pl}{Résultats}
\zcDicTypeTransl{result}{name-pl}{résultats}

\zcDicTypeTransl{example}{Name-sg}{Exemple}
\zcDicTypeTransl{example}{name-sg}{exemple}
\zcDicTypeTransl{example}{Name-pl}{Exemples}
\zcDicTypeTransl{example}{name-pl}{exemples}

\zcDicTypeTransl{remark}{Name-sg}{Remarque}
\zcDicTypeTransl{remark}{name-sg}{remarque}
\zcDicTypeTransl{remark}{Name-pl}{Remarques}
\zcDicTypeTransl{remark}{name-pl}{remarques}

\zcDicTypeTransl{algorithm}{Name-sg}{Algorithme}
\zcDicTypeTransl{algorithm}{name-sg}{algorithme}
\zcDicTypeTransl{algorithm}{Name-pl}{Algorithmes}
\zcDicTypeTransl{algorithm}{name-pl}{algorithmes}

\zcDicTypeTransl{listing}{Name-sg}{Liste}
\zcDicTypeTransl{listing}{name-sg}{liste}
\zcDicTypeTransl{listing}{Name-pl}{Listes}
\zcDicTypeTransl{listing}{name-pl}{listes}

\zcDicTypeTransl{exercise}{Name-sg}{Exercice}
\zcDicTypeTransl{exercise}{name-sg}{exercice}
\zcDicTypeTransl{exercise}{Name-pl}{Exercices}
\zcDicTypeTransl{exercise}{name-pl}{exercices}

\zcDicTypeTransl{solution}{Name-sg}{Solution}
\zcDicTypeTransl{solution}{name-sg}{solution}
\zcDicTypeTransl{solution}{Name-pl}{Solutions}
\zcDicTypeTransl{solution}{name-pl}{solutions}
%    \end{macrocode}
%
%    \begin{macrocode}
%</lang-french>
%    \end{macrocode}
%
%
%
% \subsection{Portuguese}
%
%    \begin{macrocode}
%<*lang-portuguese>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvideDictionaryFor{Portuguese}{zref-clever}

\zcDicDefaultTransl{namesep}{\nobreakspace}
\zcDicDefaultTransl{pairsep}{~e\nobreakspace}
\zcDicDefaultTransl{listsep}{,~}
\zcDicDefaultTransl{lastsep}{~e\nobreakspace}
\zcDicDefaultTransl{tpairsep}{~e\nobreakspace}
\zcDicDefaultTransl{tlistsep}{,~}
\zcDicDefaultTransl{tlastsep}{~e\nobreakspace}
\zcDicDefaultTransl{notesep}{~}
\zcDicDefaultTransl{rangesep}{~a\nobreakspace}

\zcDicTypeTransl{part}{Name-sg}{Parte}
\zcDicTypeTransl{part}{name-sg}{parte}
\zcDicTypeTransl{part}{Name-pl}{Partes}
\zcDicTypeTransl{part}{name-pl}{partes}

\zcDicTypeTransl{chapter}{Name-sg}{Capítulo}
\zcDicTypeTransl{chapter}{name-sg}{capítulo}
\zcDicTypeTransl{chapter}{Name-pl}{Capítulos}
\zcDicTypeTransl{chapter}{name-pl}{capítulos}

\zcDicTypeTransl{section}{Name-sg}{Seção}
\zcDicTypeTransl{section}{name-sg}{seção}
\zcDicTypeTransl{section}{Name-pl}{Seções}
\zcDicTypeTransl{section}{name-pl}{seções}

\zcDicTypeTransl{paragraph}{Name-sg}{Parágrafo}
\zcDicTypeTransl{paragraph}{name-sg}{parágrafo}
\zcDicTypeTransl{paragraph}{Name-pl}{Parágrafos}
\zcDicTypeTransl{paragraph}{name-pl}{parágrafos}
\zcDicTypeTransl{paragraph}{Name-sg-ab}{Par.}
\zcDicTypeTransl{paragraph}{name-sg-ab}{par.}
\zcDicTypeTransl{paragraph}{Name-pl-ab}{Par.}
\zcDicTypeTransl{paragraph}{name-pl-ab}{par.}

\zcDicTypeTransl{appendix}{Name-sg}{Apêndice}
\zcDicTypeTransl{appendix}{name-sg}{apêndice}
\zcDicTypeTransl{appendix}{Name-pl}{Apêndices}
\zcDicTypeTransl{appendix}{name-pl}{apêndices}

\zcDicTypeTransl{page}{Name-sg}{Página}
\zcDicTypeTransl{page}{name-sg}{página}
\zcDicTypeTransl{page}{Name-pl}{Páginas}
\zcDicTypeTransl{page}{name-pl}{páginas}
\zcDicTypeTransl{page}{name-sg-ab}{p.}
\zcDicTypeTransl{page}{name-pl-ab}{pp.}

\zcDicTypeTransl{line}{Name-sg}{Linha}
\zcDicTypeTransl{line}{name-sg}{linha}
\zcDicTypeTransl{line}{Name-pl}{Linhas}
\zcDicTypeTransl{line}{name-pl}{linhas}

\zcDicTypeTransl{figure}{Name-sg}{Figura}
\zcDicTypeTransl{figure}{name-sg}{figura}
\zcDicTypeTransl{figure}{Name-pl}{Figuras}
\zcDicTypeTransl{figure}{name-pl}{figuras}
\zcDicTypeTransl{figure}{Name-sg-ab}{Fig.}
\zcDicTypeTransl{figure}{name-sg-ab}{fig.}
\zcDicTypeTransl{figure}{Name-pl-ab}{Figs.}
\zcDicTypeTransl{figure}{name-pl-ab}{figs.}

\zcDicTypeTransl{table}{Name-sg}{Tabela}
\zcDicTypeTransl{table}{name-sg}{tabela}
\zcDicTypeTransl{table}{Name-pl}{Tabelas}
\zcDicTypeTransl{table}{name-pl}{tabelas}

\zcDicTypeTransl{item}{Name-sg}{Item}
\zcDicTypeTransl{item}{name-sg}{item}
\zcDicTypeTransl{item}{Name-pl}{Itens}
\zcDicTypeTransl{item}{name-pl}{itens}

\zcDicTypeTransl{footnote}{Name-sg}{Nota}
\zcDicTypeTransl{footnote}{name-sg}{nota}
\zcDicTypeTransl{footnote}{Name-pl}{Notas}
\zcDicTypeTransl{footnote}{name-pl}{notas}

\zcDicTypeTransl{note}{Name-sg}{Nota}
\zcDicTypeTransl{note}{name-sg}{nota}
\zcDicTypeTransl{note}{Name-pl}{Notas}
\zcDicTypeTransl{note}{name-pl}{notas}

\zcDicTypeTransl{equation}{Name-sg}{Equação}
\zcDicTypeTransl{equation}{name-sg}{equação}
\zcDicTypeTransl{equation}{Name-pl}{Equações}
\zcDicTypeTransl{equation}{name-pl}{equações}
\zcDicTypeTransl{equation}{Name-sg-ab}{Eq.}
\zcDicTypeTransl{equation}{name-sg-ab}{eq.}
\zcDicTypeTransl{equation}{Name-pl-ab}{Eqs.}
\zcDicTypeTransl{equation}{name-pl-ab}{eqs.}
\zcDicTypeTransl{equation}{refpre-in}{(}
\zcDicTypeTransl{equation}{refpos-in}{)}

\zcDicTypeTransl{theorem}{Name-sg}{Teorema}
\zcDicTypeTransl{theorem}{name-sg}{teorema}
\zcDicTypeTransl{theorem}{Name-pl}{Teoremas}
\zcDicTypeTransl{theorem}{name-pl}{teoremas}

\zcDicTypeTransl{lemma}{Name-sg}{Lema}
\zcDicTypeTransl{lemma}{name-sg}{lema}
\zcDicTypeTransl{lemma}{Name-pl}{Lemas}
\zcDicTypeTransl{lemma}{name-pl}{lemas}

\zcDicTypeTransl{corollary}{Name-sg}{Corolário}
\zcDicTypeTransl{corollary}{name-sg}{corolário}
\zcDicTypeTransl{corollary}{Name-pl}{Corolários}
\zcDicTypeTransl{corollary}{name-pl}{corolários}

\zcDicTypeTransl{proposition}{Name-sg}{Proposição}
\zcDicTypeTransl{proposition}{name-sg}{proposição}
\zcDicTypeTransl{proposition}{Name-pl}{Proposições}
\zcDicTypeTransl{proposition}{name-pl}{proposições}

\zcDicTypeTransl{definition}{Name-sg}{Definição}
\zcDicTypeTransl{definition}{name-sg}{definição}
\zcDicTypeTransl{definition}{Name-pl}{Definições}
\zcDicTypeTransl{definition}{name-pl}{definições}

\zcDicTypeTransl{proof}{Name-sg}{Demonstração}
\zcDicTypeTransl{proof}{name-sg}{demonstração}
\zcDicTypeTransl{proof}{Name-pl}{Demonstrações}
\zcDicTypeTransl{proof}{name-pl}{demonstrações}

\zcDicTypeTransl{result}{Name-sg}{Resultado}
\zcDicTypeTransl{result}{name-sg}{resultado}
\zcDicTypeTransl{result}{Name-pl}{Resultados}
\zcDicTypeTransl{result}{name-pl}{resultados}

\zcDicTypeTransl{example}{Name-sg}{Exemplo}
\zcDicTypeTransl{example}{name-sg}{exemplo}
\zcDicTypeTransl{example}{Name-pl}{Exemplos}
\zcDicTypeTransl{example}{name-pl}{exemplos}

\zcDicTypeTransl{remark}{Name-sg}{Observação}
\zcDicTypeTransl{remark}{name-sg}{observação}
\zcDicTypeTransl{remark}{Name-pl}{Observações}
\zcDicTypeTransl{remark}{name-pl}{observações}

\zcDicTypeTransl{algorithm}{Name-sg}{Algoritmo}
\zcDicTypeTransl{algorithm}{name-sg}{algoritmo}
\zcDicTypeTransl{algorithm}{Name-pl}{Algoritmos}
\zcDicTypeTransl{algorithm}{name-pl}{algoritmos}

\zcDicTypeTransl{listing}{Name-sg}{Listagem}
\zcDicTypeTransl{listing}{name-sg}{listagem}
\zcDicTypeTransl{listing}{Name-pl}{Listagens}
\zcDicTypeTransl{listing}{name-pl}{listagens}

\zcDicTypeTransl{exercise}{Name-sg}{Exercício}
\zcDicTypeTransl{exercise}{name-sg}{exercício}
\zcDicTypeTransl{exercise}{Name-pl}{Exercícios}
\zcDicTypeTransl{exercise}{name-pl}{exercícios}

\zcDicTypeTransl{solution}{Name-sg}{Solução}
\zcDicTypeTransl{solution}{name-sg}{solução}
\zcDicTypeTransl{solution}{Name-pl}{Soluções}
\zcDicTypeTransl{solution}{name-pl}{soluções}
%    \end{macrocode}
%
%    \begin{macrocode}
%</lang-portuguese>
%    \end{macrocode}
%
%
%
% \subsection{Spanish}
%
%    \begin{macrocode}
%<*lang-spanish>
%    \end{macrocode}
%
%    \begin{macrocode}
\ProvideDictionaryFor{Spanish}{zref-clever}

\zcDicDefaultTransl{namesep}{\nobreakspace}
\zcDicDefaultTransl{pairsep}{~y\nobreakspace}
\zcDicDefaultTransl{listsep}{,~}
\zcDicDefaultTransl{lastsep}{~y\nobreakspace}
\zcDicDefaultTransl{tpairsep}{~y\nobreakspace}
\zcDicDefaultTransl{tlistsep}{,~}
\zcDicDefaultTransl{tlastsep}{~y\nobreakspace}
\zcDicDefaultTransl{notesep}{~}
\zcDicDefaultTransl{rangesep}{~a\nobreakspace}

\zcDicTypeTransl{part}{Name-sg}{Parte}
\zcDicTypeTransl{part}{name-sg}{parte}
\zcDicTypeTransl{part}{Name-pl}{Partes}
\zcDicTypeTransl{part}{name-pl}{partes}

\zcDicTypeTransl{chapter}{Name-sg}{Capítulo}
\zcDicTypeTransl{chapter}{name-sg}{capítulo}
\zcDicTypeTransl{chapter}{Name-pl}{Capítulos}
\zcDicTypeTransl{chapter}{name-pl}{capítulos}

\zcDicTypeTransl{section}{Name-sg}{Sección}
\zcDicTypeTransl{section}{name-sg}{sección}
\zcDicTypeTransl{section}{Name-pl}{Secciones}
\zcDicTypeTransl{section}{name-pl}{secciones}

\zcDicTypeTransl{paragraph}{Name-sg}{Párrafo}
\zcDicTypeTransl{paragraph}{name-sg}{párrafo}
\zcDicTypeTransl{paragraph}{Name-pl}{Párrafos}
\zcDicTypeTransl{paragraph}{name-pl}{párrafos}

\zcDicTypeTransl{appendix}{Name-sg}{Apéndice}
\zcDicTypeTransl{appendix}{name-sg}{apéndice}
\zcDicTypeTransl{appendix}{Name-pl}{Apéndices}
\zcDicTypeTransl{appendix}{name-pl}{apéndices}

\zcDicTypeTransl{page}{Name-sg}{Página}
\zcDicTypeTransl{page}{name-sg}{página}
\zcDicTypeTransl{page}{Name-pl}{Páginas}
\zcDicTypeTransl{page}{name-pl}{páginas}

\zcDicTypeTransl{line}{Name-sg}{Línea}
\zcDicTypeTransl{line}{name-sg}{línea}
\zcDicTypeTransl{line}{Name-pl}{Líneas}
\zcDicTypeTransl{line}{name-pl}{líneas}

\zcDicTypeTransl{figure}{Name-sg}{Figura}
\zcDicTypeTransl{figure}{name-sg}{figura}
\zcDicTypeTransl{figure}{Name-pl}{Figuras}
\zcDicTypeTransl{figure}{name-pl}{figuras}

\zcDicTypeTransl{table}{Name-sg}{Cuadro}
\zcDicTypeTransl{table}{name-sg}{cuadro}
\zcDicTypeTransl{table}{Name-pl}{Cuadros}
\zcDicTypeTransl{table}{name-pl}{cuadros}

\zcDicTypeTransl{item}{Name-sg}{Punto}
\zcDicTypeTransl{item}{name-sg}{punto}
\zcDicTypeTransl{item}{Name-pl}{Puntos}
\zcDicTypeTransl{item}{name-pl}{puntos}

\zcDicTypeTransl{footnote}{Name-sg}{Nota}
\zcDicTypeTransl{footnote}{name-sg}{nota}
\zcDicTypeTransl{footnote}{Name-pl}{Notas}
\zcDicTypeTransl{footnote}{name-pl}{notas}

\zcDicTypeTransl{note}{Name-sg}{Nota}
\zcDicTypeTransl{note}{name-sg}{nota}
\zcDicTypeTransl{note}{Name-pl}{Notas}
\zcDicTypeTransl{note}{name-pl}{notas}

\zcDicTypeTransl{equation}{Name-sg}{Ecuación}
\zcDicTypeTransl{equation}{name-sg}{ecuación}
\zcDicTypeTransl{equation}{Name-pl}{Ecuaciones}
\zcDicTypeTransl{equation}{name-pl}{ecuaciones}
\zcDicTypeTransl{equation}{refpre-in}{(}
\zcDicTypeTransl{equation}{refpos-in}{)}

\zcDicTypeTransl{theorem}{Name-sg}{Teorema}
\zcDicTypeTransl{theorem}{name-sg}{teorema}
\zcDicTypeTransl{theorem}{Name-pl}{Teoremas}
\zcDicTypeTransl{theorem}{name-pl}{teoremas}

\zcDicTypeTransl{lemma}{Name-sg}{Lema}
\zcDicTypeTransl{lemma}{name-sg}{lema}
\zcDicTypeTransl{lemma}{Name-pl}{Lemas}
\zcDicTypeTransl{lemma}{name-pl}{lemas}

\zcDicTypeTransl{corollary}{Name-sg}{Corolario}
\zcDicTypeTransl{corollary}{name-sg}{corolario}
\zcDicTypeTransl{corollary}{Name-pl}{Corolarios}
\zcDicTypeTransl{corollary}{name-pl}{corolarios}

\zcDicTypeTransl{proposition}{Name-sg}{Proposición}
\zcDicTypeTransl{proposition}{name-sg}{proposición}
\zcDicTypeTransl{proposition}{Name-pl}{Proposiciones}
\zcDicTypeTransl{proposition}{name-pl}{proposiciones}

\zcDicTypeTransl{definition}{Name-sg}{Definición}
\zcDicTypeTransl{definition}{name-sg}{definición}
\zcDicTypeTransl{definition}{Name-pl}{Definiciones}
\zcDicTypeTransl{definition}{name-pl}{definiciones}

\zcDicTypeTransl{proof}{Name-sg}{Demostración}
\zcDicTypeTransl{proof}{name-sg}{demostración}
\zcDicTypeTransl{proof}{Name-pl}{Demostraciones}
\zcDicTypeTransl{proof}{name-pl}{demostraciones}

\zcDicTypeTransl{result}{Name-sg}{Resultado}
\zcDicTypeTransl{result}{name-sg}{resultado}
\zcDicTypeTransl{result}{Name-pl}{Resultados}
\zcDicTypeTransl{result}{name-pl}{resultados}

\zcDicTypeTransl{example}{Name-sg}{Ejemplo}
\zcDicTypeTransl{example}{name-sg}{ejemplo}
\zcDicTypeTransl{example}{Name-pl}{Ejemplos}
\zcDicTypeTransl{example}{name-pl}{ejemplos}

\zcDicTypeTransl{remark}{Name-sg}{Observación}
\zcDicTypeTransl{remark}{name-sg}{observación}
\zcDicTypeTransl{remark}{Name-pl}{Observaciones}
\zcDicTypeTransl{remark}{name-pl}{observaciones}

\zcDicTypeTransl{algorithm}{Name-sg}{Algoritmo}
\zcDicTypeTransl{algorithm}{name-sg}{algoritmo}
\zcDicTypeTransl{algorithm}{Name-pl}{Algoritmos}
\zcDicTypeTransl{algorithm}{name-pl}{algoritmos}

\zcDicTypeTransl{listing}{Name-sg}{Listado}
\zcDicTypeTransl{listing}{name-sg}{listado}
\zcDicTypeTransl{listing}{Name-pl}{Listados}
\zcDicTypeTransl{listing}{name-pl}{listados}

\zcDicTypeTransl{exercise}{Name-sg}{Ejercicio}
\zcDicTypeTransl{exercise}{name-sg}{ejercicio}
\zcDicTypeTransl{exercise}{Name-pl}{Ejercicios}
\zcDicTypeTransl{exercise}{name-pl}{ejercicios}

\zcDicTypeTransl{solution}{Name-sg}{Solución}
\zcDicTypeTransl{solution}{name-sg}{solución}
\zcDicTypeTransl{solution}{Name-pl}{Soluciones}
\zcDicTypeTransl{solution}{name-pl}{soluciones}
%    \end{macrocode}
%
%    \begin{macrocode}
%</lang-spanish>
%    \end{macrocode}
%
%
% \PrintIndex
%
% \end{implementation}
