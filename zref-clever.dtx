% \iffalse meta-comment
%
% File: zref-clever.dtx
%
% This file is part of the LaTeX package "zref-clever".
%
% Copyright (C) 2021  Gustavo Barros
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file:
%
%    https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
%
% This work is "maintained" (as per LPPL maintenance status) by
% Gustavo Barros.
%
% This work consists of the files zref-clever.dtx,
%                                 zref-clever.ins,
%                                 zref-clever.tex,
%                                 zref-clever-code.tex,
%           and the derived files zref-clever.sty and
%                                 zref-clever.pdf,
%                                 zref-clever-code.pdf.
%
% The released version of this package is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the package can be found at
%
%    https://github.com/gusbrs/zref-clever
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}
% Have \GetFileInfo pick up date and version data
\usepackage{zref-check}
\NewDocumentCommand\opt{m}{\texttt{#1}}
\MakeShortVerb{\|}
\begin{document}
  \DocInput{zref-clever.dtx}
\end{document}
%</driver>
% \fi
%
%
% \begin{documentation}
%
%
% \end{documentation}
%
%
%
% \begin{implementation}
%
% \section{Initial setup}
%
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=zrefclever>
%    \end{macrocode}
%
%
%
% Identify the package.
%    \begin{macrocode}
\ProvidesExplPackage {zref-clever} {2021-08-09} {0.1.0-alpha}
  {Do-what-I-mean cross-references based on zref}
%    \end{macrocode}
%
% \section{Dependencies}
%
%    \begin{macrocode}
\RequirePackage { zref-user }
\RequirePackage { zref-counter }
\RequirePackage { zref-abspage }
\RequirePackage { translations }
%    \end{macrocode}
%
%
%
% \section{\pkg{zref} setup}
%
% We are interested in three basic label elements: the reference itself, the
% page, and the counter.  The `page' and `counter' are respectively handled by
% modules \pkg{zref-base} and \pkg{zref-counter}.  The \pkg{zref-abspage} also
% provides the `abspage` property which gives us a safe and easy way to sort
% labels on page references.  But the reference itself, stored by \pkg{zref}
% in the `default' field, is somewhat a disputed real estate.  In particular,
% the use of \cs{labelformat} will include there the reference ``prefix'' and
% complicate the job we are trying to do here.  Hence, we isolate
% \cs{the}\meta{counter} and store it ``clean'' in \texttt{zc@thecounter} for
% reserved use.
%
% From the definition of \cs{@currentlabel} done inside \cs{refstepcounter} in
% 'texdoc source2e', section 'ltcounts.dtx'.  We just drop the \cs{p@...}
% prefix.
%    \begin{macrocode}
\zref@newprop { zc@thecounter } { \cs:w the \@currentcounter \cs_end: }
\zref@addprop \ZREF@mainlist { zc@thecounter }
%    \end{macrocode}
%
% However, the moment where the label is set is a privileged one, because at
% this point we have a lot of raw information available.  Information which
% may be difficult to retrieve later on by parsing the reference printed value
% of the counter, which we stored in \texttt{zc@thecounter} above.  Hence, we
% seize the opportunity to store some of that information in a way which eases
% significantly the task of processing the reference later on: i) the counter
% \emph{value}, as a number; ii) the counter values of the set of counters
% which may trigger a reset of the current counter.
%
% The first one is trivial, \cs{c@}\meta{counter} contains the counter's
% numerical value (see `texdoc source2e', section `ltcounts.dtx'), we just
% store it in \texttt{zc@countervalue}.
%    \begin{macrocode}
\zref@newprop { zc@countervalue } { \int_use:c { c@\@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@countervalue }
%    \end{macrocode}
%
% The second one is trickier.  For starters, the counters which may reset the
% current counter are not retrievable from the counter itself, because this
% information is stored with the counter that does the resetting, not with the
% one that gets reset (the list is stored in \cs{cl@}\meta{counter} with
% format |\@elt{countera}\@elt{counterb}\@elt{counterc}|, again see section
% `ltcounts.dtx' in `source2e').  Besides, there may be a chain of resetting
% counters, which must be taken into account.  The procedure below examines a
% set of counters, those included in \cs{g_@@_reseters_seq}, and for each
% counter retrieves its ``within-counters'' recursively.  There is one
% relevant caveat to this procedure: \cs{g_@@_reseters_seq} is populated by
% hand with the ``usual suspects'', there is no way (that I know of) to ensure
% it is exhaustive.  However, it is not that difficult to create a reasonable
% ``usual suspects'' list which, of course, should include the counters for
% the sectioning commands, to start with, and it is easy to add more counters
% to this list if needed.
%
% \begin{variable}{\g_@@_reseters_seq}
%   Stores the list of counters which get examined \cs{AtBeginDocument} as
%   potential ``within-counters'' for other counters.
%    \begin{macrocode}
\seq_set_from_clist:Nn \g_@@_reseters_seq
  {
    part ,
    chapter ,
    section ,
    subsection ,
    subsubsection ,
    paragraph ,
    subparagraph
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[EXP]{\@@_get_within_counters:n}
%   Recursively generate a \emph{sequence} of ``within-counters'' values, for
%   a given \Arg{counter} and leave it in the input stream.  This function
%   must be expandable, since it gets called from \cs{zref@newprop} and is the
%   one responsible for generating the desired information when the label is
%   being set.  Note that the order in which we are getting this information
%   is reversed, since we are navigating the counter reset chain bottom-up.
%   But it is very hard to do otherwise here where we need expandable
%   functions, and easy to handle at the reading side.
%    \begin{macrocode}
\cs_new:Npn \@@_get_within_counters:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \int_use:N \cs:w c@ \@@_counter_reset_by:n {#1} \cs_end: }
        \@@_get_within_counters:f
          { \@@_counter_reset_by:n {#1} }
      }
  }
% Both \texttt{e} and \texttt{f} variants work for the recursive call.
\cs_generate_variant:Nn \@@_get_within_counters:n { o , e , f }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \@@_counter_reset_by:n,
%     \@@_counter_within:nn,
%     \@@_counter_within_aux:nnn
%   }
% Auxiliary functions for \cs{@@_get_within_counters:n}.  They are broken in
% parts to be able to use the expandable mapping functions.  In particular
% \cs{@@_counter_reset_by:n} leaves in the stream the ``within-counter'' which
% resets \Arg{counter}.
%    \begin{macrocode}
\cs_new:Npn \@@_counter_reset_by:n #1
  {
    \bool_case_true:nF
      {
        % TODO Handle exceptions. Start with "enumi...".
        { \c_false_bool } {}
      }
      {
        \seq_map_tokens:Nn \g_@@_reseters_seq
          { \@@_counter_within:nn {#1} }
      }
  }
\cs_new:Npn \@@_counter_within:nn #1#2
  {
    \cs_if_exist:cT { c@ #2 }
      {
        \tl_if_empty:cF { cl@ #2 }
          {
            \tl_map_tokens:cn { cl@ #2 }
              { \@@_counter_within_aux:nnn {#2} {#1} }
          }
      }
  }
\cs_new:Npn \@@_counter_within_aux:nnn #1#2#3
  {
    \str_if_eq:nnT {#2} {#3}
      { \tl_map_break:n { \seq_map_break:n {#1} } }
  }
%    \end{macrocode}
% \end{macro}
%
% Finally, add \texttt{zc@counterwithin} to \pkg{zref}'s \texttt{main}
% property list.
%    \begin{macrocode}
\zref@newprop { zc@counterwithin }
  { \@@_get_within_counters:o { \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@counterwithin }
%    \end{macrocode}
%
% And the `page' itself may also be subject to resetting with
% \cs{refstepcounter} (it is not by default in the standard classes, but it
% \emph{may} be defined to be so).  So we store that too.
%    \begin{macrocode}
\zref@newprop { zc@pagewithin }
  { \@@_get_within_counters:n { page } }
\zref@addprop \ZREF@mainlist { zc@pagewithin }
%    \end{macrocode}
%
%
% A previous version of the same task.  Easier to implement, hence possibly
% more robust (for me to maintain, that is\dots{}), but which required to
% assess the state of the reset counters \cs{AtBeginDocument}, so does not get
% mid-document changes.  Keep it around for the time being, in case we face
% trouble with the expandable version.  The procedure here examines a set of
% counters, those included in \cs{g_@@_reseters_seq}, and for each counter
% each of those reset, defines a \texttt{tl} variable with name
% \cs{g_@@_counter_\meta{counter}_within_tl} storing the value of its
% ``within-counter''.  These \texttt{tl} variables are then used by
% \cs{@@_get_within_counters_old:n} to store the desired information when the
% label is actually set.
% \begin{verbatim}
% \cs_new:Npn \@@_get_within_counters_old:n #1
%   {
%     \bool_lazy_and:nnT
%       { \tl_if_exist_p:c { g_@@_counter_ \tl_use:N #1 _within_tl } }
%       {
%         \cs_if_exist_p:c
%           { c@ \use:c { g_@@_counter_ \tl_use:N #1 _within_tl } }
%       }
%       {
%         { \int_use:c { c@ \use:c { g_@@_counter_ \tl_use:N #1 _within_tl } } }
%         \@@_get_within_counters_old:n
%           { \use:c { g_@@_counter_ \tl_use:N #1 _within_tl } }
%       }
%   }
% \end{verbatim}
% Map through \cs{g_@@_reseters_seq} defining \texttt{tl} variables storing,
% for each counter that may be reset, the ``within-counter'' which may do so.
% \begin{verbatim}
% \cs_new:Npn \@@_set_within_counters:
%   {
%     \group_begin:
%       \seq_map_inline:Nn \g_@@_reseters_seq
%         {
%           \cs_if_exist:cT { c@ ##1 }
%             {
%               \cs_set:Npn \@@_elt_aux:n ####1
%                 {
%                   \tl_if_exist:cF { g_@@_counter_ ####1 _within_tl }
%                     { \tl_gset:cx { g_@@_counter_ ####1 _within_tl } {##1} }
%                 }
%               \cs_set_eq:NN \@elt \@@_elt_aux:n
%               \use:c { cl@ ##1 }
%             }
%         }
%     \group_end:
%   }
% \end{verbatim}
% And run it \cs{AtBeginDocument}.
% \begin{verbatim}
% \AtBeginDocument { \@@_set_within_counters: }
% \end{verbatim}
%
%
% \begin{macro}[EXP]{\@@_page_numbering:}
%   Another piece of information we need and can retrieve at label setting is
%   the type of numbering being used by \cs{thepage}, so that we know when we
%   can (or not) group a set of page references in a range.  To see how
%   \cs{pagenumbering} is constructed, and hence \cs{thepage}'s definition,
%   see 'ltpageno.dtx' in 'texdoc source2e'.
%    \begin{macrocode}
\cs_new:Npn \@@_page_numbering:
  {
    \exp_args:No \tl_map_function:nN
      { \thepage } \@@_page_numbering_aux:n
  }
\cs_new:Npn \@@_page_numbering_aux:n #1
  {
    \tl_case:NnF #1
      {
        \csname {}
        @ {}
        \endcsname { \tl_map_break: }
      }
      {#1}
  }
\zref@newprop* { zc@pagenum } { \@@_page_numbering: }
\zref@addprop \ZREF@mainlist { zc@pagenum }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Plumbing}
%
% \subsection{Counter override}
%
% There are some cases in which differently named references are made to
% document objects sharing the same counter.  Prominently, the environments
% created with the kernel's \cs{newtheorem} command, but the case will be
% considered, and handled generally.
%
% \pkg{cleveref} deals with this by redefining \cs{newtheorem}'s internals and
% retrieve the environment's name, to infer the type and do an ``automatic
% definition'' of theorem-like environments with a reasonable default.  But
% even then, it can only provide the singular form of the cross-reference
% name, and if the plural is ever needed, the name has to be provided manually
% anyway.  It also imposes the restriction of \cs{newtheorem} only being used
% in the preamble, which would be good practice, but \cs{newtheorem} is
% documented to be allowed anywhere in the document (see `texdoc source2e',
% section `ltthm.dtx', comment at the definition of \cs{newtheorem}).  And the
% calls to \cs{newtheorem} must also come after \pkg{cleveref} is loaded.  And
% for this to work, either \pkg{ntheorem} or \pkg{amsthm} must be loaded (as
% stated in the ``Non-Bugs'' section of the documentation).  This automatism
% is, of course, a good thing, but the restrictions are considerable.
%
% Another mechanism \pkg{cleveref} provides for overriding individual labels
% is by adding optional arguments to both \cs{label} and \cs{refstepcounter}
% which receives a ``counter override label type'' and stores that
% \emph{instead} of regular counter with the \cs{newlabel} in the \file{.aux}
% file.
%
% All in all, and since \pkg{zref} spares us of the need to redefine such core
% commands, I think a more general approach, even if a little less automatic,
% is the best for us here.  \pkg{zref}'s data flexibility also helps us in
% this.  The idea is simple, use a variable which serves as a ``flag'', if
% this variable is set and contains something, we store that in the label as
% an \emph{additional} property \texttt{zc@counterover} which, if present,
% will have precedence when we refer to that label.  And this ``flag
% variable'' can be set at appropriate times (it should always be done within
% a group, of course).  For environments, it is trivial with a hook to
% \texttt{env/\meta{env}/begin}.  This can be used for \cs{newtheorem}
% environments to start with.  The use case for the optional argument for
% \cs{label} and \cs{refstepcounter} I do not quite grasp, and it does
% introduce ample opportunity for users to shoot themselves in the foot.
% Still an equivalent could be provided by, for example, defining a document
% command \cs{zclabel}\oart{counterover}\marg{label} which makes a group, sets
% the flag with \meta{counterover}, and calls \cs{zlabel} with \meta{label}.
% Anyway, for the time being, I'll provide the infrastructure for
% environments, covering \cs{newtheorem} with that, and only introduce a
% manual override of the sort if the need indeed arises and is well justified.
%
% Another relevant use case of the same general problem of different names for
% the same counter is the \cs{appendix} which in some document classes,
% including the standard ones, change the sectioning commands looks but, of
% course, keep using the same counter (\file{book.cls} and \file{report.cls}
% reset counters \texttt{chapter} and \texttt{section} to 0, change
% \cs{@chapapp} to use \cs{appendixname} and use \cs{@Alph} for
% \cs{thechapter}; \file{article.cls} resets counters \texttt{section} and
% \texttt{subsection} to 0, and uses \cs{@Alph} for \cs{thesection};
% \file{memoir.cls}, \file{scrbook.cls} and \file{scrarticle.cls} do the same
% as their corresponding standard classes, and sometimes a little more, but
% what interests us here is pretty much the same; see also the \pkg{appendix}
% package).

%
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \PrintIndex
%
% \end{implementation}
%
