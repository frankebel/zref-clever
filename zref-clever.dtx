% \iffalse meta-comment
%
% File: zref-clever.dtx
%
% This file is part of the LaTeX package "zref-clever".
%
% Copyright (C) 2021  Gustavo Barros
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file:
%
%    https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
%
% This work is "maintained" (as per LPPL maintenance status) by
% Gustavo Barros.
%
% This work consists of the files zref-clever.dtx,
%                                 zref-clever.ins,
%                                 zref-clever.tex,
%                                 zref-clever-code.tex,
% and the derived files listed in MANIFEST.md.
%
% The released version of this package is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the package can be found at
%
%    https://github.com/gusbrs/zref-clever
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}
% Have \GetFileInfo pick up date and version data
\usepackage{zref-clever}
\NewDocumentCommand\opt{m}{\texttt{#1}}
\MakeShortVerb{\|}
\begin{document}
  \DocInput{zref-clever.dtx}
\end{document}
%</driver>
% \fi
%
%
% \begin{documentation}
%
% \section{Introduction}
%
%
%
%
% \section{Loading the package}
%
%
%
%
%
%
%
%
% \section{Dependencies}
%
%
%
%
%
%
%
%
% \section{User interface}
%
%
%
%
%
%
%
%
% \section{Options}
%
%
%
%
%
%
%
% \section{Reference Types}
% \label{sec:reference-types}
%
% A ``reference type'' is the basic \pkg{zref-clever} setup unit for
% specifying how a cross-reference group of a certain kind is to be typeset.
% Though, usually, it will have the same name as the underlying \LaTeX{}
% \emph{counter}, they are conceptually different.  \pkg{zref-clever} defines
% \emph{reference types} and an association between each \emph{counter} and
% its \emph{type}, it does not define the counters themselves, which are
% defined by your document.  One \emph{reference type} can be associated with
% one or more \emph{counters}, and a \emph{counter} can be associated with
% different \emph{types} at different points in your document.  But each label
% is stored with only one \emph{type}, as specified by the counter-type
% association at the moment it is set, and that determines how the reference
% to that label is typeset.  References to different \emph{counters} of the
% same \emph{type} are grouped together, and treated alike by \cs{zcref}.  A
% \emph{reference type} may exist even when the \emph{counter} it is
% associated with is not actually defined, and this inconsequential.  In
% practice, the contrary may also happen, a \emph{counter} may be defined but
% we have no \emph{type} for it, but this must be handled by \pkg{zref-clever}
% as a ``missing type'' error (at least, if we try to refer to it).
%
% A \emph{reference type} can be associated with multiple counters because we
% may want to refer to different document elements, with different
% \emph{counters}, with a single name, as a single \emph{type}.  One prominent
% case of this are sectioning commands.  \cs{section}, \cs{subsection}, and
% \cs{subsubsection} have each their counter, but we'd like to refer to all of
% them by ``section''.  The same for \cs{paragraph} and \cs{subparagraph}.
%
% There are also cases in which we may want to use different \emph{reference
% types} to refer to document objects sharing the same \emph{counter}.
% Notably, the environments created with \LaTeX{}'s \cs{newtheorem} command
% and the \cs{appendix}.
%
%
%
% \section{Limitations}
%
%
%
%
%
%
% \section{Acknowledgments}
%
%
%
%
%
%
%
% \section{Change history}
%
%
% A change log with relevant changes for each version, eventual upgrade
% instructions, and upcoming changes, is maintained in the package's
% repository, at
% \url{https://github.com/gusbrs/zref-clever/blob/main/CHANGELOG.md}.
%
%
%
%
% \end{documentation}
%
%
% \begin{implementation}
%
% \section{Initial setup}
%
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=zrefclever>
%    \end{macrocode}
%
% Taking a stance on backward compatibility of the package.  During initial
% development, we have used freely recent features of the kernel (albeit
% refraining from \pkg{l3candidates}, even though I'd have loved to have used
% \cs{bool_case_true:}\dots{}).  We presume \pkg{xparse} (which made to the
% kernel in the 2020-10-01 release), and \pkg{expl3} as well (which made to
% the kernel in the 2020-02-02 release).  We also just use UTF-8 for the
% dictionaries (which became the default input encoding in the 2018-04-01
% release).  Hence, since we would not be able to go much backwards without
% special handling anyway, we make the cut with the inclusion of the new hook
% management system (\pkg{ltcmdhooks}), which is bound to be useful for our
% purposes, and was released with the 2021-06-01 kernel.
%    \begin{macrocode}
\providecommand\IfFormatAtLeastTF{\@ifl@t@r\fmtversion}
\IfFormatAtLeastTF{2021-06-01}
  {}
  {%
    \PackageError{zref-clever}{LaTeX kernel too old}
      {%
        'zref-clever' requires a LaTeX kernel newer than 2021-06-01.%
        \MessageBreak Loading will abort!%
      }%
    \endinput
  }%
%    \end{macrocode}
%
%
% Identify the package.
%    \begin{macrocode}
\ProvidesExplPackage {zref-clever} {2021-09-13} {0.1.0-alpha}
  {Clever LaTeX cross-references based on zref}
%    \end{macrocode}
%
%
% \section{Dependencies}
%
% Required packages.  Besides these, \pkg{zref-hyperref} may also be required
% depending on the presence of \pkg{hyperref} itself and on the \opt{hyperref}
% option.
%
%    \begin{macrocode}
\RequirePackage { zref-base }
\RequirePackage { zref-user }
\RequirePackage { zref-counter }
\RequirePackage { zref-abspage }
\RequirePackage { l3keys2e }
%    \end{macrocode}
%
%
% \section{\pkg{zref} setup}
%
% For the purposes of the package, we need to store some information with the
% labels, some of it standard, some of it not so much.  So, we have to setup
% \pkg{zref} to do so.
%
% Some basic properties are handled by \pkg{zref} itself, or some of its
% modules.  The \texttt{page} and \texttt{counter} properties are respectively
% provided by modules \pkg{zref-base} and \pkg{zref-counter}.  The
% \pkg{zref-abspage} provides the \texttt{abspage} property which gives us a
% safe and easy way to sort labels for page references.
%
% But the reference itself, stored by \pkg{zref-base} in the \texttt{default}
% property, is somewhat a disputed real estate.  In particular, the use of
% \cs{labelformat} (previously from \pkg{varioref}, now in the kernel) will
% include there the reference ``prefix'' and complicate the job we are trying
% to do here.  Hence, we isolate \cs{the}\meta{counter} and store it ``clean''
% in \texttt{zc@thecnt} for reserved use.  Based on the definition of
% \cs{@currentlabel} done inside \cs{refstepcounter} in `texdoc source2e',
% section `ltxref.dtx'.  We just drop the \cs{p@...} prefix.
%
%    \begin{macrocode}
\zref@newprop { zc@thecnt } { \use:c { the \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@thecnt }
%    \end{macrocode}
%
%
% Much of the work of \pkg{zref-clever} relies on the association between a
% label's ``counter'' and its ``type'' (see the User manual section on
% ``Reference types'').  Superficially examined, one might think this relation
% could just be stored in a global property list, rather than in the label
% itself.  However, there are cases in which we want to distinguish different
% types for the same counter, depending on the document context.  Hence, we
% need to store the ``type'' of the ``counter'' for each ``label''.  In
% setting this, the presumption is that the label's type has the same name as
% its counter, unless it is specified otherwise by the \opt{countertype}
% option, as stored in \cs{l_@@_counter_type_prop}.
%
%    \begin{macrocode}
\zref@newprop { zc@type }
  {
    \prop_if_in:NVTF \l_@@_counter_type_prop \@currentcounter
      {
        \exp_args:NNe \prop_item:Nn
          \l_@@_counter_type_prop { \@currentcounter }
      }
      { \@currentcounter }
  }
\zref@addprop \ZREF@mainlist { zc@type }
%    \end{macrocode}
%
%
% Since the \texttt{zc@thecnt} and \texttt{page} properties store the
% ``\emph{printed} representation'' of their respective counters, for sorting
% and compressing purposes, we are also interested in their numeric values.
% So we store them in \texttt{zc@cntval} and \texttt{zc@pgval}.  For this, we
% use \cs{c@}\meta{counter}, which contains the counter's numerical value (see
% `texdoc source2e', section `ltcounts.dtx').
%    \begin{macrocode}
\zref@newprop { zc@cntval } [0] { \int_use:c { c@ \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@cntval }
\zref@newprop* { zc@pgval } [0] { \int_use:c { c@page } }
\zref@addprop \ZREF@mainlist { zc@pgval }
%    \end{macrocode}
%
%
% However, since many counters (may) get reset along the document, we require
% more than just their numeric values.  We need to know the reset chain of a
% given counter, in order to sort and compress a group of references.  Also
% here, the ``printed representation'' is not enough, not only because it is
% easier to work with the numeric values but, given we occasionally group
% multiple counters within a single type, sorting this group requires to know
% the actual counter reset chain (the counters' names and values).  Indeed,
% the set of counters grouped into a single type cannot be arbitrary: all of
% them must belong to the same reset chain, and must be nested within each
% other (they cannot even just share the same parent).
%
% Furthermore, even if it is true that most of the definitions of counters,
% and hence of their reset behavior, is likely to be defined in the preamble,
% this is not necessarily true.  Users can create counters, newtheorems
% mid-document, and alter their reset behavior along the way.  Was that not
% the case, we could just store the desired information at
% \texttt{begindocument} in a variable and retrieve it when needed.  But since
% it is, we need to store the information with the label, with the values as
% current when the label is set.
%
% Though counters can be reset at any time, and in different ways at that, the
% most important use case is the automatic resetting of counters when some
% other counter is stepped, as performed by the standard mechanisms of the
% kernel (optional argument of \cs{newcounter}, \cs{@addtoreset},
% \cs{counterwithin}, and related infrastructure).  The canonical optional
% argument of \cs{newcounter} establishes that the counter being created (the
% mandatory argument) gets reset every time the ``enclosing counter'' gets
% stepped (this is called in the usual sources ``within-counter'', ``old
% counter'', ``supercounter'' etc.).  This information is a little trickier to
% get.  For starters, the counters which may reset the current counter are not
% retrievable from the counter itself, because this information is stored with
% the counter that does the resetting, not with the one that gets reset (the
% list is stored in \cs{cl@}\meta{counter} with format
% |\@elt{countera}\@elt{counterb}\@elt{counterc}|, see section `ltcounts.dtx'
% in `source2e').  Besides, there may be a chain of resetting counters, which
% must be taken into account: if `counterC' gets reset by `counterB', and
% `counterB' gets reset by `counterA', stepping the latter affects all three
% of them.
%
% The procedure below examines a set of counters, those included in
% \cs{l_@@_counter_resetters_seq}, and for each of them retrieves the set of
% counters it resets, as stored in \cs{cl@}\meta{counter}, looking for the
% counter for which we are trying to set a label (\cs{@currentcounter}, passed
% as an argument to the functions).  There is one relevant caveat to this
% procedure: \cs{l_@@_counter_resetters_seq} is populated by hand with the
% ``usual suspects'', there is no way (that I know of) to ensure it is
% exhaustive.  However, it is not that difficult to create a reasonable
% ``usual suspects'' list which, of course, should include the counters for
% the sectioning commands to start with, and it is easy to add more counters
% to this list if needed, with the option \opt{counterresetters}.
% Unfortunately, not all counters are created alike, or reset alike.  Some
% counters, even some kernel ones, get reset by other mechanisms (notably, the
% \texttt{enumerate} environment counters do not use the regular counter
% machinery for resetting on each level, but are nested nevertheless by other
% means).  Therefore, inspecting \cs{cl@}\meta{counter} cannot possibly fully
% account for all of the automatic counter resetting which takes place in the
% document.  And there's also no other ``general rule'' we could grab on for
% this, as far as I know.  So we provide a way to manually tell
% \pkg{zref-clever} of these cases, by means of the \opt{counterresetby}
% option, whose information is stored in \cs{l_@@_counter_resetby_prop}.  This
% manual specification has precedence over the search through
% \cs{l_@@_counter_resetters_seq}, and should be handled with care, since
% there is no possible verification mechanism for this.
%
%
% \begin{macro}[EXP]
%   {
%     \@@_get_enclosing_counters:n ,
%     \@@_get_enclosing_counters_value:n ,
%   }
%     Recursively generate a \emph{sequence} of ``enclosing counters'' and
%     values, for a given \meta{counter} and leave it in the input stream.
%     These functions must be expandable, since they get called from
%     \cs{zref@newprop} and are the ones responsible for generating the
%     desired information when the label is being set.  Note that the order in
%     which we are getting this information is reversed, since we are
%     navigating the counter reset chain bottom-up.  But it is very hard to do
%     otherwise here where we need expandable functions, and easy to handle at
%     the reading side.
%     \begin{syntax}
%       \cs{@@_get_enclosing_counters:n} \Arg{counter}
%       \cs{@@_get_enclosing_counters_value:n} \Arg{counter}
%     \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \@@_get_enclosing_counters:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \@@_counter_reset_by:n {#1} }
        \@@_get_enclosing_counters:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
\cs_new:Npn \@@_get_enclosing_counters_value:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \int_use:c { c@ \@@_counter_reset_by:n {#1} } }
        \@@_get_enclosing_counters_value:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
%    \end{macrocode}
%
% Both \texttt{e} and \texttt{f} expansions work for this particular recursive
% call.  I'll stay with the \texttt{e} variant, since conceptually it is what
% I want (\texttt{x} itself is not expandable), and this package is anyway not
% compatible with older kernels for which the performance penalty of the
% \texttt{e} expansion would ensue (see also
% \url{https://tex.stackexchange.com/q/611370/#comment1529282_611385}, thanks
% Enrico Gregorio, aka `egreg').
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_get_enclosing_counters:n { V , e }
\cs_generate_variant:Nn \@@_get_enclosing_counters_value:n { V , e }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[EXP]{\@@_counter_reset_by:n}
%   Auxiliary function for \cs{@@_get_enclosing_counters:n} and
%   \cs{@@_get_enclosing_counters_value:n}.  They are broken in parts to be
%   able to use the expandable mapping functions.  \cs{@@_counter_reset_by:n}
%   leaves in the stream the ``enclosing counter'' which resets
%   \meta{counter}.
%   \begin{syntax}
%     \cs{@@_counter_reset_by:n} \Arg{counter}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \@@_counter_reset_by:n #1
  {
    \bool_if:nTF
      { \prop_if_in_p:Nn \l_@@_counter_resetby_prop {#1} }
      { \prop_item:Nn  \l_@@_counter_resetby_prop {#1} }
      {
        \seq_map_tokens:Nn \l_@@_counter_resetters_seq
          { \@@_counter_reset_by_aux:nn {#1} }
      }
  }
\cs_new:Npn \@@_counter_reset_by_aux:nn #1#2
  {
    \cs_if_exist:cT { c@ #2 }
      {
        \tl_if_empty:cF { cl@ #2 }
          {
            \tl_map_tokens:cn { cl@ #2 }
              { \@@_counter_reset_by_auxi:nnn {#2} {#1} }
          }
      }
  }
\cs_new:Npn \@@_counter_reset_by_auxi:nnn #1#2#3
  {
    \str_if_eq:nnT {#2} {#3}
      { \tl_map_break:n { \seq_map_break:n {#1} } }
  }
%    \end{macrocode}
% \end{macro}
%
%
% Finally, we create the \texttt{zc@enclcnt} and \texttt{zc@enclval}
% properties, and add them to the \texttt{main} property list.
%    \begin{macrocode}
\zref@newprop { zc@enclcnt }
  { \@@_get_enclosing_counters:V \@currentcounter }
\zref@newprop { zc@enclval }
  { \@@_get_enclosing_counters_value:V \@currentcounter }
\zref@addprop \ZREF@mainlist { zc@enclcnt }
\zref@addprop \ZREF@mainlist { zc@enclval }
%    \end{macrocode}
%
%
% Another piece of information we need is the page numbering format being used
% by \cs{thepage}, so that we know when we can (or not) group a set of page
% references in a range.  Unfortunately, \texttt{page} is not a typical
% counter in ways which complicates things.  First, it does commonly get reset
% along the document, not necessarily by the usual counter reset chains, but
% rather with \cs{pagenumbering} or variations thereof.  Second, the format of
% the page number commonly changes in the document (roman, arabic, etc.), not
% necessarily, though usually, together with a reset.  Trying to ``parse''
% \cs{thepage} to retrieve such information is bound to go wrong: we don't
% know, and can't know, what is within that macro, and that's the business of
% the user, or of the documentclass, or of the loaded packages.  The technique
% used by \pkg{cleveref}, which we borrow here, is simple and smart: store
% with the label what \cs{thepage} would return, if the counter \cs{c@page}
% was ``\(1\)''.  That does not allow us to \emph{sort} the references,
% luckily however, we have \texttt{abspage} which solves this problem.  But we
% can decide whether two labels can be compressed into a range or not based on
% this format: if they are identical, we can compress them, otherwise, we
% can't.  To do so, we locally redefine \cs{c@page} to return ``1'', thus
% avoiding any global spillovers of this trick.  Since this operation is not
% expandable we cannot run it directly from the property definition.  Hence,
% we use a shipout hook, and set \cs{g_@@_page_format_tl}, which can then be
% retrieved by the starred definition of |\zref@newprop*{zc@pgfmt}|.
%
%    \begin{macrocode}
\tl_new:N \g_@@_page_format_tl
\cs_new_protected:Npx \@@_page_format_aux: { \int_eval:n { 1 } }
\AddToHook { shipout / before }
  {
    \group_begin:
    \cs_set_eq:NN \c@page \@@_page_format_aux:
    \exp_args:NNx \tl_gset:Nn \g_@@_page_format_tl { \thepage }
    \group_end:
  }
\zref@newprop* { zc@pgfmt } { \g_@@_page_format_tl }
\zref@addprop \ZREF@mainlist { zc@pgfmt }
%    \end{macrocode}
%
%
% Still another property which we don't need to handle at the data provision
% side, but need to cater for at the retrieval side, is the \texttt{url}
% property (or the equivalent \texttt{urluse}) from the \pkg{zref-xr} module,
% which is added to the labels imported from external documents, and needed to
% construct hyperlinks to them.
%
%
%
% \section{Plumbing}
%
%
% \subsection{Messages}
%
%
%    \begin{macrocode}
\msg_new:nnn { zref-clever } { option-not-type-specific }
  {
    Option~'#1'~is~not~type-specific~\msg_line_context:.~
    Set~it~in~'\iow_char:N\\zcDeclareTranslations'~before~first~'type'
    ~switch~or~as~package~option.
  }
\msg_new:nnn { zref-clever } { option-only-type-specific }
  {
    No~type~specified~for~option~'#1'~\msg_line_context:.~
    Set~it~after~'type'~switch~or~in~'\iow_char:N\\zcRefTypeSetup'.
  }
\msg_new:nnn { zref-clever } { key-requires-value }
  { The~'#1'~key~'#2'~requires~a~value~\msg_line_context:. }
\msg_new:nnn { zref-clever } { language-declared }
  { Language~'#1'~is~already~declared.~Nothing~to~do. }
\msg_new:nnn { zref-clever } { unknown-language-alias }
  {
    Language~'#1'~is~unknown,~cannot~alias~to~it.~See~documentation~for~
    '\iow_char:N\\zcDeclareLanguage'~and~
    '\iow_char:N\\zcDeclareLanguageAlias'.
  }
\msg_new:nnn { zref-clever } { unknown-language-transl }
  {
    Language~'#1'~is~unknown,~cannot~declare~translations~to~it.~
    See~documentation~for~'\iow_char:N\\zcDeclareLanguage'~and~
    '\iow_char:N\\zcDeclareLanguageAlias'.
  }
\msg_new:nnn { zref-clever } { dict-loaded }
  { Loaded~'#1'~dictionary. }
\msg_new:nnn { zref-clever } { dict-not-available }
  { Dictionary~for~'#1'~not~available~\msg_line_context:. }
\msg_new:nnn { zref-clever } { unknown-language-load }
  {
    Language~'#1'~is~unknown~\msg_line_context:.~Unable~to~load~dictionary.~
    See~documentation~for~'\iow_char:N\\zcDeclareLanguage'~and~
    '\iow_char:N\\zcDeclareLanguageAlias'.
  }
\msg_new:nnn { zref-clever } { missing-zref-titleref }
  {
    Option~'ref=title'~requested~\msg_line_context:.~
    But~package~'zref-titleref'~is~not~loaded,~falling-back~to~default~'ref'.
  }
\msg_new:nnn { zref-clever } { hyperref-preamble-only }
  {
    Option~'hyperref'~only~available~in~the~preamble.~
    Use~the~starred~version~of~'\iow_char:N\\zcref'~instead.
  }
\msg_new:nnn { zref-clever } { missing-hyperref }
  { Missing~'hyperref'~package.~Setting~'hyperref=false'. }
\msg_new:nnn { zref-check } { check-document-only }
  { Option~'check'~only~available~in~the~document. }
\msg_new:nnn { zref-clever } { missing-zref-check }
  {
    Option~'check'~requested~\msg_line_context:.~
    But~package~'zref-check'~is~not~loaded,~can't~run~the~checks.
  }
\msg_new:nnn { zref-clever } { counters-not-nested }
  { Counters~not~nested~for~labels~'#1'~and~'#2'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-type }
  { Reference~type~undefined~for~label~'#1'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-name }
  { Name~undefined~for~type~'#1'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-string }
  {
    We~couldn't~find~a~value~for~reference~option~'#1'~\msg_line_context:.~
    But~we~should~have:~throw~a~rock~at~the~maintainer.
  }
\msg_new:nnn { zref-clever } { single-element-range }
  { Range~for~type~'#1'~resulted~in~single~element~\msg_line_context:. }
%    \end{macrocode}
%
%
%
% \subsection{Reference format}
% \label{sec:reference-format}
%
% Formatting how the reference is to be typeset is, quite naturally, a big
% part of the user interface of \pkg{zref-clever}.  In this area, we tried to
% balance ``flexibility'' and ``user friendliness''.  But the former does
% place a big toll overall, since there are indeed many places where tweaking
% may be desired, and the settings may depend on at least two important
% dimensions of variation: the reference type and the language.  Combination
% of those necessarily makes for a large set of possibilities.  Hence, the
% attempt here is to provide a rich set of ``handles'' for fine tuning the
% reference format but, at the same time, do not \emph{require} detailed setup
% by the users, unless they really want it.
%
% With that in mind, we have settled with an user interface for reference
% formatting which allows settings to be done in different scopes, with more
% or less overarching effects, and some precedence rules to regulate the
% relation of settings given in each of these scopes.  There are four scopes
% in which reference formatting can be specified by the user, in the following
% precedence order: i) as general \emph{options}; ii) as \emph{type-specific
% options}; iii) as \emph{language-specific and type-specific translations};
% and iv) as \emph{default translations} (that is, language-specific but not
% type-specific).  Besides those, there's actually a fifth \emph{internal}
% scope, with the least priority of all, a ``fallback'', for the cases where
% it is meaningful to provide some value, even for an unknown language. These
% precedence rules are handled / enforced in \cs{@@_get_ref_string:nN},
% \cs{@@_get_ref_font:nN}, and \cs{@@_type_name_setup:} which are the basic
% functions to retrieve proper values for reference format settings.
%
% General ``options'' (i) can be given by the user in the optional argument of
% \cs{zcref}, but just as well in \cs{zcsetup} or as package options at
% load-time (see Section~\ref{sec:reference-options}).  ``Type-specific
% options'' (ii) are handled by \cs{zcRefTypeSetup}.  ``Language-specific
% translations'', be they ``type-specific'' (iii) or ``default'' (iv) have
% their user interface in \cs{zcDeclareTranslations}, and have their values
% populated by the package's dictionaries.  The ``fallback'' settings are
% stored in \cs{g_@@_fallback_dict_prop}.
%
% Not all reference format specifications can be given in all of these
% scopes.  Some of them can't be type-specific, others must be type-specific,
% so the set available in each scope depends on the pertinence of the case.
%
% The package itself places the default setup for reference formatting at low
% precedence levels, and the users can easily and conveniently override them
% as desired.  Indeed, I expect most of the users' needs to be normally
% achievable with the general options and type-specific options, since
% references will normally be typeset in a single language (the document's
% main language) and, hence, multiple translations don't need to be provided.
%
%
% \begin{variable}
%   {
%     \l_@@_setup_type_tl ,
%     \l_@@_dict_language_tl ,
%   }
%     Store ``current'' type and language in different places for option and
%     translation handling, notably in \cs{@@_provide_dictionary:n},
%     \cs{zcRefTypeSetup}, and \cs{zcDeclareTranslations}.  But also for
%     translations retrieval, in \cs{@@_get_type_transl:nnnN} and
%     \cs{@@_get_default_transl:nnN}.
%    \begin{macrocode}
\tl_new:N \l_@@_setup_type_tl
\tl_new:N \l_@@_dict_language_tl
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}
%   {
%     \c_@@_ref_options_necessarily_not_type_specific_seq ,
%     \c_@@_ref_options_possibly_type_specific_seq ,
%     \c_@@_ref_options_necessarily_type_specific_seq ,
%     \c_@@_ref_options_font_seq ,
%     \c_@@_ref_options_typesetup_seq ,
%     \c_@@_ref_options_reference_seq ,
%   }
%     Lists of reference format related options in ``categories''.  Since
%     these options are set in different scopes, and at different places,
%     storing the actual lists in centralized variables makes the job not only
%     easier later on, but also keeps things consistent.
%    \begin{macrocode}
\seq_const_from_clist:Nn
  \c_@@_ref_options_necessarily_not_type_specific_seq
  {
    tpairsep ,
    tlistsep ,
    tlastsep ,
    notesep ,
  }
\seq_const_from_clist:Nn
  \c_@@_ref_options_possibly_type_specific_seq
  {
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    refpre ,
    refpos ,
    refpre-in ,
    refpos-in ,
  }
%    \end{macrocode}
% Only ``type names'' are ``necessarily type-specific'', which makes them
% somewhat special on the retrieval side of things.  In short, they don't have
% their values queried by \cs{@@_get_ref_string:nN}, but by
% \cs{@@_type_name_setup:}.
%    \begin{macrocode}
\seq_const_from_clist:Nn
  \c_@@_ref_options_necessarily_type_specific_seq
  {
    Name-sg ,
    name-sg ,
    Name-pl ,
    name-pl ,
    Name-sg-ab ,
    name-sg-ab ,
    Name-pl-ab ,
    name-pl-ab ,
  }
%    \end{macrocode}
% \cs{c_@@_ref_options_font_seq} are technically ``possibly type-specific'',
% but are not ``language-specific'', so we separate them.
%    \begin{macrocode}
\seq_const_from_clist:Nn
  \c_@@_ref_options_font_seq
  {
    namefont ,
    reffont ,
    reffont-in ,
  }
\seq_new:N \c_@@_ref_options_typesetup_seq
\seq_gconcat:NNN \c_@@_ref_options_typesetup_seq
  \c_@@_ref_options_possibly_type_specific_seq
  \c_@@_ref_options_necessarily_type_specific_seq
\seq_gconcat:NNN \c_@@_ref_options_typesetup_seq
  \c_@@_ref_options_typesetup_seq
  \c_@@_ref_options_font_seq
\seq_new:N \c_@@_ref_options_reference_seq
\seq_gconcat:NNN \c_@@_ref_options_reference_seq
  \c_@@_ref_options_necessarily_not_type_specific_seq
  \c_@@_ref_options_possibly_type_specific_seq
\seq_gconcat:NNN \c_@@_ref_options_reference_seq
  \c_@@_ref_options_reference_seq
  \c_@@_ref_options_font_seq
%    \end{macrocode}
% \end{variable}
%
%
%
% \subsection{Languages}
%
% \begin{variable}{\g_@@_languages_prop}
%   Stores the names of known languages and the mapping from ``language name''
%   to ``dictionary name''.  Whether of not a language or alias is known to
%   \pkg{zref-clever} is decided by its presence in this property list.  A
%   ``base language'' (loose concept here, meaning just ``the name we gave for
%   the dictionary in that particular language'') is just like any other one,
%   the only difference is that the ``language name'' happens to be the same
%   as the ``dictionary name'', in other words, it is an ``alias to itself''.
%    \begin{macrocode}
\prop_new:N \g_@@_languages_prop
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}[int]{\zcDeclareLanguage}
%   Declare a new language for use with \pkg{zref-clever}.  \meta{language} is
%   taken to be both the ``language name'' and the ``dictionary name''.  If
%   \meta{language} is already known, just warn.  \cs{zcDeclareLanguage} is
%   preamble only.
%   \begin{syntax}
%     \cs{zcDeclareLanguage} \marg{language}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcDeclareLanguage { m }
  {
    \tl_if_empty:nF {#1}
      {
        \prop_if_in:NnTF \g_@@_languages_prop {#1}
          { \msg_warning:nnn { zref-clever } { language-declared } {#1} }
          { \prop_gput:Nnn \g_@@_languages_prop {#1} {#1} }
      }
  }
\@onlypreamble \zcDeclareLanguage
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[int]{\zcDeclareLanguageAlias}
%   Declare \meta{language alias} to be an alias of \meta{aliased language}.
%   \meta{aliased language} must be already known to \pkg{zref-clever}, as
%   stored in \cs{g_@@_languages_prop}.  \cs{zcDeclareLanguageAlias} is
%   preamble only.
%   \begin{syntax}
%     \cs{zcDeclareLanguageAlias} \marg{language alias} \marg{aliased language}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcDeclareLanguageAlias { m m }
  {
    \tl_if_empty:nF {#1}
      {
        \prop_if_in:NnTF \g_@@_languages_prop {#2}
          {
            \exp_args:NNnx
              \prop_gput:Nnn \g_@@_languages_prop {#1}
                { \prop_item:Nn \g_@@_languages_prop {#2} }
          }
          { \msg_warning:nnn { zref-clever } { unknown-language-alias } {#2} }
      }
  }
\@onlypreamble \zcDeclareLanguageAlias
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Dictionaries}
%
% Contrary to general options and type options, which are always \emph{local},
% ``dictionaries'', ``translations'' or ``language-specific settings'' are
% always \emph{global}.  Hence, the loading of built-in dictionaries, as well
% as settings done with \cs{zcDeclareTranslations}, should set the relevant
% variables globally.
%
% The built-in dictionaries and their related infrastructure are designed to
% perform ``on the fly'' loading of dictionaries, ``lazily'' as needed.  Much
% like \pkg{babel} does for languages not declared in the preamble, but used
% in the document.  This offers some convenience, of course, and that's one
% reason to do it.  But it also has the purpose of parsimony, of ``loading the
% least possible''.  My expectation is that for most use cases, users will
% require a single language of the functionality of \pkg{zref-clever} -- the
% main language of the document --, even in multilingual documents.  Hence,
% even the set of \pkg{babel} or \pkg{polyglossia} ``loaded languages'', which
% would be the most tenable set if loading were restricted to the preamble, is
% bound to be an overshoot in typical cases.  Therefore, we load at
% \texttt{begindocument} one single language (see \nameref{sec:lang-option}),
% as specified by the user in the preamble with the \opt{lang} option or,
% failing any specification, the main language of the document, which is the
% default.  Anything else is lazily loaded, on the fly, along the document.
%
% This design decision has also implications to the \emph{form} the dictionary
% files assumed.  As far as my somewhat impressionistic sampling goes,
% dictionary or localization files of the most common packages in this area of
% functionality, are usually a set of commands which perform the relevant
% definitions and assignments in the preamble or at \texttt{begindocument}.
% This includes \pkg{translator}, \pkg{translations}, but also \pkg{babel}'s
% \file{.ldf} files, and \pkg{biblatex}'s \file{.lbx} files.  I'm not really
% well acquainted with this machinery, but as far as I grasp, they all rely on
% some variation of \cs{ProvidesFile} and \cs{input}.  And they can be safely
% \cs{input} without generating spurious content, because they rely on being
% loaded before the document has actually started.  As far as I can tell,
% \pkg{babel}'s ``on the fly'' functionality is not based on the \file{.ldf}
% files, but on the \file{.ini} files, and on \cs{babelprovide}.  And the
% \file{.ini} files are not in this form, but actually resemble
% ``configuration files'' of sorts, which means they are read and processed
% somehow else than with just \cs{input}.  So we do the more or less the same
% here.  It seems a reasonable way to ensure we can load dictionaries on the
% fly robustly mid-document, without getting paranoid with the last bit of
% white-space in them, and without introducing any undue content on the stream
% when we cannot afford to do it.  Hence, \pkg{zref-clever}'s built-in
% dictionary files are a set of \emph{key-value options} which are read from
% the file, and fed to |\keys_set:nn{zref-clever/dictionary}| by
% \cs{@@_provide_dictionary:n}.  And they use the same syntax and options as
% \cs{zcDeclareTranslations} does.  The dictionary file itself is read with
% \cs{ExplSyntaxOn} with the usual implications for white-space and catcodes.
%
% \cs{@@_provide_dictionary:n} is only meant to load the built-in
% dictionaries.  For languages declared by the user, or for any settings to a
% known language made with \cs{zcDeclareTranslations}, values are populated
% directly to a variable \cs{g_@@_dict_\meta{language}_prop}, created as
% needed.  Hence, there is no need to ``load'' anything in this case:
% definitions and assignments made by the user are performed immediately.
%
%
% \subsubsection*{Provide}
%
% \begin{variable}{\g_@@_loaded_dictionaries_seq}
%   Used to keep track of whether a dictionary has already been loaded or not.
%    \begin{macrocode}
\seq_new:N \g_@@_loaded_dictionaries_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_load_dict_verbose_bool}
%   Controls whether \cs{@@_provide_dictionary:n} fails silently or verbosely
%   in case of unknown languages or dictionaries not found.
%    \begin{macrocode}
\bool_new:N \l_@@_load_dict_verbose_bool
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\@@_provide_dictionary:n}
%   Load dictionary for known \meta{language} if it is available and if it has
%   not already been loaded.
%   \begin{syntax}
%     \cs{@@_provide_dictionary:n} \Arg{language}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_provide_dictionary:n #1
  {
    \group_begin:
    \prop_get:NnNTF \g_@@_languages_prop {#1}
      \l_@@_dict_language_tl
      {
        \seq_if_in:NVF
          \g_@@_loaded_dictionaries_seq
          \l_@@_dict_language_tl
          {
            \exp_args:Nx \file_get:nnNTF
              { zref-clever- \l_@@_dict_language_tl .dict }
              { \ExplSyntaxOn }
              \l_tmpa_tl
              {
                \prop_if_exist:cF
                  {
                    g_@@_dict_
                    \l_@@_dict_language_tl _prop
                  }
                  {
                    \prop_new:c
                      {
                        g_@@_dict_
                        \l_@@_dict_language_tl _prop
                      }
                  }
                \tl_clear:N \l_@@_setup_type_tl
                \exp_args:NnV
                  \keys_set:nn { zref-clever / dictionary } \l_tmpa_tl
                \seq_gput_right:NV \g_@@_loaded_dictionaries_seq
                  \l_@@_dict_language_tl
                \msg_note:nnx { zref-clever } { dict-loaded }
                  { \l_@@_dict_language_tl }
              }
              {
                \bool_if:NT \l_@@_load_dict_verbose_bool
                  {
                    \msg_warning:nnx { zref-clever } { dict-not-available }
                      { \l_@@_dict_language_tl }
                  }
              }
          }
      }
      {
        \bool_if:NT \l_@@_load_dict_verbose_bool
          { \msg_warning:nnn { zref-clever } { unknown-language-load } {#1} }
      }
    \group_end:
  }
\cs_generate_variant:Nn \@@_provide_dictionary:n { x }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_provide_dictionary_verbose:n}
%   Does the same as \cs{@@_provide_dictionary:n}, but warns if the loading of
%   the dictionary has failed.
%   \begin{syntax}
%     \cs{@@_provide_dictionary_verbose:n} \Arg{language}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_provide_dictionary_verbose:n #1
  {
    \group_begin:
    \bool_set_true:N \l_@@_load_dict_verbose_bool
    \@@_provide_dictionary:n {#1}
    \group_end:
  }
\cs_generate_variant:Nn \@@_provide_dictionary_verbose:n { x }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}
%   {
%     \@@_provide_dict_type_transl:nn ,
%     \@@_provide_dict_default_transl:nn ,
%   }
%   A couple of auxiliary functions for the of
%   \texttt{{zref-clever/dictionary}} keys set in
%   \cs{@@_provide_dictionary:n}.  They respectively ``provide'' (i.e.  set if
%   it value does not exist, do nothing if it already does) ``type-specific''
%   and ``default'' translations.  Both receive \meta{key} and
%   \meta{translation} as arguments, but \cs{@@_provide_dict_type_transl:nn}
%   relies on the current value of \cs{l_@@_setup_type_tl}, as set by the
%   \texttt{type} key.
%   \begin{syntax}
%     \cs{@@_provide_dict_type_transl:nn} \Arg{key} \Arg{translation}
%     \cs{@@_provide_dict_default_transl:nn} \Arg{key} \Arg{translation}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_provide_dict_type_transl:nn #1#2
  {
    \exp_args:Nnx \prop_gput_if_new:cnn
      { g_@@_dict_ \l_@@_dict_language_tl _prop }
      { type- \l_@@_setup_type_tl - #1 } {#2}
  }
\cs_new_protected:Npn \@@_provide_dict_default_transl:nn #1#2
  {
    \prop_gput_if_new:cnn
      { g_@@_dict_ \l_@@_dict_language_tl _prop }
      { default- #1 } {#2}
  }
%    \end{macrocode}
% \end{macro}
%
%
% The set of keys for \texttt{{zref-clever/dictionary}}, which is used to
% process the dictionary files in \cs{@@_provide_dictionary:n}.  The no-op
% cases for each category have their messages sent to ``info''.  These
% messages should not occur, as long as the dictionaries are well formed, but
% they're placed there nevertheless, and can be leveraged in regression tests.
%
%    \begin{macrocode}
\keys_define:nn { zref-clever / dictionary }
  {
    type .code:n =
      {
        \tl_if_empty:nTF {#1}
          { \tl_clear:N \l_@@_setup_type_tl }
          { \tl_set:Nn \l_@@_setup_type_tl {#1} }
      } ,
  }
\seq_map_inline:Nn
  \c_@@_ref_options_necessarily_not_type_specific_seq
  {
    \keys_define:nn { zref-clever / dictionary }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              { \@@_provide_dict_default_transl:nn {#1} {##1} }
              {
                \msg_info:nnn { zref-clever }
                  { option-not-type-specific } {#1}
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \c_@@_ref_options_possibly_type_specific_seq
  {
    \keys_define:nn { zref-clever / dictionary }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              { \@@_provide_dict_default_transl:nn {#1} {##1} }
              { \@@_provide_dict_type_transl:nn {#1} {##1} }
          } ,
      }
  }
\seq_map_inline:Nn
  \c_@@_ref_options_necessarily_type_specific_seq
  {
    \keys_define:nn { zref-clever / dictionary }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \msg_info:nnn { zref-clever }
                  { option-only-type-specific } {#1}
              }
              { \@@_provide_dict_type_transl:nn {#1} {##1} }
          } ,
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{Fallback}
%
% All ``strings'' queried with \cs{@@_get_ref_string:nN} -- in practice, those
% in either \cs{c_@@_ref_options_necessarily_not_type_specific_seq} or
% \cs{c_@@_ref_options_possibly_type_specific_seq} -- must have their values
% set for ``fallback'', even if to empty ones, since this is what will be
% retrieved in the absence of a proper translation, which will be the case if
% \pkg{babel} or \pkg{polyglossia} is loaded and sets a language which
% \pkg{zref-clever} does not know.  On the other hand, ``type names'' are not
% looked for in ``fallback'', since it is indeed impossible to provide any
% reasonable value for them for a ``specified but unknown language''.  Also
% ``font'' options -- those in \cs{c_@@_ref_options_font_seq}, and queried
% with \cs{@@_get_ref_font:nN} -- do not need to be provided here, since the
% later function sets an empty value if the option is not found.
%
% TODO Add regression test to ensure all fallback ``translations'' are indeed
% present.
%
%    \begin{macrocode}
\prop_new:N \g_@@_fallback_dict_prop
\prop_gset_from_keyval:Nn \g_@@_fallback_dict_prop
  {
    tpairsep  = {,~} ,
    tlistsep  = {,~} ,
    tlastsep  = {,~} ,
    notesep   = {~} ,
    namesep   = {\nobreakspace} ,
    pairsep   = {,~} ,
    listsep   = {,~} ,
    lastsep   = {,~} ,
    rangesep  = {\textendash} ,
    refpre    = {} ,
    refpos    = {} ,
    refpre-in = {} ,
    refpos-in = {} ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{Get translations}
%
% \begin{macro}{\@@_get_type_transl:nnnNF}
%   Get type-specific translation of \meta{key} for \meta{type} and
%   \meta{language}, and store it in \meta{tl variable} if found.  If not
%   found, leave the \meta{false code} on the stream, in which case the value
%   of \meta{tl variable} should not be relied upon.
%   \begin{syntax}
%     \cs{@@_get_type_transl:nnnNF} \Arg{language} \Arg{type} \Arg{key}
%     ~~\meta{tl variable} \Arg{false code}
%   \end{syntax}
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn
  \@@_get_type_transl:nnnN #1#2#3#4 { F }
  {
    \prop_get:NnNTF \g_@@_languages_prop {#1}
      \l_@@_dict_language_tl
      {
        \prop_get:cnNTF
          { g_@@_dict_ \l_@@_dict_language_tl _prop }
          { type- #2 - #3 } #4
          { \prg_return_true:  }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \@@_get_type_transl:nnnN { xxxN , xxnN } { F }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_get_default_transl:nnNF}
%   Get default translation of \meta{key} for \meta{language}, and store it in
%   \meta{tl variable} if found.  If not found, leave the \meta{false code} on
%   the stream, in which case the value of \meta{tl variable} should not be
%   relied upon.
%   \begin{syntax}
%     \cs{@@_get_default_transl:nnNF} \Arg{language} \Arg{key}
%     ~~\meta{tl variable} \Arg{false code}
%   \end{syntax}
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn
  \@@_get_default_transl:nnN #1#2#3 { F }
  {
    \prop_get:NnNTF \g_@@_languages_prop {#1}
      \l_@@_dict_language_tl
      {
        \prop_get:cnNTF
          { g_@@_dict_ \l_@@_dict_language_tl _prop }
          { default- #2 } #3
          { \prg_return_true:  }
          { \prg_return_false: }
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \@@_get_default_transl:nnN { xnN } { F }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_get_fallback_transl:nNF}
%   Get fallback translation of \meta{key}, and store it in \meta{tl variable}
%   if found.  If not found, leave the \meta{false code} on the stream, in
%   which case the value of \meta{tl variable} should not be relied upon.
%   \begin{syntax}
%     \cs{@@_get_fallback_transl:nNF} \Arg{key}
%     ~~\meta{tl variable} \Arg{false code}
%   \end{syntax}
%    \begin{macrocode}
% {<key>}<tl var to set>
\prg_new_protected_conditional:Npnn
  \@@_get_fallback_transl:nN #1#2 { F }
  {
    \prop_get:NnNTF \g_@@_fallback_dict_prop
      { #1 } #2
      { \prg_return_true:  }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Options}
%
%
% \subsubsection*{Auxiliary}
%
%
% \begin{macro}{\@@_prop_put_non_empty:Nnn}
%   If \meta{value} is empty, remove \meta{key} from \meta{property list}.
%   Otherwise, add \meta{key} = \meta{value} to \meta{property list}.
%   \begin{syntax}
%     \cs{@@_prop_put_non_empty:Nnn} \meta{property list} \Arg{key} \Arg{value}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_prop_put_non_empty:Nnn #1#2#3
  {
    \tl_if_empty:nTF {#3}
      { \prop_remove:Nn #1 {#2} }
      { \prop_put:Nnn #1 {#2} {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection*{\opt{countertype} option}
%
% \cs{l_@@_counter_type_prop} is used by \texttt{zc@type} property, and stores
% a mapping from ``counter'' to ``reference type''.  Only those counters whose
% type name is different from that of the counter need to be specified, since
% \texttt{zc@type} presumes the counter as the type if the counter is not
% found in \cs{l_@@_counter_type_prop}.
%
%    \begin{macrocode}
\prop_new:N \l_@@_counter_type_prop
\keys_define:nn { zref-clever / label }
  {
    countertype .code:n =
      {
        \keyval_parse:nnn
          {
            \msg_warning:nnnn { zref-clever }
              { key-requires-value } { countertype }
          }
          {
            \@@_prop_put_non_empty:Nnn
              \l_@@_counter_type_prop
          }
          {#1}
      } ,
    countertype .value_required:n = true ,
    countertype .initial:n =
      {
        subsection    = section ,
        subsubsection = section ,
        subparagraph  = paragraph ,
        enumi         = item ,
        enumii        = item ,
        enumiii       = item ,
        enumiv        = item ,
      } ,
  }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{counterresetters} option}
%
% \cs{l_@@_counter_resetters_seq} is used by \cs{@@_counter_reset_by:n} to
% populate the \texttt{zc@enclcnt} and \texttt{zc@enclval} properties, and
% stores the list of counters which are potential ``enclosing counters'' for
% other counters.  This option is constructed such that users can only
% \emph{add} items to the variable.  There would be little gain and some risk
% in allowing removal, and the syntax of the option would become unnecessarily
% more complicated.  Besides, users can already override, for any particular
% counter, the search done from the set in \cs{l_@@_counter_resetters_seq}
% with the \opt{counterresetby} option.
%
%    \begin{macrocode}
\seq_new:N \l_@@_counter_resetters_seq
\keys_define:nn { zref-clever / label }
  {
    counterresetters .code:n =
      {
        \clist_map_inline:nn {#1}
          {
            \seq_if_in:NnF \l_@@_counter_resetters_seq {##1}
              {
                \seq_put_right:Nn
                  \l_@@_counter_resetters_seq {##1}
              }
          }
      } ,
    counterresetters .initial:n =
      {
        part ,
        chapter ,
        section ,
        subsection ,
        subsubsection ,
        paragraph ,
        subparagraph ,
      },
    typesort .value_required:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{counterresetby} option}
%
% \cs{l_@@_counter_resetby_prop} is used by \cs{@@_counter_reset_by:n} to
% populate the \texttt{zc@enclcnt} and \texttt{zc@enclval} properties, and
% stores a mapping from counters to the counter which resets each of them.
% This mapping has precedence in \cs{@@_counter_reset_by:n} over the search
% through \cs{l_@@_counter_resetters_seq}.
%
%    \begin{macrocode}
\prop_new:N \l_@@_counter_resetby_prop
\keys_define:nn { zref-clever / label }
  {
    counterresetby .code:n =
      {
        \keyval_parse:nnn
          {
            \msg_warning:nnn { zref-clever }
              { key-requires-value } { counterresetby }
          }
          {
            \@@_prop_put_non_empty:Nnn
              \l_@@_counter_resetby_prop
          }
          {#1}
      } ,
    counterresetby .value_required:n = true ,
    counterresetby .initial:n =
      {
%    \end{macrocode}
% The counters for the \texttt{enumerate} environment do not use the regular
% counter machinery for resetting on each level, but are nested nevertheless
% by other means, treat them as exception.
%    \begin{macrocode}
        enumii  = enumi   ,
        enumiii = enumii  ,
        enumiv  = enumiii ,
      } ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{ref} option}
%
% \cs{l_@@_ref_property_tl} stores the property to which the reference is
% being made.  Currently, we restrict \texttt{ref=} to these two (or three)
% alternatives -- \texttt{zc@thecnt}, \texttt{page}, and \texttt{title} if
% \pkg{zref-titleref} is loaded --, but there might be a case for making this
% more flexible.  The infrastructure can already handle receiving an arbitrary
% property, as long as one is satisfied with sorting and compressing from the
% default counter.  If more flexibility is granted, one thing \emph{must} be
% handled at this point: the existence of the property itself, as far as
% \pkg{zref} is concerned.  This because typesetting relies on the check
% \cs{zref@ifrefcontainsprop}, which \emph{presumes} the property is defined
% and silently expands the \emph{true} branch if it is not (see
% \url{https://github.com/ho-tex/zref/issues/13}, thanks Ulrike Fischer).
% Therefore, before adding anything to \cs{l_@@_ref_property_tl}, check if
% first here with \cs{zref@ifpropundefined}: close it at the door.
%
%
%    \begin{macrocode}
\tl_new:N \l_@@_ref_property_tl
\keys_define:nn { zref-clever / reference }
  {
    ref .choice: ,
    ref / zc@thecnt .code:n =
      { \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt } } ,
    ref / page .code:n =
      { \tl_set:Nn \l_@@_ref_property_tl { page } } ,
    ref / title .code:n =
      {
        \AddToHook { begindocument }
          {
            \@ifpackageloaded { zref-titleref }
              { \tl_set:Nn \l_@@_ref_property_tl { title } }
              {
                \msg_warning:nn { zref-clever } { missing-zref-titleref }
                \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt }
              }
          }
      } ,
    ref .initial:n = zc@thecnt ,
    ref .value_required:n = true ,
    page .meta:n = { ref = page },
    page .value_forbidden:n = true ,
  }
\AddToHook { begindocument }
  {
    \@ifpackageloaded { zref-titleref }
      {
        \keys_define:nn { zref-clever / reference }
          {
            ref / title .code:n =
              { \tl_set:Nn \l_@@_ref_property_tl { title } }
          }
      }
      {
        \keys_define:nn { zref-clever / reference }
          {
            ref / title .code:n =
              {
                \msg_warning:nn { zref-clever } { missing-zref-titleref }
                \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt }
              }
          }
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{typeset} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_ref_bool
\bool_new:N \l_@@_typeset_name_bool
\keys_define:nn { zref-clever / reference }
  {
    typeset .choice: ,
    typeset / both .code:n =
      {
        \bool_set_true:N \l_@@_typeset_ref_bool
        \bool_set_true:N \l_@@_typeset_name_bool
      } ,
    typeset / ref .code:n =
      {
        \bool_set_true:N \l_@@_typeset_ref_bool
        \bool_set_false:N \l_@@_typeset_name_bool
      } ,
    typeset / name .code:n =
      {
        \bool_set_false:N \l_@@_typeset_ref_bool
        \bool_set_true:N \l_@@_typeset_name_bool
      } ,
    typeset .initial:n = both ,
    typeset .value_required:n = true ,

    noname .meta:n = { typeset = ref },
    noname .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{sort} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_sort_bool
\keys_define:nn { zref-clever / reference }
  {
    sort .bool_set:N = \l_@@_typeset_sort_bool ,
    sort .initial:n = true ,
    sort .default:n = true ,
    nosort .meta:n = { sort = false },
    nosort .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{typesort} option}
%
% \cs{l_@@_typesort_seq} is stored reversed, since the sort priorities are
% computed in the negative range in \cs{@@_sort_default_different_types:nn},
% so that we can implicitly rely on `0' being the ``last value'', and spare
% creating an integer variable using \cs{seq_map_indexed_inline:Nn}.
%
%    \begin{macrocode}
\seq_new:N \l_@@_typesort_seq
\keys_define:nn { zref-clever / reference }
  {
    typesort .code:n =
      {
        \seq_set_from_clist:Nn \l_@@_typesort_seq {#1}
        \seq_reverse:N \l_@@_typesort_seq
      } ,
    typesort .initial:n =
      { part , chapter , section , paragraph },
    typesort .value_required:n = true ,
    notypesort .code:n =
      { \seq_clear:N \l_@@_typesort_seq } ,
    notypesort .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{comp} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_compress_bool
\keys_define:nn { zref-clever / reference }
  {
    comp .bool_set:N = \l_@@_typeset_compress_bool ,
    comp .initial:n = true ,
    comp .default:n = true ,
    nocomp .meta:n = { comp = false },
    nocomp .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{range} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_range_bool
\keys_define:nn { zref-clever / reference }
  {
    range .bool_set:N = \l_@@_typeset_range_bool ,
    range .initial:n = false ,
    range .default:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{hyperref} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_use_hyperref_bool
\bool_new:N \l_@@_warn_hyperref_bool
\keys_define:nn { zref-clever / reference }
  {
    hyperref .choice: ,
    hyperref / auto .code:n =
      {
        \bool_set_true:N \l_@@_use_hyperref_bool
        \bool_set_false:N \l_@@_warn_hyperref_bool
      } ,
    hyperref / true .code:n =
      {
        \bool_set_true:N \l_@@_use_hyperref_bool
        \bool_set_true:N \l_@@_warn_hyperref_bool
      } ,
    hyperref / false .code:n =
      {
        \bool_set_false:N \l_@@_use_hyperref_bool
        \bool_set_false:N \l_@@_warn_hyperref_bool
      } ,
    hyperref .initial:n = auto ,
    hyperref .default:n = auto
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\AddToHook { begindocument }
  {
    \@ifpackageloaded { hyperref }
      {
        \bool_if:NT \l_@@_use_hyperref_bool
          { \RequirePackage { zref-hyperref } }
      }
      {
        \bool_if:NT \l_@@_warn_hyperref_bool
          { \msg_warning:nn { zref-clever } { missing-hyperref } }
        \bool_set_false:N \l_@@_use_hyperref_bool
      }
    \keys_define:nn { zref-clever / reference }
      {
        hyperref .code:n =
          { \msg_warning:nn { zref-clever } { hyperref-preamble-only } }
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{nameinlink} option}
%
%    \begin{macrocode}
\str_new:N \l_@@_nameinlink_str
\keys_define:nn { zref-clever / reference }
  {
    nameinlink .choice: ,
    nameinlink / true .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { true } } ,
    nameinlink / false .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { false } } ,
    nameinlink / single .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { single } } ,
    nameinlink / tsingle .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { tsingle } } ,
    nameinlink .initial:n = tsingle ,
    nameinlink .default:n = true ,
  }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{cap} and \opt{capfirst} options}
%
%    \begin{macrocode}
\bool_new:N \l_@@_capitalize_bool
\bool_new:N \l_@@_capitalize_first_bool
\keys_define:nn { zref-clever / reference }
  {
    cap .bool_set:N = \l_@@_capitalize_bool ,
    cap .initial:n = false ,
    cap .default:n = true ,
    nocap .meta:n = { cap = false },
    nocap .value_forbidden:n = true ,

    capfirst .bool_set:N = \l_@@_capitalize_first_bool ,
    capfirst .initial:n = false ,
    capfirst .default:n = true ,

    C .meta:n =
      { capfirst = true , noabbrevfirst = true },
    C .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{abbrev} and \opt{noabbrevfirst} options}
%
%    \begin{macrocode}
\bool_new:N \l_@@_abbrev_bool
\bool_new:N \l_@@_noabbrev_first_bool
\keys_define:nn { zref-clever / reference }
  {
    abbrev .bool_set:N = \l_@@_abbrev_bool ,
    abbrev .initial:n = false ,
    abbrev .default:n = true ,
    noabbrev .meta:n = { abbrev = false },
    noabbrev .value_forbidden:n = true ,

    noabbrevfirst .bool_set:N = \l_@@_noabbrev_first_bool ,
    noabbrevfirst .initial:n = false ,
    noabbrevfirst .default:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{lang} option}
% \phantomsection{}\label{sec:lang-option}
%
% \cs{l_@@_current_language_tl} is an internal alias for \pkg{babel}'s
% \cs{languagename} or \pkg{polyglossia}'s \cs{mainbabelname} and, if none of
% them is loaded, we set it to \texttt{english}.  \cs{l_@@_main_language_tl}
% is an internal alias for \pkg{babel}'s \cs{bbl@main@language} or for
% \pkg{polyglossia}'s \cs{mainbabelname}, as the case may be. Note that for
% \pkg{polyglossia} we get \pkg{babel}'s language names, so that we only need
% to handle those internally.  \cs{l_@@_ref_language_tl} is the internal
% variable which stores the language in which the reference is to be made.
%
% The overall setup here seems a little roundabout, but this is actually
% required.  In the preamble, we (potentially) don't yet have values for the
% ``main'' and ``current'' document languages, this must be retrieved at a
% \texttt{begindocument} hook.  The \texttt{begindocument} hook is responsible
% to get values for \cs{l_@@_main_language_tl} and
% \cs{l_@@_current_language_tl}, and to set the default for
% \cs{l_@@_ref_language_tl}.  Package options, or preamble calls to
% \cs{zcsetup} are also hooked at \texttt{begindocument}, but come after the
% first hook, so that the pertinent variables have been set when they are
% executed.  Finally, we set a third \texttt{begindocument} hook, at
% \texttt{begindocument/before}, so that it runs after any options set in the
% preamble.  This hook redefines the \opt{lang} option for immediate execution
% in the document body, and ensures the \texttt{main} language's dictionary
% gets loaded, if it hadn't been already.
%
% For the \pkg{babel} and \pkg{polyglossia} variables which store the ``main''
% and ``current'' languages, see \url{https://tex.stackexchange.com/a/233178},
% including comments, particularly the one by Javier Bezos.  For the
% \pkg{babel} and \pkg{polyglossia} variables which store the list of loaded
% languages, see \url{https://tex.stackexchange.com/a/281220}, including
% comments, particularly PLK's.  Note, however, that languages loaded by
% \cs{babelprovide}, either directly, ``on the fly'', or with the
% \texttt{provide} option, \texttt{do not} get included in \cs{bbl@loaded}.
%

%    \begin{macrocode}
\tl_new:N \l_@@_ref_language_tl
\tl_new:N \l_@@_main_language_tl
\tl_new:N \l_@@_current_language_tl
\AddToHook { begindocument }
  {
    \@ifpackageloaded { babel }
      {
        \tl_set:Nn \l_@@_current_language_tl { \languagename }
        \tl_set:Nn \l_@@_main_language_tl { \bbl@main@language }
      }
      {
        \@ifpackageloaded { polyglossia }
          {
            \tl_set:Nn \l_@@_current_language_tl { \babelname }
            \tl_set:Nn \l_@@_main_language_tl { \mainbabelname }
          }
          {
            \tl_set:Nn \l_@@_current_language_tl { english }
            \tl_set:Nn \l_@@_main_language_tl { english }
          }
      }
%    \end{macrocode}
% Provide default value for \cs{l_@@_ref_language_tl} corresponding to option
% \opt{main}, but do so outside of the \pkg{l3keys} machinery (that is,
% instead of using \texttt{.initial:n}), so that we are able to distinguish
% when the user actually gave the option, in which case the dictionary loading
% is done verbosely, from when we are setting the default value (here), in
% which case the dictionary loading is done silently.
%    \begin{macrocode}
    \tl_set:Nn \l_@@_ref_language_tl
      { \l_@@_main_language_tl }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\keys_define:nn { zref-clever / reference }
  {
    lang .code:n =
      {
        \AddToHook { begindocument }
          {
            \str_case:nnF {#1}
              {
                { main }
                {
                  \tl_set:Nn \l_@@_ref_language_tl
                    { \l_@@_main_language_tl }
                  \@@_provide_dictionary_verbose:x
                    { \l_@@_ref_language_tl }
                }

                { current }
                {
                  \tl_set:Nn \l_@@_ref_language_tl
                    { \l_@@_current_language_tl }
                  \@@_provide_dictionary_verbose:x
                    { \l_@@_ref_language_tl }
                }
              }
              {
                \tl_set:Nn \l_@@_ref_language_tl {#1}
                \@@_provide_dictionary_verbose:x
                  { \l_@@_ref_language_tl }
              }
          }
      } ,
    lang .value_required:n = true ,
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\AddToHook { begindocument / before }
  {
    \AddToHook { begindocument }
      {
%    \end{macrocode}
% If any \opt{lang} option has been given by the user, the corresponding
% language is already loaded, otherwise, ensure the default one
% (\texttt{main}) gets loaded early, but not verbosely.
%    \begin{macrocode}
        \@@_provide_dictionary:x { \l_@@_ref_language_tl }
%    \end{macrocode}
% Redefinition of the \texttt{lang} key option for the document body.
%    \begin{macrocode}
        \keys_define:nn { zref-clever / reference }
          {
            lang .code:n =
              {
                \str_case:nnF {#1}
                  {
                    { main }
                    {
                      \tl_set:Nn \l_@@_ref_language_tl
                        { \l_@@_main_language_tl }
                      \@@_provide_dictionary_verbose:x
                        { \l_@@_ref_language_tl }
                    }

                    { current }
                    {
                      \tl_set:Nn \l_@@_ref_language_tl
                        { \l_@@_current_language_tl }
                      \@@_provide_dictionary_verbose:x
                        { \l_@@_ref_language_tl }
                    }
                  }
                  {
                    \tl_set:Nn \l_@@_ref_language_tl {#1}
                    \@@_provide_dictionary_verbose:x
                      { \l_@@_ref_language_tl }
                  }
              } ,
            lang .value_required:n = true ,
          }
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{font} option}
%
%    \begin{macrocode}
\tl_new:N \l_@@_ref_typeset_font_tl
\keys_define:nn { zref-clever / reference }
  { font .tl_set:N = \l_@@_ref_typeset_font_tl }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{note} option}
%
%    \begin{macrocode}
\tl_new:N \l_@@_zcref_note_tl
\keys_define:nn { zref-clever / reference }
  {
    note .tl_set:N = \l_@@_zcref_note_tl ,
    note .value_required:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{check} option}
%
% Integration with \pkg{zref-check}.
%
%    \begin{macrocode}
\bool_new:N \l_@@_zrefcheck_available_bool
\bool_new:N \l_@@_zcref_with_check_bool
\keys_define:nn { zref-clever / reference }
  {
    check .code:n =
      { \msg_warning:nn { zref-clever } { check-document-only } } ,
  }
\AddToHook { begindocument }
  {
    \@ifpackageloaded { zref-check }
      {
        \bool_set_true:N \l_@@_zrefcheck_available_bool
        \keys_define:nn { zref-clever / reference }
          {
            check .code:n =
              {
                \bool_set_true:N \l_@@_zcref_with_check_bool
                \keys_set:nn { zref-check / zcheck } {#1}
              }
          }
      }
      {
        \bool_set_false:N \l_@@_zrefcheck_available_bool
        \keys_define:nn { zref-clever / reference }
          {
            check .code:n =
              { \msg_warning:nn { zref-clever } { missing-zref-check } }
          }
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{Reference options}
% \label{sec:reference-options}
%
% This is a set of options related to reference typesetting which receive
% equal treatment and, hence, are handled in batch.  Since we are dealing with
% options to be passed to \cs{zcref} or to \cs{zcsetup} or at load time, only
% ``not necessarily type-specific'' options are pertinent here.  However, they
% \emph{may} either be type-specific or language-specific, and thus must be
% stored in a property list, \cs{l_@@_ref_options_prop}, in order to be
% retrieved from the option \emph{name} by \cs{@@_get_ref_string:nN} and
% \cs{@@_get_ref_font:nN} according to context and precedence rules.
%
% The keys are set so that any value, including an empty one, is added to
% \cs{l_@@_ref_options_prop}, while a key with \emph{no value} removes the
% property from the list, so that these options can then fall back to lower
% precedence levels settings.  For discussion about the used technique, see
% Section~\ref{sec:zcreftypesetup}.
%
%    \begin{macrocode}
\prop_new:N \l_@@_ref_options_prop
\seq_map_inline:Nn
  \c_@@_ref_options_reference_seq
  {
    \keys_define:nn { zref-clever / reference }
      {
        #1 .default:V = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              { \prop_remove:Nn \l_@@_ref_options_prop {#1} }
              { \prop_put:Nnn \l_@@_ref_options_prop {#1} {##1} }
          } ,
      }
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{Package options}
%
% The options have been separated in two different groups, so that we can
% potentially apply them selectively to different contexts: \texttt{label} and
% \texttt{reference}.  Currently, the only use of this selection is the
% ability to exclude label related options from \cs{zcref}'s options.  Anyway,
% for load-time package options and for \cs{zcsetup} we want the whole set, so
% we aggregate the two into \texttt{zref-clever/zcsetup}, and use that here.
%
%    \begin{macrocode}
\keys_define:nn { }
  {
    zref-clever / zcsetup .inherit:n = zref-clever / label ,
    zref-clever / zcsetup .inherit:n = zref-clever / reference ,
  }
%    \end{macrocode}
%
%
% Process load-time package options
% (\url{https://tex.stackexchange.com/a/15840}).
%    \begin{macrocode}
\ProcessKeysOptions { zref-clever / zcsetup }
%    \end{macrocode}
%
%
%
% \section{Configuration}
%
% \subsection{\cs{zcsetup}}
%
%
% \begin{macro}[int]{\zcsetup}
%   Provide \cs{zcsetup}.
%   \begin{syntax}
%     \cs{zcsetup}\marg{options}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcsetup { m }
  { \keys_set:nn { zref-clever / zcsetup } {#1} }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{\cs{zcRefTypeSetup}}
% \label{sec:zcreftypesetup}
%
% \cs{zcRefTypeSetup} is the main user interface for ``type-specific''
% reference formatting.  Settings done by this command have a higher
% precedence than any translation, hence they override any language-specific
% setting, either done at \cs{zcDeclareTranslations} or by the package's
% dictionaries.  On the other hand, they have a lower precedence than non
% type-specific general options.  The \meta{options} should be given in the
% usual \texttt{key=val} format.  The \meta{type} does not need to pre-exist,
% the property list variable to store the properties for the type gets created
% if need be.
%
% \begin{macro}[int]{\zcRefTypeSetup}
%   \begin{syntax}
%     \cs{zcRefTypeSetup} \marg{type} \marg{options}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcRefTypeSetup { m m }
  {
    \prop_if_exist:cF { l_@@_type_ #1 _options_prop }
      { \prop_new:c { l_@@_type_ #1 _options_prop } }
    \tl_set:Nn \l_@@_setup_type_tl {#1}
    \keys_set:nn { zref-clever / typesetup } {#2}
  }
%    \end{macrocode}
% \end{macro}
%
%
% Inside \cs{zcRefTypeSetup} any of the options \emph{can} receive empty
% values, and those values, if they exist in the property list, will override
% translations, regardless of their emptiness.  In principle, we could live
% with the situation of, once a setting has been made in
% \cs{l_@@_type_<type>_options_prop} or in \cs{l_@@_ref_options_prop} it stays
% there forever, and can only be overridden by a new value at the same
% precedence level or a higher one.  But it would be nice if an user can
% ``unset'' an option at either of those scopes to go back to the lower
% precedence level of the translations at any given point.  So both in
% \cs{zcRefTypeSetup} and in setting reference options (see
% Section~\ref{sec:reference-options}), we leverage the distinction of an
% ``empty valued key'' (|key=| or |key={}|) from a ``key with no value''
% (|key|).  This distinction is captured internally by the lower-level key
% parsing, but must be made explicit at \cs{keys_set:nn} by means of the
% \texttt{.default:V} property of the key in \cs{keys_define:nn}.  For the
% technique and some discussion about it, see
% \url{https://tex.stackexchange.com/q/614690} (thanks Jonathan P.\ Spratte,
% aka `Skillmon', and Phelype Oleinik) and
% \url{https://github.com/latex3/latex3/pull/988}.
%
%    \begin{macrocode}
\seq_map_inline:Nn
  \c_@@_ref_options_necessarily_not_type_specific_seq
  {
    \keys_define:nn { zref-clever / typesetup }
      {
        #1 .code:n =
          {
            \msg_warning:nnn { zref-clever }
              { option-not-type-specific } {#1}
          } ,
      }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\seq_map_inline:Nn
  \c_@@_ref_options_typesetup_seq
  {
    \keys_define:nn { zref-clever / typesetup }
      {
        #1 .default:V = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              {
                \prop_remove:cn
                  {
                    l_@@_type_
                    \l_@@_setup_type_tl _options_prop
                  }
                  {#1}
              }
              {
                \prop_put:cnn
                  {
                    l_@@_type_
                    \l_@@_setup_type_tl _options_prop
                  }
                  {#1} {##1}
              }
          } ,
      }
  }
%    \end{macrocode}
%
%
%
% \subsection{\cs{zcDeclareTranslations}}
%
% \cs{zcDeclareTranslations} is the main user interface for
% ``language-specific'' reference formatting, be it ``type-specific'' or not.
% The difference between the two cases is captured by the \texttt{type} key,
% which works as a sort of a ``switch''.  Inside the \meta{options} argument
% of \cs{zcDeclareTranslations}, any options made before the first
% \texttt{type} key declare ``default'' (non type-specific) translations.
% When the \texttt{type} key is given with a value, the options following it
% will set ``type-specific'' translations for that type.  The current type can
% be switched off by an empty \texttt{type} key.  \cs{zcDeclareTranslations}
% is preamble only.
%
% \begin{macro}[int]{\zcDeclareTranslations}
%   \begin{syntax}
%     \cs{zcDeclareTranslations}\marg{language}\marg{options}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcDeclareTranslations { m m }
  {
    \group_begin:
    \prop_get:NnNTF \g_@@_languages_prop {#1}
      \l_@@_dict_language_tl
      {
        \tl_clear:N \l_@@_setup_type_tl
        \keys_set:nn { zref-clever / translations } {#2}
      }
      { \msg_warning:nnn { zref-clever } { unknown-language-transl } {#1} }
    \group_end:
  }
\@onlypreamble \zcDeclareTranslations
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}
%   {
%     \@@_declare_type_transl:nnnn ,
%     \@@_declare_default_transl:nnn ,
%   }
%   A couple of auxiliary functions for the of
%   \texttt{{zref-clever/translation}} keys set in \cs{zcDeclareTranslations}.
%   They respectively declare (unconditionally set) ``type-specific'' and
%   ``default'' translations.
%   \begin{syntax}
%     \cs{@@_declare_type_transl:nnnn} \Arg{language} \Arg{type}
%     ~~\Arg{key} \Arg{translation}
%     \cs{@@_declare_default_transl:nnn} \Arg{language}
%     ~~\Arg{key} \Arg{translation}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_declare_type_transl:nnnn #1#2#3#4
  {
    \prop_gput:cnn { g_@@_dict_ #1 _prop }
      { type- #2 - #3 } {#4}
  }
\cs_generate_variant:Nn \@@_declare_type_transl:nnnn { VVnn }
\cs_new_protected:Npn \@@_declare_default_transl:nnn #1#2#3
  {
    \prop_gput:cnn { g_@@_dict_ #1 _prop }
      { default- #2 } {#3}
  }
\cs_generate_variant:Nn \@@_declare_default_transl:nnn { Vnn }
%    \end{macrocode}
% \end{macro}
%
%
% The set of keys for \texttt{{zref-clever/translations}}, which is used to
% set language-specific translations in \cs{zcDeclareTranslations}.
%
%    \begin{macrocode}
\keys_define:nn { zref-clever / translations }
  {
    type .code:n =
      {
        \tl_if_empty:nTF {#1}
          { \tl_clear:N \l_@@_setup_type_tl }
          { \tl_set:Nn \l_@@_setup_type_tl {#1} }
      } ,
  }
\seq_map_inline:Nn
  \c_@@_ref_options_necessarily_not_type_specific_seq
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \@@_declare_default_transl:Vnn
                  \l_@@_dict_language_tl
                  {#1} {##1}
              }
              {
                \msg_warning:nnn { zref-clever }
                  { option-not-type-specific } {#1}
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \c_@@_ref_options_possibly_type_specific_seq
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \@@_declare_default_transl:Vnn
                  \l_@@_dict_language_tl
                  {#1} {##1}
              }
              {
                \@@_declare_type_transl:VVnn
                  \l_@@_dict_language_tl
                  \l_@@_setup_type_tl
                  {#1} {##1}
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \c_@@_ref_options_necessarily_type_specific_seq
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \msg_warning:nnn { zref-clever }
                  { option-only-type-specific } {#1}
              }
              {
                \@@_declare_type_transl:VVnn
                  \l_@@_dict_language_tl
                  \l_@@_setup_type_tl
                  {#1} {##1}
              }
          } ,
      }
  }
%    \end{macrocode}
%
%
%
% \section{User interface}
%
% \subsection{\cs{zcref}}
%
%
% \begin{macro}[int]{\zcref}
%   The main user command of the package.
%   \begin{syntax}
%     \cs{zcref}\meta{*}\oarg{options}\marg{labels}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcref { s O { } m }
  { \zref@wrapper@babel \@@_zcref:nnn {#3} {#1} {#2} }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_zcref:nnnn}
%   An intermediate internal function, which does the actual heavy lifting,
%   and places \Arg{labels} as first argument, so that it can be protected by
%   \cs{zref@wrapper@babel} in \cs{zcref}.
%   \begin{syntax}
%     \cs{@@_zcref:nnnn} \Arg{labels} \Arg{*} \Arg{options}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_zcref:nnn #1#2#3
  {
    \group_begin:
%    \end{macrocode}
% Set options.
%    \begin{macrocode}
      \keys_set:nn { zref-clever / reference } {#3}
%    \end{macrocode}
% Store arguments values.
%    \begin{macrocode}
      \seq_set_from_clist:Nn \l_@@_zcref_labels_seq {#1}
      \bool_set:Nn \l_@@_link_star_bool {#2}
%    \end{macrocode}
% Ensure dictionary for reference language is loaded, if available.  We cannot
% rely on \cs{keys_set:nn} for the task, since if the \opt{lang} option is set
% for \texttt{current}, the actual language may have changed outside our
% control.  \cs{@@_provide_dictionary:x} does nothing if the dictionary is
% already loaded.
%    \begin{macrocode}
      \@@_provide_dictionary:x { \l_@@_ref_language_tl }
%    \end{macrocode}
% Integration with \pkg{zref-check}.
%    \begin{macrocode}
      \bool_lazy_and:nnT
        { \l_@@_zrefcheck_available_bool }
        { \l_@@_zcref_with_check_bool }
        { \zrefcheck_zcref_beg_label: }
%    \end{macrocode}
% Sort the labels.
%    \begin{macrocode}
      \bool_lazy_or:nnT
        { \l_@@_typeset_sort_bool }
        { \l_@@_typeset_range_bool }
        { \@@_sort_labels: }
%    \end{macrocode}
% Typeset the references.  Also, set the reference font, and group it, so that
% it does not leak to the note.
%    \begin{macrocode}
      \group_begin:
      \l_@@_ref_typeset_font_tl
      \@@_typeset_refs:
      \group_end:
%    \end{macrocode}
% Typeset \texttt{note}.
%    \begin{macrocode}
      \@@_get_ref_string:nN { notesep } \l_tmpa_tl
      \l_tmpa_tl
      \l_@@_zcref_note_tl
%    \end{macrocode}
% Integration with \pkg{zref-check}.
%    \begin{macrocode}
      \bool_lazy_and:nnT
        { \l_@@_zrefcheck_available_bool }
        { \l_@@_zcref_with_check_bool }
        {
          \zrefcheck_zcref_end_label_maybe:
          \zrefcheck_zcref_run_checks_on_labels:n
            { \l_@@_zcref_labels_seq }
        }
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_zcref_labels_seq, \l_@@_link_star_bool}
%    \begin{macrocode}
\seq_new:N \l_@@_zcref_labels_seq
\bool_new:N \l_@@_link_star_bool
%    \end{macrocode}
% \end{variable}
%
%
%
% \subsection{\cs{zcpageref}}
%
%
% \begin{macro}[int]{\zcpageref}
%   A \cs{pageref} equivalent of \cs{zcref}.
%   \begin{syntax}
%     \cs{zcpageref}\meta{*}\oarg{options}\marg{labels}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcpageref { s O { } m }
  {
    \IfBooleanTF {#1}
      { \zcref*[#2, ref = page] {#3} }
      { \zcref [#2, ref = page] {#3} }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Sorting}
%
% Sorting is certainly a ``big task'' for \pkg{zref-clever} but, in the end,
% it boils down to ``carefully done branching'', and quite some of it.  The
% sorting of ``page'' references is very much lightened by the availability of
% \texttt{abspage}, from the \pkg{zref-abspage} module, which offers ``just
% what we need'' for our purposes.  The sorting of ``default'' references
% falls on two main cases: i) labels of the same type; ii) labels of different
% types.  The first case is sorted according to the priorities set by the
% \opt{typesort} option or, if that is silent for the case, by the order in
% which labels were given by the user in \cs{zcref}.  The second case is the
% most involved one, since it is possible for multiple counters to be bundled
% together in a single reference type.  Because of this, sorting must take
% into account the whole chain of ``enclosing counters'' for the counters of
% the labels at hand.
%
% \begin{variable}
%   {
%     \l_@@_label_type_a_tl ,
%     \l_@@_label_type_b_tl ,
%     \l_@@_label_enclcnt_a_tl ,
%     \l_@@_label_enclcnt_b_tl ,
%     \l_@@_label_enclval_a_tl ,
%     \l_@@_label_enclval_b_tl ,
%   }
%   Auxiliary variables, for use in sorting, and some also in typesetting.
%   Used to store reference information -- label properties -- of the
%   ``current'' (\texttt{a}) and ``next'' (\texttt{b}) labels.
%    \begin{macrocode}
\tl_new:N \l_@@_label_type_a_tl
\tl_new:N \l_@@_label_type_b_tl
\tl_new:N \l_@@_label_enclcnt_a_tl
\tl_new:N \l_@@_label_enclcnt_b_tl
\tl_new:N \l_@@_label_enclval_a_tl
\tl_new:N \l_@@_label_enclval_b_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_sort_decided_bool}
%   Auxiliary variable for \cs{@@_sort_default_same_type:nn}, signals if the
%   sorting between two labels has been decided or not.
%    \begin{macrocode}
\bool_new:N \l_@@_sort_decided_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_sort_prior_a_int,\l_@@_sort_prior_b_int}
%   Auxiliary variables for \cs{@@_sort_default_different_types:nn}.  Store
%   the sort priority of the ``current'' and ``next'' labels.
%    \begin{macrocode}
\int_new:N \l_@@_sort_prior_a_int
\int_new:N \l_@@_sort_prior_b_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_label_types_seq}
%   Stores the order in which reference types appear in the label list
%   supplied by the user in \cs{zcref}.  This variable is populated by
%   \cs{@@_label_type_put_new_right:n} at the start of \cs{@@_sort_labels:}.
%   This order is required as a ``last resort'' sort criterion between the
%   reference types, for use in \cs{@@_sort_default_different_types:nn}.
%    \begin{macrocode}
\seq_new:N \l_@@_label_types_seq
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\@@_sort_labels:}
%   The main sorting function.  It does not receive arguments, but it is
%   expected to be run inside \cs{@@_zcref:nnnn} where a number of environment
%   variables are to be set appropriately.  In particular,
%   \cs{l_@@_zcref_labels_seq} should contain the labels received as argument
%   to \cs{zcref}, and the function performs its task by sorting this
%   variable.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_labels:
  {
%    \end{macrocode}
% Store label types sequence.
%    \begin{macrocode}
    \seq_clear:N \l_@@_label_types_seq
    \tl_if_eq:NnF \l_@@_ref_property_tl { page }
      {
        \seq_map_function:NN \l_@@_zcref_labels_seq
          \@@_label_type_put_new_right:n
      }
%    \end{macrocode}
% Sort.
%    \begin{macrocode}
    \seq_sort:Nn \l_@@_zcref_labels_seq
      {
        \zref@ifrefundefined {##1}
          {
            \zref@ifrefundefined {##2}
              {
                % Neither label is defined.
                \sort_return_same:
              }
              {
                % The second label is defined, but the first isn't, leave the
                % undefined first (to be more visible).
                \sort_return_same:
              }
          }
          {
            \zref@ifrefundefined {##2}
              {
                % The first label is defined, but the second isn't, bring the
                % second forward.
                \sort_return_swapped:
              }
              {
                % The interesting case: both labels are defined.  References
                % to the "default" property or to the "page" are quite
                % different with regard to sorting, so we branch them here to
                % specialized functions.
                \tl_if_eq:NnTF \l_@@_ref_property_tl { page }
                  { \@@_sort_page:nn {##1} {##2} }
                  { \@@_sort_default:nn {##1} {##2} }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_label_type_put_new_right:n}
%   Auxiliary function used to store the order in which reference types appear
%   in the label list supplied by the user in \cs{zcref}.  It is expected to
%   be run inside \cs{@@_sort_labels:}, and stores the types sequence in
%   \cs{l_@@_label_types_seq}.  I have tried to handle the same task inside
%   \cs{seq_sort:Nn} in \cs{@@_sort_labels:} to spare mapping over
%   \cs{l_@@_zcref_labels_seq}, but it turned out it not to be easy to rely on
%   the order the labels get processed at that point, since the variable is
%   being sorted there.  Besides, the mapping is simple, not a particularly
%   expensive operation.  Anyway, this keeps things clean.
%   \begin{syntax}
%     \cs{@@_label_type_put_new_right:n} \Arg{label}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_label_type_put_new_right:n #1
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \seq_if_in:NVF \l_@@_label_types_seq
      \l_@@_label_type_a_tl
      {
        \seq_put_right:NV \l_@@_label_types_seq
          \l_@@_label_type_a_tl
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_sort_default:nn}
%   The heavy-lifting function for sorting of defined labels for ``default''
%   references (that is, a standard reference, not to ``page'').  This
%   function is expected to be called within the sorting loop of
%   \cs{@@_sort_labels:} and receives the pair of labels being considered for
%   a change of order or not.  It should \emph{always} ``return'' either
%   \cs{sort_return_same:} or \cs{sort_return_swapped:}.
%   \begin{syntax}
%     \cs{@@_sort_default:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_default:nn #1#2
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_type_b_tl
      { \zref@extractdefault {#2} { zc@type } { \c_empty_tl } }

    \bool_if:nTF
      {
        % The second label has a type, but the first doesn't, leave the
        % undefined first (to be more visible).
        \tl_if_empty_p:N \l_@@_label_type_a_tl &&
        ! \tl_if_empty_p:N \l_@@_label_type_b_tl
      }
      { \sort_return_same: }
      {
        \bool_if:nTF
          {
            % The first label has a type, but the second doesn't, bring the
            % second forward.
            ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
            \tl_if_empty_p:N \l_@@_label_type_b_tl
          }
          { \sort_return_swapped: }
          {
            \bool_if:nTF
              {
                % The interesting case: both labels have a type...
                ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
                ! \tl_if_empty_p:N \l_@@_label_type_b_tl
              }
              {
                \tl_if_eq:NNTF
                  \l_@@_label_type_a_tl
                  \l_@@_label_type_b_tl
                  % ...and it's the same type.
                  { \@@_sort_default_same_type:nn {#1} {#2} }
                  % ...and they are different types.
                  { \@@_sort_default_different_types:nn {#1} {#2} }
              }
              {
                % Neither label has a type.  We can't do much of meaningful
                % here, but if it's the same counter, compare it.
                \exp_args:Nxx \tl_if_eq:nnTF
                  { \zref@extractdefault {#1} { counter } { } }
                  { \zref@extractdefault {#2} { counter } { } }
                  {
                    \int_compare:nNnTF
                      { \zref@extractdefault {#1} { zc@cntval } { -1 } }
                        >
                      { \zref@extractdefault {#2} { zc@cntval } { -1 } }
                      { \sort_return_swapped: }
                      { \sort_return_same:    }
                  }
                  { \sort_return_same: }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% Variant not provided by the kernel, for use in
% \cs{@@_sort_default_same_type:nn}.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_reverse_items:n { V }
%    \end{macrocode}
%
% \begin{macro}{\@@_sort_default_same_type:nn}
%   \begin{syntax}
%     \cs{@@_sort_default_same_type:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_default_same_type:nn #1#2
  {
    \tl_set:Nx \l_@@_label_enclcnt_a_tl
      { \zref@extractdefault {#1} { zc@enclcnt } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclcnt_a_tl
      { \tl_reverse_items:V \l_@@_label_enclcnt_a_tl }
    \tl_set:Nx \l_@@_label_enclcnt_b_tl
      { \zref@extractdefault {#2} { zc@enclcnt } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclcnt_b_tl
      { \tl_reverse_items:V \l_@@_label_enclcnt_b_tl }
    \tl_set:Nx \l_@@_label_enclval_a_tl
      { \zref@extractdefault {#1} { zc@enclval } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclval_a_tl
      { \tl_reverse_items:V \l_@@_label_enclval_a_tl }
    \tl_set:Nx \l_@@_label_enclval_b_tl
      { \zref@extractdefault {#2} { zc@enclval } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_enclval_b_tl
      { \tl_reverse_items:V \l_@@_label_enclval_b_tl }

    \bool_set_false:N \l_@@_sort_decided_bool
    \bool_until_do:Nn \l_@@_sort_decided_bool
      {
        \bool_if:nTF
          {
            % Both are empty: neither label has any (further) "enclosing
            % counters" (left).
            \tl_if_empty_p:V \l_@@_label_enclcnt_a_tl &&
            \tl_if_empty_p:V \l_@@_label_enclcnt_b_tl
          }
          {
            \exp_args:Nxx \tl_if_eq:nnTF
              { \zref@extractdefault {#1} { counter } { } }
              { \zref@extractdefault {#2} { counter } { } }
              {
                \bool_set_true:N \l_@@_sort_decided_bool
                \int_compare:nNnTF
                  { \zref@extractdefault {#1} { zc@cntval } { -1 } }
                    >
                  { \zref@extractdefault {#2} { zc@cntval } { -1 } }
                  { \sort_return_swapped: }
                  { \sort_return_same:    }
              }
              {
                \msg_warning:nnnn { zref-clever }
                  { counters-not-nested } {#1} {#2}
                \bool_set_true:N \l_@@_sort_decided_bool
                \sort_return_same:
              }
          }
          {
            \bool_if:nTF
              {
                % `a' is empty (and `b' is not): `b' may be nested in `a'.
                \tl_if_empty_p:V \l_@@_label_enclcnt_a_tl
              }
              {
                \exp_args:NNx \tl_if_in:NnTF
                  \l_@@_label_enclcnt_b_tl
                  { {\zref@extractdefault {#1} { counter } { }} }
                  {
                    \bool_set_true:N \l_@@_sort_decided_bool
                    \sort_return_same:
                  }
                  {
                    \msg_warning:nnnn { zref-clever }
                      { counters-not-nested } {#1} {#2}
                    \bool_set_true:N \l_@@_sort_decided_bool
                    \sort_return_same:
                  }
              }
              {
                \bool_if:nTF
                  {
                    % `b' is empty (and `a' is not): `a' may be nested in `b'.
                    \tl_if_empty_p:V \l_@@_label_enclcnt_b_tl
                  }
                  {
                    \exp_args:NNx \tl_if_in:NnTF
                      \l_@@_label_enclcnt_a_tl
                      { {\zref@extractdefault {#2} { counter } { }} }
                      {
                        \bool_set_true:N \l_@@_sort_decided_bool
                        \sort_return_swapped:
                      }
                      {
                        \msg_warning:nnnn { zref-clever }
                          { counters-not-nested } {#1} {#2}
                        \bool_set_true:N \l_@@_sort_decided_bool
                        \sort_return_same:
                      }
                  }
                  {
                    % Neither is empty: we can (possibly) compare the values
                    % of the current enclosing counter in the loop, if they
                    % are equal, we are still in the loop, if they are not, a
                    % sorting decision can be made directly.
                    \exp_args:Nxx \tl_if_eq:nnTF
                      { \tl_head:N \l_@@_label_enclcnt_a_tl }
                      { \tl_head:N \l_@@_label_enclcnt_b_tl }
                      {
                        \int_compare:nNnTF
                          { \tl_head:N \l_@@_label_enclval_a_tl }
                            =
                          { \tl_head:N \l_@@_label_enclval_b_tl }
                          {
                            \tl_set:Nx \l_@@_label_enclcnt_a_tl
                              { \tl_tail:N \l_@@_label_enclcnt_a_tl }
                            \tl_set:Nx \l_@@_label_enclcnt_b_tl
                              { \tl_tail:N \l_@@_label_enclcnt_b_tl }
                            \tl_set:Nx \l_@@_label_enclval_a_tl
                              { \tl_tail:N \l_@@_label_enclval_a_tl }
                            \tl_set:Nx \l_@@_label_enclval_b_tl
                              { \tl_tail:N \l_@@_label_enclval_b_tl }
                          }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \int_compare:nNnTF
                              { \tl_head:N \l_@@_label_enclval_a_tl }
                                >
                              { \tl_head:N \l_@@_label_enclval_b_tl }
                              { \sort_return_swapped: }
                              { \sort_return_same:    }
                          }
                      }
                      {
                        \msg_warning:nnnn { zref-clever }
                          { counters-not-nested } {#1} {#2}
                        \bool_set_true:N \l_@@_sort_decided_bool
                        \sort_return_same:
                      }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_sort_default_different_types:nn}
%   \begin{syntax}
%     \cs{@@_sort_default_different_types:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_default_different_types:nn #1#2
  {
%    \end{macrocode}
% Retrieve sort priorities for \meta{label a} and \meta{label b}.
% \cs{l_@@_typesort_seq} was stored in reverse sequence, and we compute the
% sort priorities in the negative range, so that we can implicitly rely on `0'
% being the ``last value''.
%    \begin{macrocode}
    \int_zero:N \l_@@_sort_prior_a_int
    \int_zero:N \l_@@_sort_prior_b_int
    \seq_map_indexed_inline:Nn \l_@@_typesort_seq
      {
        \tl_if_eq:nnTF {##2} {{othertypes}}
          {
            \int_compare:nNnT { \l_@@_sort_prior_a_int } = { 0 }
              { \int_set:Nn \l_@@_sort_prior_a_int { - ##1 } }
            \int_compare:nNnT { \l_@@_sort_prior_b_int } = { 0 }
              { \int_set:Nn \l_@@_sort_prior_b_int { - ##1 } }
          }
          {
            \tl_if_eq:NnTF \l_@@_label_type_a_tl {##2}
              { \int_set:Nn \l_@@_sort_prior_a_int { - ##1 } }
              {
                \tl_if_eq:NnT \l_@@_label_type_b_tl {##2}
                  { \int_set:Nn \l_@@_sort_prior_b_int { - ##1 } }
              }
          }
      }
%    \end{macrocode}
% Then do the actual sorting.
%    \begin{macrocode}
    \bool_if:nTF
      {
        \int_compare_p:nNn
          { \l_@@_sort_prior_a_int } <
          { \l_@@_sort_prior_b_int }
      }
      { \sort_return_same: }
      {
        \bool_if:nTF
          {
            \int_compare_p:nNn
              { \l_@@_sort_prior_a_int } >
              { \l_@@_sort_prior_b_int }
          }
          { \sort_return_swapped: }
          {
            % Sort priorities are equal: the type that occurs first in
            % `labels', as given by the user, is kept (or brought) forward.
            \seq_map_inline:Nn \l_@@_label_types_seq
              {
                \tl_if_eq:NnTF \l_@@_label_type_a_tl {##1}
                  { \seq_map_break:n { \sort_return_same: } }
                  {
                    \tl_if_eq:NnT \l_@@_label_type_b_tl {##1}
                      { \seq_map_break:n { \sort_return_swapped: } }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_sort_page:nn}
%   The sorting function for sorting of defined labels for references to
%   ``page''.  This function is expected to be called within the sorting loop
%   of \cs{@@_sort_labels:} and receives the pair of labels being considered
%   for a change of order or not.  It should \emph{always} ``return'' either
%   \cs{sort_return_same:} or \cs{sort_return_swapped:}.  Compared to the
%   sorting of default labels, this is a piece of cake (thanks to
%   \texttt{abspage}).
%   \begin{syntax}
%     \cs{@@_sort_page:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_page:nn #1#2
  {
    \int_compare:nNnTF
      { \zref@extractdefault {#1} { abspage } {-1} }
        >
      { \zref@extractdefault {#2} { abspage } {-1} }
      { \sort_return_swapped: }
      { \sort_return_same:    }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Typesetting}
%
% ``Typesetting'' the reference, which here includes the parsing of the labels
% and eventual compression of labels in sequence into ranges, is definitely
% the ``crux'' of \pkg{zref-clever}.  This because we process the label set as
% a stack, in a single pass, and hence ``parsing'', ``compressing'', and
% ``typesetting'' must be decided upon at the same time, making it difficult
% to slice the job into more specific and self-contained tasks.  So, do bear
% this in mind before you curse me for the length of some of the functions
% below, or before a more orthodox ``docstripper'' complains about me not
% sticking to code commenting conventions to keep the code more readable in
% the \file{.dtx} file.
%
% While processing the label stack (kept in \cs{l_@@_typeset_labels_seq}),
% \cs{@@_typeset_refs:} ``sees'' two labels, and two labels only, the
% ``current'' one (kept in \cs{l_@@_label_a_tl}), and the ``next'' one (kept
% in \cs{l_@@_label_b_tl}).  However, the typesetting needs (a lot) more
% information than just these two immediate labels to make a number of
% critical decisions.  Some examples: i) We cannot know if labels ``current''
% and ``next'' of the same type are a ``pair'', or just ``elements in a
% list'', until we examine the label after ``next''; ii) If the ``next'' label
% is of the same type as the ``current'', and it is in immediate sequence to
% it, it potentially forms a ``range'', but we cannot know if ``next'' is
% actually the end of the range until we examined an arbitrary number of
% labels, and found one which is not in sequence from the previous one; iii)
% When processing a type block, the ``name'' comes first, however, we only
% know if that name should be plural, or if it should be included in the
% hyperlink, after processing an arbitrary number of labels and find one of a
% different type.  One could naively assume that just examining ``next'' would
% be enough for this, since we can know if it is of the same type or not.
% Alas, ``there be ranges'', and a compression operation may boil down to a
% single element, so we have to process the whole type block to know how its
% name should be typeset; iv) Similar issues apply to lists of type blocks,
% each of which is of arbitrary length: we can only know if two type blocks
% form a ``pair'' or are ``elements in a list'' when we finish the
% block. Etc.\ etc.\ etc.
%
% We handle this by storing the reference ``pieces'' in ``queues'', instead of
% typesetting them immediately upon processing.  The ``queues'' get typeset at
% the point where all the information needed is available, which usually
% happens when a type block finishes (we see something of a different type in
% ``next'', signaled by \cs{l_@@_last_of_type_bool}), or the stack itself
% finishes (has no more elements, signaled by \cs{l_@@_typeset_last_bool}).
% And, in processing a type block, the type ``name'' gets added last (on the
% left) of the queue.  The very first reference of its type always follows the
% name, since it may form a hyperlink with it (so we keep it stored
% separately, in \cs{l_@@_type_first_label_tl}, with
% \cs{l_@@_type_first_label_type_tl} being its type).  And, since we may need
% up to two type blocks in storage before typesetting, we have two of these
% ``queues'': \cs{l_@@_typeset_queue_curr_tl} and
% \cs{l_@@_typeset_queue_prev_tl}.
%
% Some of the relevant cases (e.g., distinguishing ``pair'' from ``list'') are
% handled by counters, the main ones are: one for the ``type''
% (\cs{l_@@_type_count_int}) and one for the ``label in the current type
% block'' (\cs{l_@@_label_count_int}).
%
% Range compression, in particular, relies heavily on counting to be able do
% distinguish relevant cases.  \cs{l_@@_range_count_int} counts the number of
% elements in the current sequential ``streak'', and
% \cs{l_@@_range_same_count_int} counts the number of \emph{equal} elements in
% that same ``streak''.  The difference between the two allows us to
% distinguish the cases in which a range actually ``skips'' a number in the
% sequence, in which case we should use a range separator, from when they are
% after all just contiguous, in which case a pair separator is called for.
% Since, as usual, we can only know this when a arbitrary long ``streak''
% finishes, we have to store the label which (potentially) begins a range
% (kept in \cs{l_@@_range_beg_label_tl}).  \cs{l_@@_next_maybe_range_bool}
% signals when ``next'' is potentially a range with ``current'', and
% \cs{l_@@_next_is_same_bool} when their values are actually equal.
%
%
% One further thing to discuss here -- to keep this ``on record'' -- is
% inhibition of compression for individual labels.  It is not difficult to
% handle it at the infrastructure side, what gets sloppy is the user facing
% syntax to signal such inhibition.  For some possible alternatives for this
% (and good ones at that) see \url{https://tex.stackexchange.com/q/611370}
% (thanks Enrico Gregorio, Phelype Oleinik, and Steven B.\ Segletes).  Yet
% another alternative would be an option receiving the label(s) not to be
% compressed, this would be a repetition, but would keep the syntax clean.
% All in all, probably the best is simply not to allow individual inhibition
% of compression.  We can already control compression of each \cs{zcref} call
% with existing options, this should be enough.  I don't think the small extra
% flexibility individual label control for this would grant is worth the
% syntax disruption it would entail.  Anyway, it would be easy to deal with
% this in case the need arose, by just adding another condition (coming from
% whatever the chosen syntax was) when we check for
% \cs{@@_labels_in_sequence:nn} in \cs{@@_typeset_refs_not_last_of_type:}.
% But I remain unconvinced of the pertinence of doing so.
%
%
% \subsection*{Variables}
%
% \begin{variable}
%   {
%     \l_@@_typeset_labels_seq ,
%     \l_@@_typeset_last_bool ,
%     \l_@@_last_of_type_bool ,
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:} main stack control.
%    \begin{macrocode}
\seq_new:N \l_@@_typeset_labels_seq
\bool_new:N \l_@@_typeset_last_bool
\bool_new:N \l_@@_last_of_type_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_type_count_int ,
%     \l_@@_label_count_int ,
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:} main counters.
%    \begin{macrocode}
\int_new:N \l_@@_type_count_int
\int_new:N \l_@@_label_count_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_label_a_tl ,
%     \l_@@_label_b_tl ,
%     \l_@@_typeset_queue_prev_tl ,
%     \l_@@_typeset_queue_curr_tl ,
%     \l_@@_type_first_label_tl ,
%     \l_@@_type_first_label_type_tl
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:} main ``queue'' control and
%   storage.
%    \begin{macrocode}
\tl_new:N \l_@@_label_a_tl
\tl_new:N \l_@@_label_b_tl
\tl_new:N \l_@@_typeset_queue_prev_tl
\tl_new:N \l_@@_typeset_queue_curr_tl
\tl_new:N \l_@@_type_first_label_tl
\tl_new:N \l_@@_type_first_label_type_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_type_name_tl ,
%     \l_@@_name_in_link_bool ,
%     \l_@@_name_format_tl ,
%     \l_@@_name_format_fallback_tl
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:} type name handling.
%    \begin{macrocode}
\tl_new:N \l_@@_type_name_tl
\bool_new:N \l_@@_name_in_link_bool
\tl_new:N \l_@@_name_format_tl
\tl_new:N \l_@@_name_format_fallback_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_range_count_int ,
%     \l_@@_range_same_count_int ,
%     \l_@@_range_beg_label_tl ,
%     \l_@@_next_maybe_range_bool ,
%     \l_@@_next_is_same_bool ,
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:} range handling.
%    \begin{macrocode}
\int_new:N \l_@@_range_count_int
\int_new:N \l_@@_range_same_count_int
\tl_new:N \l_@@_range_beg_label_tl
\bool_new:N \l_@@_next_maybe_range_bool
\bool_new:N \l_@@_next_is_same_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_tpairsep_tl ,
%     \l_@@_tlistsep_tl ,
%     \l_@@_tlastsep_tl ,
%     \l_@@_namesep_tl ,
%     \l_@@_pairsep_tl ,
%     \l_@@_listsep_tl ,
%     \l_@@_lastsep_tl ,
%     \l_@@_rangesep_tl ,
%     \l_@@_refpre_out_tl ,
%     \l_@@_refpos_out_tl ,
%     \l_@@_refpre_in_tl ,
%     \l_@@_refpos_in_tl ,
%     \l_@@_namefont_tl ,
%     \l_@@_reffont_out_tl ,
%     \l_@@_reffont_in_tl ,
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:} separators, refpre/pos and
%   font options.
%    \begin{macrocode}
\tl_new:N \l_@@_tpairsep_tl
\tl_new:N \l_@@_tlistsep_tl
\tl_new:N \l_@@_tlastsep_tl
\tl_new:N \l_@@_namesep_tl
\tl_new:N \l_@@_pairsep_tl
\tl_new:N \l_@@_listsep_tl
\tl_new:N \l_@@_lastsep_tl
\tl_new:N \l_@@_rangesep_tl
\tl_new:N \l_@@_refpre_out_tl
\tl_new:N \l_@@_refpos_out_tl
\tl_new:N \l_@@_refpre_in_tl
\tl_new:N \l_@@_refpos_in_tl
\tl_new:N \l_@@_namefont_tl
\tl_new:N \l_@@_reffont_out_tl
\tl_new:N \l_@@_reffont_in_tl
%    \end{macrocode}
% \end{variable}
%
%
% \subsection*{Main functions}
%
% \begin{macro}{\@@_typeset_refs:}
%   Main typesetting function for \cs{zcref}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_refs:
  {
    \seq_set_eq:NN \l_@@_typeset_labels_seq
      \l_@@_zcref_labels_seq
    \tl_clear:N \l_@@_typeset_queue_prev_tl
    \tl_clear:N \l_@@_typeset_queue_curr_tl
    \tl_clear:N \l_@@_type_first_label_tl
    \tl_clear:N \l_@@_type_first_label_type_tl
    \tl_clear:N \l_@@_range_beg_label_tl
    \int_zero:N \l_@@_label_count_int
    \int_zero:N \l_@@_type_count_int
    \int_zero:N \l_@@_range_count_int
    \int_zero:N \l_@@_range_same_count_int

    % Get type block options (not type-specific).
    \@@_get_ref_string:nN { tpairsep }
      \l_@@_tpairsep_tl
    \@@_get_ref_string:nN { tlistsep }
      \l_@@_tlistsep_tl
    \@@_get_ref_string:nN { tlastsep }
      \l_@@_tlastsep_tl

    % Process label stack.
    \bool_set_false:N \l_@@_typeset_last_bool
    \bool_until_do:Nn \l_@@_typeset_last_bool
      {
        \seq_pop_left:NN \l_@@_typeset_labels_seq
          \l_@@_label_a_tl
        \seq_if_empty:NTF \l_@@_typeset_labels_seq
          {
            \tl_clear:N \l_@@_label_b_tl
            \bool_set_true:N \l_@@_typeset_last_bool
          }
          {
            \seq_get_left:NN \l_@@_typeset_labels_seq
              \l_@@_label_b_tl
          }

        \tl_if_eq:NnTF \l_@@_ref_property_tl { page }
          {
            \tl_set:Nn \l_@@_label_type_a_tl { page }
            \tl_set:Nn \l_@@_label_type_b_tl { page }
          }
          {
            \tl_set:Nx \l_@@_label_type_a_tl
              {
                \zref@extractdefault
                  { \l_@@_label_a_tl } { zc@type } { \c_empty_tl }
              }
            \tl_set:Nx \l_@@_label_type_b_tl
              {
                \zref@extractdefault
                  { \l_@@_label_b_tl } { zc@type } { \c_empty_tl }
              }
          }

        % First, we establish whether the "current label" (i.e. `a') is the
        % last one of its type.  This can happen because the "next label"
        % (i.e. `b') is of a different type (or different definition status),
        % or because we are at the end of the list.
        \bool_if:NTF \l_@@_typeset_last_bool
          { \bool_set_true:N \l_@@_last_of_type_bool }
          {
            \zref@ifrefundefined { \l_@@_label_a_tl }
              {
                \zref@ifrefundefined { \l_@@_label_b_tl }
                  { \bool_set_false:N \l_@@_last_of_type_bool }
                  { \bool_set_true:N \l_@@_last_of_type_bool  }
              }
              {
                \zref@ifrefundefined { \l_@@_label_b_tl }
                  { \bool_set_true:N \l_@@_last_of_type_bool }
                  {
                    % Neither is undefined, we must check the types.
                    \bool_if:nTF
                      {
                        % Both empty: same "type".
                        \tl_if_empty_p:N \l_@@_label_type_a_tl &&
                        \tl_if_empty_p:N \l_@@_label_type_b_tl
                      }
                      { \bool_set_false:N \l_@@_last_of_type_bool }
                      {
                        \bool_if:nTF
                          {
                            % Neither empty: compare types.
                            ! \tl_if_empty_p:N \l_@@_label_type_a_tl
                            &&
                            ! \tl_if_empty_p:N \l_@@_label_type_b_tl
                          }
                          {
                            \tl_if_eq:NNTF
                              \l_@@_label_type_a_tl
                              \l_@@_label_type_b_tl
                              {
                                \bool_set_false:N
                                  \l_@@_last_of_type_bool
                              }
                              {
                                \bool_set_true:N
                                  \l_@@_last_of_type_bool
                              }
                          }
                          % One empty, the other not: different "types".
                          {
                            \bool_set_true:N
                              \l_@@_last_of_type_bool
                          }
                      }
                  }
              }
          }

        % Handle warnings in case of reference or type undefined.
        \zref@refused { \l_@@_label_a_tl }
        \zref@ifrefundefined { \l_@@_label_a_tl }
          {}
          {
            \tl_if_empty:NT \l_@@_label_type_a_tl
              {
                \msg_warning:nnx { zref-clever } { missing-type }
                  { \l_@@_label_a_tl }
              }
          }

        % Get type-specific separators, refpre/pos and font options, once per
        % type.
        \int_compare:nNnT { \l_@@_label_count_int } = { 0 }
          {
            \@@_get_ref_string:nN { namesep    }
              \l_@@_namesep_tl
            \@@_get_ref_string:nN { rangesep   }
              \l_@@_rangesep_tl
            \@@_get_ref_string:nN { pairsep    }
              \l_@@_pairsep_tl
            \@@_get_ref_string:nN { listsep    }
              \l_@@_listsep_tl
            \@@_get_ref_string:nN { lastsep    }
              \l_@@_lastsep_tl
            \@@_get_ref_string:nN { refpre     }
              \l_@@_refpre_out_tl
            \@@_get_ref_string:nN { refpos     }
              \l_@@_refpos_out_tl
            \@@_get_ref_string:nN { refpre-in  }
              \l_@@_refpre_in_tl
            \@@_get_ref_string:nN { refpos-in  }
              \l_@@_refpos_in_tl
            \@@_get_ref_font:nN   { namefont   }
              \l_@@_namefont_tl
            \@@_get_ref_font:nN   { reffont    }
              \l_@@_reffont_out_tl
            \@@_get_ref_font:nN   { reffont-in }
              \l_@@_reffont_in_tl
          }

        % Here we send this to a couple of auxiliary functions.
        \bool_if:NTF \l_@@_last_of_type_bool
          % There exists no next label of the same type as the current.
          { \@@_typeset_refs_last_of_type: }
          % There exists a next label of the same type as the current.
          { \@@_typeset_refs_not_last_of_type: }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% This is actually the one meaningful ``big branching'' we can do while
% processing the label stack: i) the ``current'' label is the last of its type
% block; or ii) the ``current'' label is \emph{not} the last of its type
% block.  Indeed, as mentioned above, quite a number of things can only be
% decided when the type block ends, and we only know this when we look at the
% ``next'' label and find something of a different ``type'' (loose here, maybe
% different definition status, maybe end of stack).  So, though this is not
% very strict, \cs{@@_typeset_refs_last_of_type:} is more of a ``wrapping
% up'' function, and it is indeed the one which does the actual typesetting,
% while \cs{@@_typeset_refs_not_last_of_type:} is more of an
% ``accumulation'' function.
%
%
% \begin{macro}{\@@_typeset_refs_last_of_type:}
%   Handles typesetting when the current label is the last of its type.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_refs_last_of_type:
  {
    % Process the current label to the current queue.
    \int_case:nnF { \l_@@_label_count_int }
      {
        % It is the last label of its type, but also the first one, and that's
        % what matters here: just store it.
        { 0 }
        {
          \tl_set:NV \l_@@_type_first_label_tl
            \l_@@_label_a_tl
          \tl_set:NV \l_@@_type_first_label_type_tl
            \l_@@_label_type_a_tl
        }

        % The last is the second: we have a pair (if not repeated).
        { 1 }
        {
          \int_compare:nNnF { \l_@@_range_same_count_int } = { 1 }
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  \exp_not:V \l_@@_pairsep_tl
                  \@@_get_ref:V \l_@@_label_a_tl
                }
            }
        }
      }
      % Last is third or more of its type: without repetition, we'd have the
      % last element on a list, but control for possible repetition.
      {
        \int_case:nnF { \l_@@_range_count_int }
          {
            % There was no range going on.
            { 0 }
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  \exp_not:V \l_@@_lastsep_tl
                  \@@_get_ref:V \l_@@_label_a_tl
                }
            }
            % Last in the range is also the second in it.
            { 1 }
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  % We know `range_beg_label' is not empty, since this is the
                  % second element in the range, but the third or more in the
                  % type list.
                  \exp_not:V \l_@@_listsep_tl
                  \@@_get_ref:V \l_@@_range_beg_label_tl
                  \int_compare:nNnF
                    { \l_@@_range_same_count_int } = { 1 }
                    {
                      \exp_not:V \l_@@_lastsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
            }
          }
          % Last in the range is third or more in it.
          {
            \int_case:nnF
              {
                \l_@@_range_count_int -
                \l_@@_range_same_count_int
              }
              {
                % Repetition, not a range.
                { 0 }
                {
                  % If `range_beg_label' is empty, it means it was also the
                  % first of the type, and hence was already handled.
                  \tl_if_empty:VF \l_@@_range_beg_label_tl
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \exp_not:V \l_@@_lastsep_tl
                          \@@_get_ref:V
                            \l_@@_range_beg_label_tl
                        }
                    }
                }
                % A `range', but with no skipped value, treat as list.
                { 1 }
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      % Ditto.
                      \tl_if_empty:VF \l_@@_range_beg_label_tl
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V
                            \l_@@_range_beg_label_tl
                        }
                      \exp_not:V \l_@@_lastsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
              }
              {
                % An actual range.
                \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                  {
                    % Ditto.
                    \tl_if_empty:VF \l_@@_range_beg_label_tl
                      {
                        \exp_not:V \l_@@_lastsep_tl
                        \@@_get_ref:V
                          \l_@@_range_beg_label_tl
                      }
                    \exp_not:V \l_@@_rangesep_tl
                    \@@_get_ref:V \l_@@_label_a_tl
                  }
              }
          }
      }

    % Handle "range" option.  The idea is simple: if the queue is not empty,
    % we replace it with the end of the range (or pair).  We can still
    % retrieve the end of the range from `label_a' since we know to be
    % processing the last label of its type at this point.
    \bool_if:NT \l_@@_typeset_range_bool
      {
        \tl_if_empty:NTF \l_@@_typeset_queue_curr_tl
          {
            \zref@ifrefundefined { \l_@@_type_first_label_tl }
              { }
              {
                \msg_warning:nnx { zref-clever } { single-element-range }
                  { \l_@@_type_first_label_type_tl }
              }
          }
          {
            \bool_set_false:N \l_@@_next_maybe_range_bool
            \zref@ifrefundefined { \l_@@_type_first_label_tl }
              { }
              {
                \@@_labels_in_sequence:nn
                  { \l_@@_type_first_label_tl }
                  { \l_@@_label_a_tl }
              }
            \tl_set:Nx \l_@@_typeset_queue_curr_tl
              {
                \bool_if:NTF \l_@@_next_maybe_range_bool
                  { \exp_not:V \l_@@_pairsep_tl }
                  { \exp_not:V \l_@@_rangesep_tl }
                \@@_get_ref:V \l_@@_label_a_tl
              }
          }
      }

    % Now that the type block is finished, we can add the name and the first
    % ref to the queue.  Also, if "typeset" option is not "both", handle it
    % here as well.
    \@@_type_name_setup:
    \bool_if:nTF
      { \l_@@_typeset_ref_bool && \l_@@_typeset_name_bool }
      {
        \tl_put_left:Nx \l_@@_typeset_queue_curr_tl
          { \@@_get_ref_first: }
      }
      {
        \bool_if:nTF
          { \l_@@_typeset_ref_bool }
          {
            \tl_put_left:Nx \l_@@_typeset_queue_curr_tl
              { \@@_get_ref:V \l_@@_type_first_label_tl }
          }
          {
            \bool_if:nTF
              { \l_@@_typeset_name_bool }
              {
                \tl_set:Nx \l_@@_typeset_queue_curr_tl
                  {
                    \bool_if:NTF \l_@@_name_in_link_bool
                      {
                        \exp_not:N \group_begin:
                        \exp_not:V \l_@@_namefont_tl
                        % It's two '@s', but escaped for DocStrip.
                        \exp_not:N \hyper@@@@link
                          {
                            \zref@ifrefcontainsprop
                              { \l_@@_type_first_label_tl }
                              { urluse }
                              {
                                \zref@extractdefault
                                  { \l_@@_type_first_label_tl }
                                  { urluse } {}
                              }
                              {
                                \zref@extractdefault
                                  { \l_@@_type_first_label_tl }
                                  { url } {}
                              }
                          }
                          {
                            \zref@extractdefault
                              { \l_@@_type_first_label_tl }
                              { anchor } {}
                          }
                          { \exp_not:V \l_@@_type_name_tl }
                        \exp_not:N \group_end:
                      }
                      {
                        \exp_not:N \group_begin:
                        \exp_not:V \l_@@_namefont_tl
                        \exp_not:V \l_@@_type_name_tl
                        \exp_not:N \group_end:
                      }
                  }
              }
              {
                % Logically, this case would correspond to "typeset=none", but
                % it should not occur, given that the options are set up to
                % typeset either "ref" or "name".  Still, leave here a
                % sensible fallback, equal to the behavior of "both".
                \tl_put_left:Nx \l_@@_typeset_queue_curr_tl
                  { \@@_get_ref_first: }
              }
          }
      }

    % Typeset the previous type, if there is one.
    \int_compare:nNnT { \l_@@_type_count_int } > { 0 }
      {
        \int_compare:nNnT { \l_@@_type_count_int } > { 1 }
          { \l_@@_tlistsep_tl }
        \l_@@_typeset_queue_prev_tl
      }

    % Wrap up loop, or prepare for next iteration.
    \bool_if:NTF \l_@@_typeset_last_bool
      {
        % We are finishing, typeset the current queue.
        \int_case:nnF { \l_@@_type_count_int }
          {
            % Single type.
            { 0 }
            { \l_@@_typeset_queue_curr_tl }
            % Pair of types.
            { 1 }
            {
              \l_@@_tpairsep_tl
              \l_@@_typeset_queue_curr_tl
            }
          }
          {
            % Last in list of types.
            \l_@@_tlastsep_tl
            \l_@@_typeset_queue_curr_tl
          }
      }
      {
        % There are further labels, set variables for next iteration.
        \tl_set_eq:NN \l_@@_typeset_queue_prev_tl
          \l_@@_typeset_queue_curr_tl
        \tl_clear:N \l_@@_typeset_queue_curr_tl
        \tl_clear:N \l_@@_type_first_label_tl
        \tl_clear:N \l_@@_type_first_label_type_tl
        \tl_clear:N \l_@@_range_beg_label_tl
        \int_zero:N \l_@@_label_count_int
        \int_incr:N \l_@@_type_count_int
        \int_zero:N \l_@@_range_count_int
        \int_zero:N \l_@@_range_same_count_int
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_typeset_refs_not_last_of_type:}
%   Handles typesetting when the current label is not the last of its type.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_typeset_refs_not_last_of_type:
  {
    % Signal if next label may form a range with the current one (only
    % considered if compression is enabled in the first place).
    \bool_set_false:N \l_@@_next_maybe_range_bool
    \bool_set_false:N \l_@@_next_is_same_bool
    \bool_if:NT \l_@@_typeset_compress_bool
      {
        \zref@ifrefundefined { \l_@@_label_a_tl }
          { }
          {
            \@@_labels_in_sequence:nn
              { \l_@@_label_a_tl } { \l_@@_label_b_tl }
          }
      }

    % Process the current label to the current queue.
    \int_compare:nNnTF { \l_@@_label_count_int } = { 0 }
      {
        % Current label is the first of its type (also not the last, but it
        % doesn't matter here): just store the label.
        \tl_set:NV \l_@@_type_first_label_tl
          \l_@@_label_a_tl
        \tl_set:NV \l_@@_type_first_label_type_tl
          \l_@@_label_type_a_tl

        % If the next label may be part of a range, we set `range_beg_label'
        % to "empty" (we deal with it as the "first", and must do it there, to
        % handle hyperlinking), but also step the range counters.
        \bool_if:NT \l_@@_next_maybe_range_bool
          {
            \tl_clear:N \l_@@_range_beg_label_tl
            \int_incr:N \l_@@_range_count_int
            \bool_if:NT \l_@@_next_is_same_bool
              { \int_incr:N \l_@@_range_same_count_int }
         }
      }
      {
        % Current label is neither the first (nor the last) of its type.
        \bool_if:NTF \l_@@_next_maybe_range_bool
          {
            % Starting, or continuing a range.
            \int_compare:nNnTF
              { \l_@@_range_count_int } = { 0 }
              {
                % There was no range going, we are starting one.
                \tl_set:NV \l_@@_range_beg_label_tl
                  \l_@@_label_a_tl
                \int_incr:N \l_@@_range_count_int
                \bool_if:NT \l_@@_next_is_same_bool
                  { \int_incr:N \l_@@_range_same_count_int }
              }
              {
                % Second or more in the range, but not the last.
                \int_incr:N \l_@@_range_count_int
                \bool_if:NT \l_@@_next_is_same_bool
                  { \int_incr:N \l_@@_range_same_count_int }
              }
          }
          {
            % Next element is not in sequence: there was no range, or we are
            % closing one.
            \int_case:nnF { \l_@@_range_count_int }
              {
                % There was no range going on.
                { 0 }
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      \exp_not:V \l_@@_listsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
                % Last is second in the range: if `range_same_count' is also
                % `1', it's a repetition (drop it), otherwise, it's a "pair
                % within a list", treat as list.
                { 1 }
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      \tl_if_empty:VF \l_@@_range_beg_label_tl
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V
                            \l_@@_range_beg_label_tl
                        }
                      \int_compare:nNnF
                        { \l_@@_range_same_count_int } = { 1 }
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V
                            \l_@@_label_a_tl
                        }
                    }
                }
              }
              {
                % Last is third or more in the range: if `range_count' and
                % `range_same_count' are the same, its a repetition (drop it),
                % if they differ by `1', its a list, if they differ by more,
                % it is a real range.
                \int_case:nnF
                  {
                    \l_@@_range_count_int -
                    \l_@@_range_same_count_int
                  }
                  {
                    { 0 }
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \tl_if_empty:VF \l_@@_range_beg_label_tl
                            {
                              \exp_not:V \l_@@_listsep_tl
                              \@@_get_ref:V
                                \l_@@_range_beg_label_tl
                            }
                        }
                    }
                    { 1 }
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \tl_if_empty:VF \l_@@_range_beg_label_tl
                            {
                              \exp_not:V \l_@@_listsep_tl
                              \@@_get_ref:V
                                \l_@@_range_beg_label_tl
                            }
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_label_a_tl
                        }
                    }
                  }
                  {
                    \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                      {
                        \tl_if_empty:VF \l_@@_range_beg_label_tl
                          {
                            \exp_not:V \l_@@_listsep_tl
                            \@@_get_ref:V
                              \l_@@_range_beg_label_tl
                          }
                        \exp_not:V \l_@@_rangesep_tl
                        \@@_get_ref:V \l_@@_label_a_tl
                      }
                  }
              }
            % Reset counters.
            \int_zero:N \l_@@_range_count_int
            \int_zero:N \l_@@_range_same_count_int
          }
      }
    % Step label counter for next iteration.
    \int_incr:N \l_@@_label_count_int
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection*{Aux functions}
%
% \cs{@@_get_ref:n} and \cs{@@_get_ref_first:} are the two functions which
% actually build the reference blocks for typesetting.  \cs{@@_get_ref:n}
% handles all references but the first of its type, and \cs{@@_get_ref_first:}
% deals with the first reference of a type.  Saying they do ``typesetting'' is
% imprecise though, they actually prepare material to be accumulated in
% \cs{l_@@_typeset_queue_curr_tl} inside \cs{@@_typeset_refs_last_of_type:}
% and \cs{@@_typeset_refs_not_last_of_type:}.  And this difference results
% quite crucial for the \TeX{}nical requirements of these functions.  This
% because, as we are processing the label stack and accumulating content in
% the queue, we are using a number of variables which are transient to the
% current label, the label properties among them, but not only.  Hence, these
% variables \emph{must} be expanded to their current values to be stored in
% the queue.  Indeed, \cs{@@_get_ref:n} and \cs{@@_get_ref_first:} get called,
% as they must, in the context of \texttt{x} type expansions.  But we don't
% want to expand the values of the variables themselves, so we need to get
% current values, but stop expansion after that.  In particular, reference
% options given by the user should reach the stream for its final typesetting
% (when the queue itself gets typeset) \emph{unmodified} (``no manipulation'',
% to use the \texttt{n} signature jargon).  We also need to prevent premature
% expansion of material that can't be expanded at this point (e.g. grouping,
% \cs{zref@default} or \cs{hyper@@@@link}).  In a nutshell, the job of these
% two functions is putting the pieces in place, but with proper expansion
% control.
%
%
% \begin{macro}{\@@_ref_default:, \@@_name_default:}
%   Default values for undefined references and undefined type names,
%   respectively.  We are ultimately using \cs{zref@default}, but calls to it
%   should be made through these internal functions, according to the case.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_ref_default:
  { \zref@default }
\cs_new_protected:Npn \@@_name_default:
  { \zref@default }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_get_ref:n}
%   Handles a complete reference block to be accumulated in the ``queue'',
%   including ``pre'' and ``pos'' elements, and hyperlinking.  For use with
%   all labels, except the first of its type, which is done by
%   \cs{@@_get_ref_first:}.
%   \begin{syntax}
%     \cs{@@_get_ref:n} \Arg{label}
%   \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \@@_get_ref:n #1
  {
    \zref@ifrefcontainsprop {#1} { \l_@@_ref_property_tl }
      {
        \bool_if:nTF
          {
            \l_@@_use_hyperref_bool &&
            ! \l_@@_link_star_bool
          }
          {
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_out_tl
            \exp_not:V \l_@@_refpre_out_tl
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_in_tl
            % It's two `@s', but escaped for DocStrip.
            \exp_not:N \hyper@@@@link
              {
                \zref@ifrefcontainsprop {#1} { urluse }
                  { \zref@extractdefault {#1} { urluse } { } }
                  { \zref@extractdefault {#1} { url } { } }
              }
              { \zref@extractdefault {#1} { anchor } { } }
              {
                \exp_not:V \l_@@_refpre_in_tl
                \zref@extractdefault {#1}
                  { \l_@@_ref_property_tl } { }
                \exp_not:V \l_@@_refpos_in_tl
              }
            \exp_not:N \group_end:
            \exp_not:V \l_@@_refpos_out_tl
            \exp_not:N \group_end:
          }
          {
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_out_tl
            \exp_not:V \l_@@_refpre_out_tl
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_reffont_in_tl
            \exp_not:V \l_@@_refpre_in_tl
            \zref@extractdefault {#1} { \l_@@_ref_property_tl } { }
            \exp_not:V \l_@@_refpos_in_tl
            \exp_not:N \group_end:
            \exp_not:V \l_@@_refpos_out_tl
            \exp_not:N \group_end:
          }
      }
      { \exp_not:N \@@_ref_default: }
  }
\cs_generate_variant:Nn \@@_get_ref:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_get_ref_first:}
%   Handles a complete reference block for the first label of its type to be
%   accumulated in the ``queue'', including ``pre'' and ``pos'' elements,
%   hyperlinking, and the reference type ``name''.  It does not receive
%   arguments, but relies on being called in the appropriate place in
%   \cs{@@_typeset_refs_last_of_type:} where a number of variables are
%   expected to be appropriately set for it to consume.  Prominently among
%   those is \cs{l_@@_type_first_label_tl}, but it also expected to be called
%   right after \cs{@@_type_name_setup:} which sets \cs{l_@@_type_name_tl} and
%   \cs{l_@@_name_in_link_bool} which it uses.
%    \begin{macrocode}
\cs_new:Npn \@@_get_ref_first:
  {
    \zref@ifrefundefined { \l_@@_type_first_label_tl }
      { \exp_not:N \@@_ref_default: }
      {
        \bool_if:NTF \l_@@_name_in_link_bool
          {
            \zref@ifrefcontainsprop
              { \l_@@_type_first_label_tl }
              { \l_@@_ref_property_tl }
              {
                % It's two `@s', but escaped for DocStrip.
                \exp_not:N \hyper@@@@link
                  {
                    \zref@ifrefcontainsprop
                      { \l_@@_type_first_label_tl } { urluse }
                      {
                        \zref@extractdefault
                          { \l_@@_type_first_label_tl }
                          { urluse } { }
                      }
                      {
                        \zref@extractdefault
                          { \l_@@_type_first_label_tl }
                          { url } { }
                      }
                  }
                  {
                    \zref@extractdefault
                      { \l_@@_type_first_label_tl }
                      { anchor } { }
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_namefont_tl
                    \exp_not:V \l_@@_type_name_tl
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_namesep_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_out_tl
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_in_tl
                    \exp_not:V \l_@@_refpre_in_tl
                    \zref@extractdefault
                      { \l_@@_type_first_label_tl }
                      { \l_@@_ref_property_tl } { }
                    \exp_not:V \l_@@_refpos_in_tl
                    \exp_not:N \group_end:
                    % hyperlink makes it's own group, we'd like to close the
                    % `refpre-out' group after `refpos-out', but... we close
                    % it here, and give the trailing `refpos-out' its own
                    % group.  This will result that formatting given to
                    % `refpre-out' will not reach `refpos-out', but I see no
                    % alternative, and this has to be handled specially.
                    \exp_not:N \group_end:
                  }
                \exp_not:N \group_begin:
                % Ditto: special treatment.
                \exp_not:V \l_@@_reffont_out_tl
                \exp_not:V \l_@@_refpos_out_tl
                \exp_not:N \group_end:
              }
              {
                \exp_not:N \group_begin:
                \exp_not:V \l_@@_namefont_tl
                \exp_not:V \l_@@_type_name_tl
                \exp_not:N \group_end:
                \exp_not:V \l_@@_namesep_tl
                \exp_not:N \@@_ref_default:
              }
          }
          {
            \tl_if_empty:NTF \l_@@_type_name_tl
              {
                \exp_not:N \@@_name_default:
                \exp_not:V \l_@@_namesep_tl
              }
              {
                \exp_not:N \group_begin:
                \exp_not:V \l_@@_namefont_tl
                \exp_not:V \l_@@_type_name_tl
                \exp_not:N \group_end:
                \exp_not:V \l_@@_namesep_tl
              }
            \zref@ifrefcontainsprop
              { \l_@@_type_first_label_tl }
              { \l_@@_ref_property_tl }
              {
                \bool_if:nTF
                  {
                    \l_@@_use_hyperref_bool &&
                    ! \l_@@_link_star_bool
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_out_tl
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_in_tl
                    % It's two '@s', but escaped for DocStrip.
                    \exp_not:N \hyper@@@@link
                      {
                        \zref@ifrefcontainsprop
                          { \l_@@_type_first_label_tl } { urluse }
                          {
                            \zref@extractdefault
                              { \l_@@_type_first_label_tl }
                              { urluse } { }
                          }
                          {
                            \zref@extractdefault
                              { \l_@@_type_first_label_tl }
                              { url } { }
                          }
                      }
                      {
                        \zref@extractdefault
                          { \l_@@_type_first_label_tl }
                          { anchor } { }
                      }
                      {
                        \exp_not:V \l_@@_refpre_in_tl
                        \zref@extractdefault
                          { \l_@@_type_first_label_tl }
                          { \l_@@_ref_property_tl } { }
                        \exp_not:V \l_@@_refpos_in_tl
                      }
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_refpos_out_tl
                    \exp_not:N \group_end:
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_out_tl
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_reffont_in_tl
                    \exp_not:V \l_@@_refpre_in_tl
                    \zref@extractdefault
                      { \l_@@_type_first_label_tl }
                      { \l_@@_ref_property_tl } { }
                    \exp_not:V \l_@@_refpos_in_tl
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_refpos_out_tl
                    \exp_not:N \group_end:
                  }
              }
              { \exp_not:N \@@_ref_default: }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_type_name_setup:}
%   Auxiliary function to \cs{@@_typeset_refs_last_of_type:}.  It is
%   responsible for setting the type name variable \cs{l_@@_type_name_tl} and
%   \cs{l_@@_name_in_link_bool}.  If a type name can't be found,
%   \cs{l_@@_type_name_tl} is cleared.  The function takes no arguments, but
%   is expected to be called in \cs{@@_typeset_refs_last_of_type:} right
%   before \cs{@@_get_ref_first:}, which is the main consumer of the variables
%   it sets, though not the only one (and hence this cannot be moved into
%   \cs{@@_get_ref_first:} itself).  It also expects a number of relevant
%   variables to have been appropriately set, and which it uses, prominently
%   \cs{l_@@_type_first_label_type_tl}, but also the queue itself in
%   \cs{l_@@_typeset_queue_curr_tl}, which should be ``ready except for the
%   first label'', and the type counter \cs{l_@@_type_count_int}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_type_name_setup:
  {
    \zref@ifrefundefined { \l_@@_type_first_label_tl }
      { \tl_clear:N \l_@@_type_name_tl }
      {
        \tl_if_empty:nTF \l_@@_type_first_label_type_tl
          { \tl_clear:N \l_@@_type_name_tl }
          {
            % Determine whether we should use capitalization, abbreviation,
            % and plural.
            \bool_lazy_or:nnTF
              { \l_@@_capitalize_bool }
              {
                \l_@@_capitalize_first_bool &&
                \int_compare_p:nNn { \l_@@_type_count_int } = { 0 }
              }
              { \tl_set:Nn \l_@@_name_format_tl {Name} }
              { \tl_set:Nn \l_@@_name_format_tl {name} }
            % If the queue is empty, we have a singular, otherwise, plural.
            \tl_if_empty:NTF \l_@@_typeset_queue_curr_tl
              { \tl_put_right:Nn \l_@@_name_format_tl { -sg } }
              { \tl_put_right:Nn \l_@@_name_format_tl { -pl } }
            \bool_lazy_and:nnTF
              { \l_@@_abbrev_bool }
              {
                ! \int_compare_p:nNn
                    { \l_@@_type_count_int } = { 0 } ||
                ! \l_@@_noabbrev_first_bool
              }
              {
                \tl_set:NV \l_@@_name_format_fallback_tl
                  \l_@@_name_format_tl
                \tl_put_right:Nn \l_@@_name_format_tl { -ab }
              }
              { \tl_clear:N \l_@@_name_format_fallback_tl }

            \tl_if_empty:NTF \l_@@_name_format_fallback_tl
              {
                \prop_get:cVNF
                  {
                    l_@@_type_
                    \l_@@_type_first_label_type_tl _options_prop
                  }
                  \l_@@_name_format_tl
                  \l_@@_type_name_tl
                  {
                    \@@_get_type_transl:xxxNF
                      { \l_@@_ref_language_tl }
                      { \l_@@_type_first_label_type_tl }
                      { \l_@@_name_format_tl }
                      \l_@@_type_name_tl
                      {
                        \tl_clear:N \l_@@_type_name_tl
                        \msg_warning:nnx { zref-clever } { missing-name }
                          { \l_@@_type_first_label_type_tl }
                      }
                  }
              }
              {
                \prop_get:cVNF
                  {
                    l_@@_type_
                    \l_@@_type_first_label_type_tl _options_prop
                  }
                  \l_@@_name_format_tl
                  \l_@@_type_name_tl
                  {
                    \prop_get:cVNF
                      {
                        l_@@_type_
                        \l_@@_type_first_label_type_tl _options_prop
                      }
                      \l_@@_name_format_fallback_tl
                      \l_@@_type_name_tl
                      {
                        \@@_get_type_transl:xxxNF
                          { \l_@@_ref_language_tl }
                          { \l_@@_type_first_label_type_tl }
                          { \l_@@_name_format_tl }
                          \l_@@_type_name_tl
                          {
                            \@@_get_type_transl:xxxNF
                              { \l_@@_ref_language_tl }
                              { \l_@@_type_first_label_type_tl }
                              { \l_@@_name_format_fallback_tl }
                              \l_@@_type_name_tl
                              {
                                \tl_clear:N \l_@@_type_name_tl
                                \msg_warning:nnx { zref-clever }
                                  { missing-name }
                                  { \l_@@_type_first_label_type_tl }
                              }
                          }
                      }
                  }
              }
          }
      }

    % Signal whether the type name is to be included in the hyperlink or not.
    \bool_lazy_any:nTF
      {
        { ! \l_@@_use_hyperref_bool }
        { \l_@@_link_star_bool }
        { \tl_if_empty_p:N \l_@@_type_name_tl }
        { \str_if_eq_p:Vn \l_@@_nameinlink_str { false } }
      }
      { \bool_set_false:N \l_@@_name_in_link_bool }
      {
        \bool_lazy_any:nTF
          {
            { \str_if_eq_p:Vn \l_@@_nameinlink_str { true } }
            {
              \str_if_eq_p:Vn \l_@@_nameinlink_str { tsingle } &&
              \tl_if_empty_p:N \l_@@_typeset_queue_curr_tl
            }
            {
              \str_if_eq_p:Vn \l_@@_nameinlink_str { single } &&
              \tl_if_empty_p:N \l_@@_typeset_queue_curr_tl &&
              \l_@@_typeset_last_bool &&
              \int_compare_p:nNn { \l_@@_type_count_int } = { 0 }
            }
          }
          { \bool_set_true:N \l_@@_name_in_link_bool }
          { \bool_set_false:N \l_@@_name_in_link_bool }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\@@_labels_in_sequence:nn}
%   Auxiliary function to \cs{@@_typeset_refs_not_last_of_type:}. Sets
%   \cs{l_@@_next_maybe_range_bool} to true if \meta{label b} comes in
%   immediate sequence from \meta{label a}.  And sets both
%   \cs{l_@@_next_maybe_range_bool} and \cs{l_@@_next_is_same_bool} to true if
%   the two labels are the ``same'' (that is, have the same counter value).
%   These two boolean variables are the basis for all range and compression
%   handling inside \cs{@@_typeset_refs_not_last_of_type:}, so this function
%   is expected to be called at its beginning, if compression is enabled.
%   \begin{syntax}
%     \cs{@@_labels_in_sequence:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_labels_in_sequence:nn #1#2
  {
    \tl_if_eq:NnTF \l_@@_ref_property_tl { page }
      {
        \exp_args:Nxx \tl_if_eq:nnT
          { \zref@extractdefault {#1} { zc@pgfmt } { } }
          { \zref@extractdefault {#2} { zc@pgfmt } { } }
          {
            \int_compare:nNnTF
              { \zref@extractdefault {#1} { zc@pgval } { -2 } + 1 }
                =
              { \zref@extractdefault {#2} { zc@pgval } { -1 } }
              { \bool_set_true:N \l_@@_next_maybe_range_bool }
              {
                \int_compare:nNnT
                  { \zref@extractdefault {#1} { zc@pgval } { -1 } }
                    =
                  { \zref@extractdefault {#2} { zc@pgval } { -1 } }
                  {
                    \bool_set_true:N \l_@@_next_maybe_range_bool
                    \bool_set_true:N \l_@@_next_is_same_bool
                  }
              }
          }
      }
      {
        \exp_args:Nxx \tl_if_eq:nnT
          { \zref@extractdefault {#1} { counter } { } }
          { \zref@extractdefault {#2} { counter } { } }
          {
            \exp_args:Nxx \tl_if_eq:nnT
              { \zref@extractdefault {#1} { zc@enclval } { } }
              { \zref@extractdefault {#2} { zc@enclval } { } }
              {
                \int_compare:nNnTF
                  { \zref@extractdefault {#1} { zc@cntval } { -2 } + 1 }
                    =
                  { \zref@extractdefault {#2} { zc@cntval } { -1 } }
                  { \bool_set_true:N \l_@@_next_maybe_range_bool }
                  {
                    \int_compare:nNnT
                      { \zref@extractdefault {#1} { zc@cntval } { -1 } }
                        =
                      { \zref@extractdefault {#2} { zc@cntval } { -1 } }
                      {
                        \bool_set_true:N \l_@@_next_maybe_range_bool
                        \bool_set_true:N \l_@@_next_is_same_bool
                      }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% Finally, a couple of functions for retrieving options values, according to
% the relevant precedence rules (see Section~\ref{sec:reference-format}).
% They both receive an \meta{option} as argument, and store the retrieved
% value in \meta{tl variable}.  Though these are mostly general functions (for
% a change\dots{}), they are not completely so, they rely on the current state
% of \cs{l_@@_label_type_a_tl}, as set during the processing of the label
% stack.  This could be easily generalized, of course, but I don't think it is
% worth it, \cs{l_@@_label_type_a_tl} is indeed what we want in all practical
% cases.  The difference between \cs{@@_get_ref_string:nN} and
% \cs{@@_get_ref_font:nN} is the kind of option each should be used for.
% \cs{@@_get_ref_string:nN} is meant for the general options, and attempts to
% find values for them in all precedence levels (four plus ``fallback'').
% \cs{@@_get_ref_font:nN} is intended for ``font'' options, which cannot be
% ``language-specific'', thus for these we just search general options and
% type options.
%
% \begin{macro}{\@@_get_ref_string:nN}
%   \begin{syntax}
%     \cs{@@_get_ref_string:nN} \Arg{option} \Arg{tl variable}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_ref_string:nN #1#2
  {
    % First attempt: general options.
    \prop_get:NnNF \l_@@_ref_options_prop {#1} #2
      {
        % If not found, try type specific options.
        \bool_lazy_all:nTF
          {
            { ! \tl_if_empty_p:N \l_@@_label_type_a_tl }
            {
              \prop_if_exist_p:c
                {
                  l_@@_type_
                  \l_@@_label_type_a_tl _options_prop
                }
            }
            {
              \prop_if_in_p:cn
                {
                  l_@@_type_
                  \l_@@_label_type_a_tl _options_prop
                }
                {#1}
            }
          }
          {
            \prop_get:cnN
              {
                l_@@_type_
                \l_@@_label_type_a_tl _options_prop
              }
              {#1} #2
          }
          {
            % If not found, try type specific translations.
            \@@_get_type_transl:xxnNF
              { \l_@@_ref_language_tl }
              { \l_@@_label_type_a_tl }
              {#1} #2
              {
                % If not found, try default translations.
                \@@_get_default_transl:xnNF
                  { \l_@@_ref_language_tl }
                  {#1} #2
                  {
                    % If not found, try fallback.
                    \@@_get_fallback_transl:nNF {#1} #2
                      {
                        \tl_clear:N #2
                        \msg_warning:nnn { zref-clever }
                          { missing-string } {#1}
                      }
                  }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_get_ref_font:nN}
%   \begin{syntax}
%     \cs{@@_get_ref_font:nN} \Arg{option} \Arg{tl variable}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_get_ref_font:nN #1#2
  {
    % First attempt: general options.
    \prop_get:NnNF \l_@@_ref_options_prop {#1} #2
      {
        % If not found, try type specific options.
        \bool_lazy_and:nnTF
          { ! \tl_if_empty_p:N \l_@@_label_type_a_tl }
          {
            \prop_if_exist_p:c
              {
                l_@@_type_
                \l_@@_label_type_a_tl _options_prop
              }
          }
          {
            \prop_get:cnNF
              {
                l_@@_type_
                \l_@@_label_type_a_tl _options_prop
              }
              {#1} #2
              { \tl_clear:N #2 }
          }
          { \tl_clear:N #2 }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Special handling}
%
% This section is meant to aggregate any ``special handling'' needed for
% \LaTeX{} kernel features, document classes, and packages, needed for
% \pkg{zref-clever} to work properly with them.  It is not meant to be a
% ``kitchen sink of workarounds''.  Rather, I intend to keep this as lean as
% possible, trying to add things selectively when they are safe and
% reasonable.  And, hopefully, doing so by proper setting of
% \pkg{zref-clever}'s options, not by messing with other packages' code.  In
% particular, I do not mean to compensate for ``lack of support for
% \pkg{zref}'' by individual packages here, unless there is really no
% alternative.
%
%
% \subsection{\cs{appendix}}
%
%
% Another relevant use case of the same general problem of different types for
% the same counter is the \cs{appendix} which in some document classes,
% including the standard ones, change the sectioning commands looks but, of
% course, keep using the same counter (\file{book.cls} and \file{report.cls}
% reset counters \texttt{chapter} and \texttt{section} to 0, change
% \cs{@chapapp} to use \cs{appendixname} and use \cs{@Alph} for
% \cs{thechapter}; \file{article.cls} resets counters \texttt{section} and
% \texttt{subsection} to 0, and uses \cs{@Alph} for \cs{thesection};
% \file{memoir.cls}, \file{scrbook.cls} and \file{scrarticle.cls} do the same
% as their corresponding standard classes, and sometimes a little more, but
% what interests us here is pretty much the same; see also the \pkg{appendix}
% package).
%
%
%
% \subsection{\pkg{enumitem} package}
%
% TODO Option \opt{counterresetby} should probably be extended for
% \pkg{enumitem}, conditioned on it being loaded.
%
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%
%
% \section{Dictionaries}
%
% \subsection{English}
%
%    \begin{macrocode}
%<package>\zcDeclareLanguage { english }
%<package>\zcDeclareLanguageAlias { american   } { english }
%<package>\zcDeclareLanguageAlias { australian } { english }
%<package>\zcDeclareLanguageAlias { british    } { english }
%<package>\zcDeclareLanguageAlias { canadian   } { english }
%<package>\zcDeclareLanguageAlias { newzealand } { english }
%<package>\zcDeclareLanguageAlias { UKenglish  } { english }
%<package>\zcDeclareLanguageAlias { USenglish  } { english }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*dict-english>
%    \end{macrocode}
%
%    \begin{macrocode}
namesep   = {\nobreakspace} ,
pairsep   = {~and\nobreakspace} ,
listsep   = {,~} ,
lastsep   = {~and\nobreakspace} ,
tpairsep  = {~and\nobreakspace} ,
tlistsep  = {,~} ,
tlastsep  = {,~and\nobreakspace} ,
notesep   = {~} ,
rangesep  = {~to\nobreakspace} ,

type = part ,
  Name-sg = Part ,
  name-sg = part ,
  Name-pl = Parts ,
  name-pl = parts ,

type = chapter ,
  Name-sg = Chapter ,
  name-sg = chapter ,
  Name-pl = Chapters ,
  name-pl = chapters ,

type = section ,
  Name-sg = Section ,
  name-sg = section ,
  Name-pl = Sections ,
  name-pl = sections ,

type = paragraph ,
  Name-sg = Paragraph ,
  name-sg = paragraph ,
  Name-pl = Paragraphs ,
  name-pl = paragraphs ,
  Name-sg-ab = Par. ,
  name-sg-ab = par. ,
  Name-pl-ab = Par. ,
  name-pl-ab = par. ,

type = appendix ,
  Name-sg = Appendix ,
  name-sg = appendix ,
  Name-pl = Appendices ,
  name-pl = appendices ,

type = page ,
  Name-sg = Page ,
  name-sg = page ,
  Name-pl = Pages ,
  name-pl = pages ,
  name-sg-ab = p. ,
  name-pl-ab = pp. ,

type = line ,
  Name-sg = Line ,
  name-sg = line ,
  Name-pl = Lines ,
  name-pl = lines ,

type = figure ,
  Name-sg = Figure ,
  name-sg = figure ,
  Name-pl = Figures ,
  name-pl = figures ,
  Name-sg-ab = Fig. ,
  name-sg-ab = fig. ,
  Name-pl-ab = Figs. ,
  name-pl-ab = figs. ,

type = table ,
  Name-sg = Table ,
  name-sg = table ,
  Name-pl = Tables ,
  name-pl = tables ,

type = item ,
  Name-sg = Item ,
  name-sg = item ,
  Name-pl = Items ,
  name-pl = items ,

type = footnote ,
  Name-sg = Footnote ,
  name-sg = footnote ,
  Name-pl = Footnotes ,
  name-pl = footnotes ,

type = note ,
  Name-sg = Note ,
  name-sg = note ,
  Name-pl = Notes ,
  name-pl = notes ,

type = equation ,
  Name-sg = Equation ,
  name-sg = equation ,
  Name-pl = Equations ,
  name-pl = equations ,
  Name-sg-ab = Eq. ,
  name-sg-ab = eq. ,
  Name-pl-ab = Eqs. ,
  name-pl-ab = eqs. ,
  refpre-in = {(} ,
  refpos-in = {)} ,

type = theorem ,
  Name-sg = Theorem ,
  name-sg = theorem ,
  Name-pl = Theorems ,
  name-pl = theorems ,

type = lemma ,
  Name-sg = Lemma ,
  name-sg = lemma ,
  Name-pl = Lemmas ,
  name-pl = lemmas ,

type = corollary ,
  Name-sg = Corollary ,
  name-sg = corollary ,
  Name-pl = Corollaries ,
  name-pl = corollaries ,

type = proposition ,
  Name-sg = Proposition ,
  name-sg = proposition ,
  Name-pl = Propositions ,
  name-pl = propositions ,

type = definition ,
  Name-sg = Definition ,
  name-sg = definition ,
  Name-pl = Definitions ,
  name-pl = definitions ,

type = proof ,
  Name-sg = Proof ,
  name-sg = proof ,
  Name-pl = Proofs ,
  name-pl = proofs ,

type = result ,
  Name-sg = Result ,
  name-sg = result ,
  Name-pl = Results ,
  name-pl = results ,

type = example ,
  Name-sg = Example ,
  name-sg = example ,
  Name-pl = Examples ,
  name-pl = examples ,

type = remark ,
  Name-sg = Remark ,
  name-sg = remark ,
  Name-pl = Remarks ,
  name-pl = remarks ,

type = algorithm ,
  Name-sg = Algorithm ,
  name-sg = algorithm ,
  Name-pl = Algorithms ,
  name-pl = algorithms ,

type = listing ,
  Name-sg = Listing ,
  name-sg = listing ,
  Name-pl = Listings ,
  name-pl = listings ,

type = exercise ,
  Name-sg = Exercise ,
  name-sg = exercise ,
  Name-pl = Exercises ,
  name-pl = exercises ,

type = solution ,
  Name-sg = Solution ,
  name-sg = solution ,
  Name-pl = Solutions ,
  name-pl = solutions ,
%    \end{macrocode}
%
%    \begin{macrocode}
%</dict-english>
%    \end{macrocode}
%
%
%
% \subsection{German}
%
%    \begin{macrocode}
%<package>\zcDeclareLanguage { german }
%<package>\zcDeclareLanguageAlias { austrian     } { german }
%<package>\zcDeclareLanguageAlias { germanb      } { german }
%<package>\zcDeclareLanguageAlias { ngerman      } { german }
%<package>\zcDeclareLanguageAlias { naustrian    } { german }
%<package>\zcDeclareLanguageAlias { nswissgerman } { german }
%<package>\zcDeclareLanguageAlias { swissgerman  } { german }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*dict-german>
%    \end{macrocode}
%
%    \begin{macrocode}
namesep  = {\nobreakspace} ,
pairsep  = {~und\nobreakspace} ,
listsep  = {,~} ,
lastsep  = {~und\nobreakspace} ,
tpairsep = {~und\nobreakspace} ,
tlistsep = {,~} ,
tlastsep = {~und\nobreakspace} ,
notesep  = {~} ,
rangesep = {~bis\nobreakspace} ,

type = part ,
  Name-sg = Teil ,
  name-sg = Teil ,
  Name-pl = Teile ,
  name-pl = Teile ,

type = chapter ,
  Name-sg = Kapitel ,
  name-sg = Kapitel ,
  Name-pl = Kapitel ,
  name-pl = Kapitel ,

type = section ,
  Name-sg = Abschnitt ,
  name-sg = Abschnitt ,
  Name-pl = Abschnitte ,
  name-pl = Abschnitte ,

type = paragraph ,
  Name-sg = Absatz ,
  name-sg = Absatz ,
  Name-pl = Absätze ,
  name-pl = Absätze ,

type = appendix ,
  Name-sg = Anhang ,
  name-sg = Anhang ,
  Name-pl = Anhänge ,
  name-pl = Anhänge ,

type = page ,
  Name-sg = Seite ,
  name-sg = Seite ,
  Name-pl = Seiten ,
  name-pl = Seiten ,

type = line ,
  Name-sg = Zeile ,
  name-sg = Zeile ,
  Name-pl = Zeilen ,
  name-pl = Zeilen ,

type = figure ,
  Name-sg = Abbildung ,
  name-sg = Abbildung ,
  Name-pl = Abbildungen ,
  name-pl = Abbildungen ,
  Name-sg-ab = Abb. ,
  name-sg-ab = Abb. ,
  Name-pl-ab = Abb. ,
  name-pl-ab = Abb. ,

type = table ,
  Name-sg = Tabelle ,
  name-sg = Tabelle ,
  Name-pl = Tabellen ,
  name-pl = Tabellen ,

type = item ,
  Name-sg = Punkt ,
  name-sg = Punkt ,
  Name-pl = Punkte ,
  name-pl = Punkte ,

type = footnote ,
  Name-sg = Fußnote ,
  name-sg = Fußnote ,
  Name-pl = Fußnoten ,
  name-pl = Fußnoten ,

type = note ,
  Name-sg = Anmerkung ,
  name-sg = Anmerkung ,
  Name-pl = Anmerkungen ,
  name-pl = Anmerkungen ,

type = equation ,
  Name-sg = Gleichung ,
  name-sg = Gleichung ,
  Name-pl = Gleichungen ,
  name-pl = Gleichungen ,
  refpre-in = {(} ,
  refpos-in = {)} ,

type = theorem ,
  Name-sg = Theorem ,
  name-sg = Theorem ,
  Name-pl = Theoreme ,
  name-pl = Theoreme ,

type = lemma ,
  Name-sg = Lemma ,
  name-sg = Lemma ,
  Name-pl = Lemmata ,
  name-pl = Lemmata ,

type = corollary ,
  Name-sg = Korollar ,
  name-sg = Korollar ,
  Name-pl = Korollare ,
  name-pl = Korollare ,

type = proposition ,
  Name-sg = Satz ,
  name-sg = Satz ,
  Name-pl = Sätze ,
  name-pl = Sätze ,

type = definition ,
  Name-sg = Definition ,
  name-sg = Definition ,
  Name-pl = Definitionen ,
  name-pl = Definitionen ,

type = proof ,
  Name-sg = Beweis ,
  name-sg = Beweis ,
  Name-pl = Beweise ,
  name-pl = Beweise ,

type = result ,
  Name-sg = Ergebnis ,
  name-sg = Ergebnis ,
  Name-pl = Ergebnisse ,
  name-pl = Ergebnisse ,

type = example ,
  Name-sg = Beispiel ,
  name-sg = Beispiel ,
  Name-pl = Beispiele ,
  name-pl = Beispiele ,

type = remark ,
  Name-sg = Bemerkung ,
  name-sg = Bemerkung ,
  Name-pl = Bemerkungen ,
  name-pl = Bemerkungen ,

type = algorithm ,
  Name-sg = Algorithmus ,
  name-sg = Algorithmus ,
  Name-pl = Algorithmen ,
  name-pl = Algorithmen ,

type = listing ,
  Name-sg = Listing , % CHECK
  name-sg = Listing , % CHECK
  Name-pl = Listings , % CHECK
  name-pl = Listings , % CHECK

type = exercise ,
  Name-sg = Übungsaufgabe ,
  name-sg = Übungsaufgabe ,
  Name-pl = Übungsaufgaben ,
  name-pl = Übungsaufgaben ,

type = solution ,
  Name-sg = Lösung ,
  name-sg = Lösung ,
  Name-pl = Lösungen ,
  name-pl = Lösungen ,
%    \end{macrocode}
%
%    \begin{macrocode}
%</dict-german>
%    \end{macrocode}
%
%
%
% \subsection{French}
%
%    \begin{macrocode}
%<package>\zcDeclareLanguage { french }
%<package>\zcDeclareLanguageAlias { acadian  } { french }
%<package>\zcDeclareLanguageAlias { canadien } { french }
%<package>\zcDeclareLanguageAlias { francais } { french }
%<package>\zcDeclareLanguageAlias { frenchb  } { french }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*dict-french>
%    \end{macrocode}
%
%    \begin{macrocode}
namesep  = {\nobreakspace} ,
pairsep  = {~et\nobreakspace} ,
listsep  = {,~} ,
lastsep  = {~et\nobreakspace} ,
tpairsep = {~et\nobreakspace} ,
tlistsep = {,~} ,
tlastsep = {~et\nobreakspace} ,
notesep  = {~} ,
rangesep = {~à\nobreakspace} ,

type = part ,
  Name-sg = Partie ,
  name-sg = partie ,
  Name-pl = Parties ,
  name-pl = parties ,

type = chapter ,
  Name-sg = Chapitre ,
  name-sg = chapitre ,
  Name-pl = Chapitres ,
  name-pl = chapitres ,

type = section ,
  Name-sg = Section ,
  name-sg = section ,
  Name-pl = Sections ,
  name-pl = sections ,

type = paragraph ,
  Name-sg = Paragraphe ,
  name-sg = paragraphe ,
  Name-pl = Paragraphes ,
  name-pl = paragraphes ,

type = appendix ,
  Name-sg = Annexe ,
  name-sg = annexe ,
  Name-pl = Annexes ,
  name-pl = annexes ,

type = page ,
  Name-sg = Page ,
  name-sg = page ,
  Name-pl = Pages ,
  name-pl = pages ,

type = line ,
  Name-sg = Ligne ,
  name-sg = ligne ,
  Name-pl = Lignes ,
  name-pl = lignes ,

type = figure ,
  Name-sg = Figure ,
  name-sg = figure ,
  Name-pl = Figures ,
  name-pl = figures ,

type = table ,
  Name-sg = Table ,
  name-sg = table ,
  Name-pl = Tables ,
  name-pl = tables ,

type = item ,
  Name-sg = Point ,
  name-sg = point ,
  Name-pl = Points ,
  name-pl = points ,

type = footnote ,
  Name-sg = Note ,
  name-sg = note ,
  Name-pl = Notes ,
  name-pl = notes ,

type = note ,
  Name-sg = Note ,
  name-sg = note ,
  Name-pl = Notes ,
  name-pl = notes ,

type = equation ,
  Name-sg = Équation ,
  name-sg = équation ,
  Name-pl = Équations ,
  name-pl = équations ,
  refpre-in = {(} ,
  refpos-in = {)} ,

type = theorem ,
  Name-sg = Théorème ,
  name-sg = théorème ,
  Name-pl = Théorèmes ,
  name-pl = théorèmes ,

type = lemma ,
  Name-sg = Lemme ,
  name-sg = lemme ,
  Name-pl = Lemmes ,
  name-pl = lemmes ,

type = corollary ,
  Name-sg = Corollaire ,
  name-sg = corollaire ,
  Name-pl = Corollaires ,
  name-pl = corollaires ,

type = proposition ,
  Name-sg = Proposition ,
  name-sg = proposition ,
  Name-pl = Propositions ,
  name-pl = propositions ,

type = definition ,
  Name-sg = Définition ,
  name-sg = définition ,
  Name-pl = Définitions ,
  name-pl = définitions ,

type = proof ,
  Name-sg = Démonstration ,
  name-sg = démonstration ,
  Name-pl = Démonstrations ,
  name-pl = démonstrations ,

type = result ,
  Name-sg = Résultat ,
  name-sg = résultat ,
  Name-pl = Résultats ,
  name-pl = résultats ,

type = example ,
  Name-sg = Exemple ,
  name-sg = exemple ,
  Name-pl = Exemples ,
  name-pl = exemples ,

type = remark ,
  Name-sg = Remarque ,
  name-sg = remarque ,
  Name-pl = Remarques ,
  name-pl = remarques ,

type = algorithm ,
  Name-sg = Algorithme ,
  name-sg = algorithme ,
  Name-pl = Algorithmes ,
  name-pl = algorithmes ,

type = listing ,
  Name-sg = Liste ,
  name-sg = liste ,
  Name-pl = Listes ,
  name-pl = listes ,

type = exercise ,
  Name-sg = Exercice ,
  name-sg = exercice ,
  Name-pl = Exercices ,
  name-pl = exercices ,

type = solution ,
  Name-sg = Solution ,
  name-sg = solution ,
  Name-pl = Solutions ,
  name-pl = solutions ,
%    \end{macrocode}
%
%    \begin{macrocode}
%</dict-french>
%    \end{macrocode}
%
%
%
% \subsection{Portuguese}
%
%    \begin{macrocode}
%<package>\zcDeclareLanguage { portuguese }
%<package>\zcDeclareLanguageAlias { brazilian } { portuguese }
%<package>\zcDeclareLanguageAlias { brazil    } { portuguese }
%<package>\zcDeclareLanguageAlias { portuges  } { portuguese }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*dict-portuguese>
%    \end{macrocode}
%
%    \begin{macrocode}
namesep  = {\nobreakspace} ,
pairsep  = {~e\nobreakspace} ,
listsep  = {,~} ,
lastsep  = {~e\nobreakspace} ,
tpairsep = {~e\nobreakspace} ,
tlistsep = {,~} ,
tlastsep = {~e\nobreakspace} ,
notesep  = {~} ,
rangesep = {~a\nobreakspace} ,

type = part ,
  Name-sg = Parte ,
  name-sg = parte ,
  Name-pl = Partes ,
  name-pl = partes ,

type = chapter ,
  Name-sg = Capítulo ,
  name-sg = capítulo ,
  Name-pl = Capítulos ,
  name-pl = capítulos ,

type = section ,
  Name-sg = Seção ,
  name-sg = seção ,
  Name-pl = Seções ,
  name-pl = seções ,

type = paragraph ,
  Name-sg = Parágrafo ,
  name-sg = parágrafo ,
  Name-pl = Parágrafos ,
  name-pl = parágrafos ,
  Name-sg-ab = Par. ,
  name-sg-ab = par. ,
  Name-pl-ab = Par. ,
  name-pl-ab = par. ,

type = appendix ,
  Name-sg = Apêndice ,
  name-sg = apêndice ,
  Name-pl = Apêndices ,
  name-pl = apêndices ,

type = page ,
  Name-sg = Página ,
  name-sg = página ,
  Name-pl = Páginas ,
  name-pl = páginas ,
  name-sg-ab = p. ,
  name-pl-ab = pp. ,

type = line ,
  Name-sg = Linha ,
  name-sg = linha ,
  Name-pl = Linhas ,
  name-pl = linhas ,

type = figure ,
  Name-sg = Figura ,
  name-sg = figura ,
  Name-pl = Figuras ,
  name-pl = figuras ,
  Name-sg-ab = Fig. ,
  name-sg-ab = fig. ,
  Name-pl-ab = Figs. ,
  name-pl-ab = figs. ,

type = table ,
  Name-sg = Tabela ,
  name-sg = tabela ,
  Name-pl = Tabelas ,
  name-pl = tabelas ,

type = item ,
  Name-sg = Item ,
  name-sg = item ,
  Name-pl = Itens ,
  name-pl = itens ,

type = footnote ,
  Name-sg = Nota ,
  name-sg = nota ,
  Name-pl = Notas ,
  name-pl = notas ,

type = note ,
  Name-sg = Nota ,
  name-sg = nota ,
  Name-pl = Notas ,
  name-pl = notas ,

type = equation ,
  Name-sg = Equação ,
  name-sg = equação ,
  Name-pl = Equações ,
  name-pl = equações ,
  Name-sg-ab = Eq. ,
  name-sg-ab = eq. ,
  Name-pl-ab = Eqs. ,
  name-pl-ab = eqs. ,
  refpre-in = {(} ,
  refpos-in = {)} ,

type = theorem ,
  Name-sg = Teorema ,
  name-sg = teorema ,
  Name-pl = Teoremas ,
  name-pl = teoremas ,

type = lemma ,
  Name-sg = Lema ,
  name-sg = lema ,
  Name-pl = Lemas ,
  name-pl = lemas ,

type = corollary ,
  Name-sg = Corolário ,
  name-sg = corolário ,
  Name-pl = Corolários ,
  name-pl = corolários ,

type = proposition ,
  Name-sg = Proposição ,
  name-sg = proposição ,
  Name-pl = Proposições ,
  name-pl = proposições ,

type = definition ,
  Name-sg = Definição ,
  name-sg = definição ,
  Name-pl = Definições ,
  name-pl = definições ,

type = proof ,
  Name-sg = Demonstração ,
  name-sg = demonstração ,
  Name-pl = Demonstrações ,
  name-pl = demonstrações ,

type = result ,
  Name-sg = Resultado ,
  name-sg = resultado ,
  Name-pl = Resultados ,
  name-pl = resultados ,

type = example ,
  Name-sg = Exemplo ,
  name-sg = exemplo ,
  Name-pl = Exemplos ,
  name-pl = exemplos ,

type = remark ,
  Name-sg = Observação ,
  name-sg = observação ,
  Name-pl = Observações ,
  name-pl = observações ,

type = algorithm ,
  Name-sg = Algoritmo ,
  name-sg = algoritmo ,
  Name-pl = Algoritmos ,
  name-pl = algoritmos ,

type = listing ,
  Name-sg = Listagem ,
  name-sg = listagem ,
  Name-pl = Listagens ,
  name-pl = listagens ,

type = exercise ,
  Name-sg = Exercício ,
  name-sg = exercício ,
  Name-pl = Exercícios ,
  name-pl = exercícios ,

type = solution ,
  Name-sg = Solução ,
  name-sg = solução ,
  Name-pl = Soluções ,
  name-pl = soluções ,
%    \end{macrocode}
%
%    \begin{macrocode}
%</dict-portuguese>
%    \end{macrocode}
%
%
%
% \subsection{Spanish}
%
%    \begin{macrocode}
%<package>\zcDeclareLanguage { spanish }
%    \end{macrocode}
%
%    \begin{macrocode}
%<*dict-spanish>
%    \end{macrocode}
%
%    \begin{macrocode}
namesep  = {\nobreakspace} ,
pairsep  = {~y\nobreakspace} ,
listsep  = {,~} ,
lastsep  = {~y\nobreakspace} ,
tpairsep = {~y\nobreakspace} ,
tlistsep = {,~} ,
tlastsep = {~y\nobreakspace} ,
notesep  = {~} ,
rangesep = {~a\nobreakspace} ,

type = part ,
  Name-sg = Parte ,
  name-sg = parte ,
  Name-pl = Partes ,
  name-pl = partes ,

type = chapter ,
  Name-sg = Capítulo ,
  name-sg = capítulo ,
  Name-pl = Capítulos ,
  name-pl = capítulos ,

type = section ,
  Name-sg = Sección ,
  name-sg = sección ,
  Name-pl = Secciones ,
  name-pl = secciones ,

type = paragraph ,
  Name-sg = Párrafo ,
  name-sg = párrafo ,
  Name-pl = Párrafos ,
  name-pl = párrafos ,

type = appendix ,
  Name-sg = Apéndice ,
  name-sg = apéndice ,
  Name-pl = Apéndices ,
  name-pl = apéndices ,

type = page ,
  Name-sg = Página ,
  name-sg = página ,
  Name-pl = Páginas ,
  name-pl = páginas ,

type = line ,
  Name-sg = Línea ,
  name-sg = línea ,
  Name-pl = Líneas ,
  name-pl = líneas ,

type = figure ,
  Name-sg = Figura ,
  name-sg = figura ,
  Name-pl = Figuras ,
  name-pl = figuras ,

type = table ,
  Name-sg = Cuadro ,
  name-sg = cuadro ,
  Name-pl = Cuadros ,
  name-pl = cuadros ,

type = item ,
  Name-sg = Punto ,
  name-sg = punto ,
  Name-pl = Puntos ,
  name-pl = puntos ,

type = footnote ,
  Name-sg = Nota ,
  name-sg = nota ,
  Name-pl = Notas ,
  name-pl = notas ,

type = note ,
  Name-sg = Nota ,
  name-sg = nota ,
  Name-pl = Notas ,
  name-pl = notas ,

type = equation ,
  Name-sg = Ecuación ,
  name-sg = ecuación ,
  Name-pl = Ecuaciones ,
  name-pl = ecuaciones ,
  refpre-in = {(} ,
  refpos-in = {)} ,

type = theorem ,
  Name-sg = Teorema ,
  name-sg = teorema ,
  Name-pl = Teoremas ,
  name-pl = teoremas ,

type = lemma ,
  Name-sg = Lema ,
  name-sg = lema ,
  Name-pl = Lemas ,
  name-pl = lemas ,

type = corollary ,
  Name-sg = Corolario ,
  name-sg = corolario ,
  Name-pl = Corolarios ,
  name-pl = corolarios ,

type = proposition ,
  Name-sg = Proposición ,
  name-sg = proposición ,
  Name-pl = Proposiciones ,
  name-pl = proposiciones ,

type = definition ,
  Name-sg = Definición ,
  name-sg = definición ,
  Name-pl = Definiciones ,
  name-pl = definiciones ,

type = proof ,
  Name-sg = Demostración ,
  name-sg = demostración ,
  Name-pl = Demostraciones ,
  name-pl = demostraciones ,

type = result ,
  Name-sg = Resultado ,
  name-sg = resultado ,
  Name-pl = Resultados ,
  name-pl = resultados ,

type = example ,
  Name-sg = Ejemplo ,
  name-sg = ejemplo ,
  Name-pl = Ejemplos ,
  name-pl = ejemplos ,

type = remark ,
  Name-sg = Observación ,
  name-sg = observación ,
  Name-pl = Observaciones ,
  name-pl = observaciones ,

type = algorithm ,
  Name-sg = Algoritmo ,
  name-sg = algoritmo ,
  Name-pl = Algoritmos ,
  name-pl = algoritmos ,

type = listing ,
  Name-sg = Listado ,
  name-sg = listado ,
  Name-pl = Listados ,
  name-pl = listados ,

type = exercise ,
  Name-sg = Ejercicio ,
  name-sg = ejercicio ,
  Name-pl = Ejercicios ,
  name-pl = ejercicios ,

type = solution ,
  Name-sg = Solución ,
  name-sg = solución ,
  Name-pl = Soluciones ,
  name-pl = soluciones ,
%    \end{macrocode}
%
%    \begin{macrocode}
%</dict-spanish>
%    \end{macrocode}
%
%
% \PrintIndex
%
% \end{implementation}
