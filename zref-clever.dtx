% \iffalse meta-comment
%
% File: zref-clever.dtx
%
% This file is part of the LaTeX package "zref-clever".
%
% Copyright (C) 2021  Gustavo Barros
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file:
%
%    https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
%
% This work is "maintained" (as per LPPL maintenance status) by
% Gustavo Barros.
%
% This work consists of the files zref-clever.dtx,
%                                 zref-clever.ins,
%                                 zref-clever.tex,
%                                 zref-clever-code.tex,
%           and the derived files zref-clever.sty and
%                                 zref-clever.pdf,
%                                 zref-clever-code.pdf.
%
% The released version of this package is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the package can be found at
%
%    https://github.com/gusbrs/zref-clever
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}
% Have \GetFileInfo pick up date and version data
\usepackage{zref-check}
\NewDocumentCommand\opt{m}{\texttt{#1}}
\MakeShortVerb{\|}
\begin{document}
  \DocInput{zref-clever.dtx}
\end{document}
%</driver>
% \fi
%
%
% \begin{documentation}
%
%
% \end{documentation}
%
%
%
% \begin{implementation}
%
% \section{Initial setup}
%
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=zrefclever>
%    \end{macrocode}
%
%
%
% Identify the package.
%    \begin{macrocode}
\ProvidesExplPackage {zref-clever} {2021-08-09} {0.1.0-alpha}
  {Do-what-I-mean cross-references based on zref}
%    \end{macrocode}
%
% \section{Dependencies}
%
%    \begin{macrocode}
\RequirePackage { zref-user }
\RequirePackage { zref-counter }
\RequirePackage { zref-abspage }
\RequirePackage { translations }
%    \end{macrocode}
%
%
%
% \section{\pkg{zref} setup}
%
% We are interested in three basic label elements: the reference itself, the
% page, and the counter.  The `page' and `counter' are respectively handled by
% modules \pkg{zref-base} and \pkg{zref-counter}.  The \pkg{zref-abspage} also
% provides the `abspage' property which gives us a safe and easy way to sort
% labels on page references.  But the reference itself, stored by \pkg{zref}
% in the `default' field, is somewhat a disputed real estate.  In particular,
% the use of \cs{labelformat} will include there the reference ``prefix'' and
% complicate the job we are trying to do here.  Hence, we isolate
% \cs{the}\meta{counter} and store it ``clean'' in \texttt{zc@thecnt} for
% reserved use.  We also store the ``type'' of the label at this point (see
% Section~\ref{sec:reference-types}).
%
%    \begin{macrocode}
\zref@newprop { zc@type }
  { \exp_args:NNo \prop_item:Nn \l_@@_counter_type_prop { \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@type }
%    \end{macrocode}
%
% From the definition of \cs{@currentlabel} done inside \cs{refstepcounter} in
% 'texdoc source2e', section 'ltcounts.dtx'.  We just drop the \cs{p@...}
% prefix.
%    \begin{macrocode}
\zref@newprop { zc@thecnt } { \cs:w the \@currentcounter \cs_end: }
\zref@addprop \ZREF@mainlist { zc@thecnt }
%    \end{macrocode}
%
% However, the moment where the label is set is a privileged one, because at
% this point we have a lot of raw information available.  Information which
% may be difficult to retrieve later on by parsing the reference printed value
% of the counter, which we stored in \texttt{zc@thecnt} above.  Hence, we
% seize the opportunity to store some of that information in a way which eases
% significantly the task of processing the reference later on: i) the counter
% \emph{value}, as a number; ii) the counter values of the set of counters
% which may trigger a reset of the current counter.
%
% The first one is trivial, \cs{c@}\meta{counter} contains the counter's
% numerical value (see `texdoc source2e', section `ltcounts.dtx'), we just
% store it in \texttt{zc@cntval}.
%    \begin{macrocode}
\zref@newprop { zc@cntval } [0] { \int_use:c { c@\@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@cntval }
%    \end{macrocode}
%
% And we need the same for the page.
%    \begin{macrocode}
\zref@newprop* { zc@pgval } [0] { \int_use:c { c@page } }
\zref@addprop \ZREF@mainlist { zc@pgval }
%    \end{macrocode}
%
% The second one is trickier.  For starters, the counters which may reset the
% current counter are not retrievable from the counter itself, because this
% information is stored with the counter that does the resetting, not with the
% one that gets reset (the list is stored in \cs{cl@}\meta{counter} with
% format |\@elt{countera}\@elt{counterb}\@elt{counterc}|, again see section
% `ltcounts.dtx' in `source2e').  Besides, there may be a chain of resetting
% counters, which must be taken into account.  The procedure below examines a
% set of counters, those included in \cs{g_@@_reseters_seq}, and for each
% counter retrieves its ``within-counters'' recursively.  There is one
% relevant caveat to this procedure: \cs{g_@@_reseters_seq} is populated by
% hand with the ``usual suspects'', there is no way (that I know of) to ensure
% it is exhaustive.  However, it is not that difficult to create a reasonable
% ``usual suspects'' list which, of course, should include the counters for
% the sectioning commands, to start with, and it is easy to add more counters
% to this list if needed.
%
% \begin{variable}{\g_@@_reseters_seq}
%   Stores the list of counters which get examined \cs{AtBeginDocument} as
%   potential ``within-counters'' for other counters.
%    \begin{macrocode}
\seq_set_from_clist:Nn \g_@@_reseters_seq
  {
    part ,
    chapter ,
    section ,
    subsection ,
    subsubsection ,
    paragraph ,
    subparagraph
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[EXP]
%   {
%     \@@_get_within_counters:n,
%     \@@_get_within_counters_value:n
%   }
% Recursively generate a \emph{sequence} of ``within-counters'' and values,
% for a given \Arg{counter} and leave it in the input stream.  These functions
% must be expandable, since they get called from \cs{zref@newprop} and are the
% ones responsible for generating the desired information when the label is
% being set.  Note that the order in which we are getting this information is
% reversed, since we are navigating the counter reset chain bottom-up.  But it
% is very hard to do otherwise here where we need expandable functions, and
% easy to handle at the reading side.
%    \begin{macrocode}
\cs_new:Npn \@@_get_within_counters:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \@@_counter_reset_by:n {#1} }
        \@@_get_within_counters:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
\cs_new:Npn \@@_get_within_counters_value:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \int_use:N \cs:w c@ \@@_counter_reset_by:n {#1} \cs_end: }
        \@@_get_within_counters_value:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
% Both \texttt{e} and \texttt{f} expansions work for this particular recursive
% call.  For the time being, I'll stay with the \texttt{e} variant, since
% conceptually it is what I want (\texttt{x} itself is not expandable), and
% this package is unlikely to be used within the context of older kernels for
% which the performance penalty of the \texttt{e} expansion would ensue (see
% also \url{https://tex.stackexchange.com/q/611370/#comment1529282_611385},
% thanks Enrico Gregorio, aka `egreg').
\cs_generate_variant:Nn \@@_get_within_counters:n { o , e }
\cs_generate_variant:Nn \@@_get_within_counters_value:n { o , e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \@@_counter_reset_by:n,
%     \@@_counter_within:nn,
%     \@@_counter_within_aux:nnn
%   }
% Auxiliary functions for \cs{@@_get_within_counters:n} and
% \cs{@@_get_within_counters_value:n}.  They are broken in parts to be able to
% use the expandable mapping functions.  In particular
% \cs{@@_counter_reset_by:n} leaves in the stream the ``within-counter'' which
% resets \Arg{counter}.
%    \begin{macrocode}
\cs_new:Npn \@@_counter_reset_by:n #1
  {
    \bool_case_true:nF
      {
%    \end{macrocode}
% The counters for the \texttt{enumerate} environment do not use the regular
% counter machinery for resetting on each level, but are nested nevertheless
% by other means, treat them as exception.  TODO This list should probably be
% extended for `enumitem', since it is very hard to expose this at the user
% side.
%    \begin{macrocode}
        { \str_if_eq_p:nn {#1} { enumii  } } { enumi   }
        { \str_if_eq_p:nn {#1} { enumiii } } { enumii  }
        { \str_if_eq_p:nn {#1} { enumiv  } } { enumiii }
      }
      {
        \seq_map_tokens:Nn \g_@@_reseters_seq
          { \@@_counter_within:nn {#1} }
      }
  }
\cs_new:Npn \@@_counter_within:nn #1#2
  {
    \cs_if_exist:cT { c@ #2 }
      {
        \tl_if_empty:cF { cl@ #2 }
          {
            \tl_map_tokens:cn { cl@ #2 }
              { \@@_counter_within_aux:nnn {#2} {#1} }
          }
      }
  }
\cs_new:Npn \@@_counter_within_aux:nnn #1#2#3
  {
    \str_if_eq:nnT {#2} {#3}
      { \tl_map_break:n { \seq_map_break:n {#1} } }
  }
%    \end{macrocode}
% \end{macro}
%
% Finally, add \texttt{zc@withincnt} and \texttt{zc@withinval} to \pkg{zref}'s
% \texttt{main} property list.
%    \begin{macrocode}
\zref@newprop { zc@withincnt }
  { \@@_get_within_counters:o { \@currentcounter } }
\zref@newprop { zc@withinval }
  { \@@_get_within_counters_value:o { \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@withincnt }
\zref@addprop \ZREF@mainlist { zc@withinval }
%    \end{macrocode}
%
% The `page' itself may also be subject to resetting with \cs{refstepcounter}.
% It is not by default in the standard classes, but it \emph{may} be defined
% to be so, e.g.z as with the package \pkg{chappg}, so we store that too.
% CHECK I think this is not actually needed.  \pkg{cleveref} does store the
% equivalent of \texttt{zc@pgwithinval}, but it doesn't have \texttt{abspage}
% available.  Since we can sort with the later, and decide about compression
% with \texttt{zc@pgfmt}, we don't need to keep track of the whole reset chain
% for \texttt{page}, which does not tell us the whole picture anyway, given it
% gets reset more frequently with \cs{pagenumbering}.
%    \begin{macrocode}
% \zref@newprop { zc@pgwithincnt }
%   { \@@_get_within_counters:o { page } }
% \zref@newprop { zc@pgwithinval }
%   { \@@_get_within_counters_value:n { page } }
% \zref@addprop \ZREF@mainlist { zc@pgwithincnt }
% \zref@addprop \ZREF@mainlist { zc@pgwithinval }
%    \end{macrocode}
%
%
% A previous version of the same task.  Easier to implement, hence possibly
% more robust (for me to maintain, that is\dots{}), but which required to
% assess the state of the reset counters \cs{AtBeginDocument}, so does not get
% mid-document changes.  Keep it around for the time being, in case we face
% trouble with the expandable version.  The procedure here examines a set of
% counters, those included in \cs{g_@@_reseters_seq}, and for each counter
% each of those reset, defines a \texttt{tl} variable with name
% \cs{g_@@_counter_\meta{counter}_within_tl} storing the value of its
% ``within-counter''.  These \texttt{tl} variables are then used by
% \cs{@@_get_within_counters_value_old:n} to store the desired information when the
% label is actually set.
% \begin{verbatim}
% \cs_new:Npn \@@_get_within_counters_value_old:n #1
%   {
%     \bool_lazy_and:nnT
%       { \tl_if_exist_p:c { g_@@_counter_ \tl_use:N #1 _within_tl } }
%       {
%         \cs_if_exist_p:c
%           { c@ \use:c { g_@@_counter_ \tl_use:N #1 _within_tl } }
%       }
%       {
%         { \int_use:c { c@ \use:c { g_@@_counter_ \tl_use:N #1 _within_tl } } }
%         \@@_get_within_counters_value_old:n
%           { \use:c { g_@@_counter_ \tl_use:N #1 _within_tl } }
%       }
%   }
% \end{verbatim}
% Map through \cs{g_@@_reseters_seq} defining \texttt{tl} variables storing,
% for each counter that may be reset, the ``within-counter'' which may do so.
% \begin{verbatim}
% \cs_new:Npn \@@_set_within_counters:
%   {
%     \group_begin:
%       \seq_map_inline:Nn \g_@@_reseters_seq
%         {
%           \cs_if_exist:cT { c@ ##1 }
%             {
%               \cs_set:Npn \@@_elt_aux:n ####1
%                 {
%                   \tl_if_exist:cF { g_@@_counter_ ####1 _within_tl }
%                     { \tl_gset:cx { g_@@_counter_ ####1 _within_tl } {##1} }
%                 }
%               \cs_set_eq:NN \@elt \@@_elt_aux:n
%               \use:c { cl@ ##1 }
%             }
%         }
%     \group_end:
%   }
% \end{verbatim}
% And run it \cs{AtBeginDocument}.
% \begin{verbatim}
% \AtBeginDocument { \@@_set_within_counters: }
% \end{verbatim}
%
%
% \begin{macro}[EXP]{\@@_page_numbering:}
%   Another piece of information we need is the page numbering format being
%   used by \cs{thepage}, so that we know when we can (or not) group a set of
%   page references in a range.  Unfortunately, the ``page'' is not a typical
%   counter in ways which complicates things.  First, it does commonly get
%   reset along the document, not necessarily by the usual counter reset
%   chains, but rather with \cs{pagenumbering} or variations thereof.  Second,
%   the format of the page number commonly changes in the document (roman,
%   arabic, etc.), not necessarily, though usually, together with a reset.
%   Trying to ``parse'' \cs{thepage} to retrieve such information is bound to
%   go wrong: we don't know, and can't know, what is within that macro, and
%   that's the business of the user, or of the documentclass, or of the loaded
%   packages.  The technique used by \pkg{cleveref}, which we borrow here, is
%   simple and smart: store with the label what \cs{thepage} would return, if
%   the counter \cs{c@page} was ``1''.  That does not allow us to \emph{sort}
%   the references, luckily however, we have \texttt{abspage} which can be
%   used for that.  But we can decide whether two labels can be compressed or
%   not based on this format: if they are identical, we can compress them,
%   otherwise, we can't.  \pkg{cleveref} actually resets the counter to ``1''
%   with \cs{setcounter}, which is a global operation, and restores it in
%   sequence.  Here we adopt a more cautious approach of locally redefining
%   \cs{c@page} to return ``1'', thus avoiding any global spillovers of this
%   trick.  Since this operation is not expandable we cannot run it directly
%   from the property definition.  Hence, we use a shipout hook, and set
%   \cs{g_@@_page_format_tl}, which can then be retrieved by the starred
%   definition of |\zref@newprop*{zc@pgfmt}|.
%    \begin{macrocode}
\tl_new:N \g_@@_page_format_tl
\cs_new_protected:Npx \@@_page_format_aux: { \int_eval:n { 1 } }
\AddToHook { shipout / before }
  {
    \group_begin:
    \cs_set_eq:NN \c@page \@@_page_format_aux:
    \exp_args:NNx \tl_gset:Nn \g_@@_page_format_tl { \thepage }
    \group_end:
  }
\zref@newprop* { zc@pgfmt } { \g_@@_page_format_tl }
\zref@addprop \ZREF@mainlist { zc@pgfmt }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Plumbing}
%
% \subsection{Reference Types}
% \label{sec:reference-types}
%
% Let's start with a bit of terminology, to avoid confusion.  A ``reference
% type'' is the basic \pkg{zref-clever} setup unit for specifying how a
% cross-reference group of a certain kind is to be typeset.  Though, usually,
% it will have the same name as the underlying \LaTeX{} \emph{counter}, they
% are conceptually different.  \pkg{zref-clever} defines \emph{reference
% types} and an association between each \emph{counter} and its \emph{type},
% it does not define the counters themselves, which are defined by your
% document.  One \emph{reference type} can be associated with one or more
% \emph{counters}, but each counter can only have one \emph{type}
% (locally\dots{}), and that determines how the reference is typeset.
% References to different \emph{counters} of the same \emph{type} are grouped
% together, and treated alike by \pkg{zref-clever}.  A \emph{reference type}
% may exist even when the \emph{counter} it is associated with is not actually
% defined, and this inconsequential.  In practice, the contrary may also
% happen, a \emph{counter} may be defined but we have no \emph{type} for it,
% but this must be handled by \pkg{zref-clever} as a ``missing type'' error
% (at least, if we try to refer to it).
%
% A \emph{reference type} can be associated with multiple counters because we
% may want to refer to different document elements, with different
% \emph{counters}, with a single name, as a single \emph{type}.  One prominent
% case of this are sectioning commands.  \cs{section}, \cs{subsection}, and
% \cs{subsubsection} have each their counter, but we'd like to refer to all of
% them by ``section''.  The same for \cs{paragraph} and \cs{subparagraph}.
% There is one relevant subtlety to grouping multiple counters under the same
% type: in order for us to be able to meaningfully sort and compress this
% group, the set of counters contained therein cannot be arbitrary.  Indeed,
% all of the \emph{counters} grouped in the same \emph{type} must belong to
% the same counter reset chain, and must be nested within each other (they
% cannot even just share the same parent).  The need to check this (?) has
% some implications to the data we store in the label.  Since we cannot do
% this verification when we set up the \emph{reference type}, because at this
% point we could only check existing counters, and they may be defined
% ``later'' or ``never'', the counter reset chain must be stored (names and
% values) with the label itself (this is done in properties
% \texttt{zc@withincnt} and \texttt{zc@withinval}).
%
%
% \begin{variable}{\l_@@_counter_type_prop}
%   Variable storing a mapping from ``counter'' to ``reference type''. TODO
%   This will have to be populated by user facing setup infrastructure.
%    \begin{macrocode}
\prop_new:N \l_@@_counter_type_prop
\prop_set_from_keyval:Nn \l_@@_counter_type_prop
  {
    part = part ,
    chapter = chapter ,
    section = section ,
    subsection = section ,
    subsubsection = section ,
    paragraph = paragraph ,
    subparagraph = paragraph ,
    figure = figure ,
    table = table ,
    equation = equation ,
    enumi = item ,
    enumii = item ,
    enumiii = item ,
    enumiv = item ,
  }
%    \end{macrocode}
% \end{variable}
%
%
% There are also cases in which we may want to use different \emph{reference
% types} to refer to document objects sharing the same \emph{counter}.
% Prominently, the environments created with the kernel's \cs{newtheorem}
% command and the \cs{appendix}, but we'll try to consider, and handle, the
% case generally.
%
% Regarding \cs{newtheorem}, \pkg{cleveref} deals with this by redefining its
% internals and retrieving the environment's name, to infer the type and do an
% ``automatic definition'' of theorem-like environments with a reasonable
% default.  But even then, it can only provide the singular form of the
% cross-reference name, and if the plural is ever needed, the name has to be
% provided manually anyway.  It also imposes the restriction of
% \cs{newtheorem} only being used in the preamble, which in itself would be
% good practice, but \cs{newtheorem} is documented to be allowed anywhere in
% the document (see \texttt{texdoc source2e}, section `ltthm.dtx', comment at
% the definition of \cs{newtheorem}).  And the calls to \cs{newtheorem} must
% also come after \pkg{cleveref} is loaded.  And for this to work, either
% \pkg{ntheorem} or \pkg{amsthm} must be loaded (as stated in the ``Non-Bugs''
% section of the documentation).  This automatism is, of course, a good thing,
% but the restrictions are considerable.
%
% A related mechanism \pkg{cleveref} provides for overriding individual labels
% is by adding optional arguments to both \cs{label} and \cs{refstepcounter}
% which receives a ``counter override label type'' and stores that
% \emph{instead} of regular counter with the \cs{newlabel} in the \file{.aux}
% file.  This affords for a fully manual ``one time'' counter override for
% that particular label.
%
% Another relevant use case of the same general problem of different types for
% the same counter is the \cs{appendix} which in some document classes,
% including the standard ones, change the sectioning commands looks but, of
% course, keep using the same counter (\file{book.cls} and \file{report.cls}
% reset counters \texttt{chapter} and \texttt{section} to 0, change
% \cs{@chapapp} to use \cs{appendixname} and use \cs{@Alph} for
% \cs{thechapter}; \file{article.cls} resets counters \texttt{section} and
% \texttt{subsection} to 0, and uses \cs{@Alph} for \cs{thesection};
% \file{memoir.cls}, \file{scrbook.cls} and \file{scrarticle.cls} do the same
% as their corresponding standard classes, and sometimes a little more, but
% what interests us here is pretty much the same; see also the \pkg{appendix}
% package).
%
% All in all, and since \pkg{zref} spares us of the need to redefine such core
% commands, I think a more general approach, even if a little less automatic,
% is the best for us here.  \pkg{zref}'s data flexibility also helps us in
% this.  As it turns out, we can also use \cs{l_@@_counter_type_prop} for this
% purpose (hence it was made locally scoped).  And we do so by storing, with
% the label, the ``type'' value of the ``counter'' key in
% \cs{l_@@_counter_type_prop} when the label is set.  If it was not for the
% need to distinguish different \emph{types} of the same \emph{counter} this
% information could be kept in the variable alone, but since we need to
% leverage other document information in the process, storing it with the
% label is not a bad idea.  And it makes some things simpler even for the
% general case, since we don't have to control whether there is a type
% property in the label or not.  (The property would have to be included
% anyway, since the \cs{appendix} case offers little in terms of hooks or
% grouping, the only choice is whether to populate this property for every
% label or just for the ones we'd like to ``override'').  With that in hand,
% \cs{l_@@_counter_type_prop} can be set at appropriate times, and the
% information gets stored in the label.  For environments, it is trivial with
% a hook to \texttt{env/\meta{env}/begin}.  This can be used for
% \cs{newtheorem} environments to start with.  In principle, with a recent
% kernel, a hook to \cs{appendix} could also be used, otherwise some (simple)
% user intervention may be required.
%
% The use case for the optional argument for \cs{label} and
% \cs{refstepcounter} I do not quite grasp, and it does introduce ample
% opportunity for users to shoot themselves in the foot.  Still, an equivalent
% could be provided by, for example, defining a document command
% \cs{zclabel}\oart{type}\marg{label} which makes a group, sets the type
% variable, and calls \cs{zlabel} with \meta{label}.  Anyway, for the time
% being, I'll provide the higher level infrastructure, covering
% \cs{newtheorem} and \cs{appendix}, and only introduce a manual override of
% the sort if the need indeed arises and is well justified.
%
%
%
%
%
% \section{\cs{zcref}}
%
%
%
%
% \begin{macro}[int]{\zcheck}
%   \begin{syntax}
%     \cs{zcref}\meta{*}\oarg{options}\marg{labels}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcref { s O { } > { \SplitList { , } } m }
  { \zref@wrapper@babel \@@_zcref:nnn {#3} {#1} {#2} }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\@@_zcref:nnnn}
%   An intermediate internal function, which does the actual heavy lifting,
%   and places \Arg{labels} as first argument, so that it can be protected by
%   \cs{zref@wrapper@babel} in \cs{zcref}.
%   \begin{syntax}
%     \cs{@@_zcref:nnnn} \Arg{labels} \Arg{*} \Arg{options}
%   \end{syntax}
%    \begin{macrocode}
\seq_new:N \l_@@_zcref_labels_seq
\cs_new_protected:Npn \@@_zcref:nnn #1#2#3
  {
    \group_begin:
    \seq_set_split:Nnn \l_@@_zcref_labels_seq { } {#1}
    \@@_sort_labels:
    \seq_use:Nn \l_@@_zcref_labels_seq {,~}

    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
%
%
% \section{Sorting}
%
%
%    \begin{macrocode}

% TODO Stores whether this reference is to the page, or to the default
% counter, this should be moved to options.
\bool_new:N \l_@@_page_ref_bool

% Aux variables.
\tl_new:N \l_@@_label_type_a_tl
\tl_new:N \l_@@_label_type_b_tl
\tl_new:N \l_@@_label_counter_a_tl
\tl_new:N \l_@@_label_counter_b_tl
\tl_new:N \l_@@_label_withincnt_a_tl
\tl_new:N \l_@@_label_withincnt_b_tl
\tl_new:N \l_@@_label_withinval_a_tl
\tl_new:N \l_@@_label_withinval_b_tl


% TODO Stores whether sort priorities should be used or not.  This should be
% moved to options.  This is a way to enable/disable sort priority wholesale.
% Whatever we do, setting the sort priorities will not be convenient and will
% not be doable locally as an option, since it must be done ``per type'', so a
% way to handle the whole thing in one swoop is indeed needed.
\bool_new:N \l_@@_use_sort_prior_bool
\bool_set_true:N \l_@@_use_sort_prior_bool

% TODO The "priority" should be coming somehow from options, but this is not
% done yet, just set a temporary value to build one piece at a time.  Items
% with higher priority go to the top.
\int_new:N \l_@@_sort_prior_a_int
\int_new:N \l_@@_sort_prior_b_int

% Auxiliary variable for \cs{@@_sort_labels:}, stores the sequence that
% reference types appear in the label list supplied by the user in \cs{zcref}.
\seq_new:N \l_@@_label_types_seq

% Auxiliary variable for \cs{@@_sort_labels:}, signals if the sorting between
% two labels has been decided or not.
\bool_new:N \l_@@_sort_decided_bool

% Variant not provided by the kernel.
\cs_generate_variant:Nn \tl_reverse_items:n { V }

% Auxiliary function used to store ``new'' label types in
% \cs{l_@@_label_types_seq} as the sorting proceeds.  The reference type
% sequence of the labels list given by the user in \cs{zcref} is needed to
% have a sort criterion when the sort priority of different types is the same.
\cs_new_protected:Npn \@@_label_type_put_new_right:n #1
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \tl_if_empty:NF \l_@@_label_type_a_tl
      {
        \seq_if_in:NVF \l_@@_label_types_seq \l_@@_label_type_a_tl
          {
            \seq_put_right:NV
              \l_@@_label_types_seq \l_@@_label_type_a_tl
          }
      }
  }

\cs_new_protected:Npn \@@_sort_labels:
  {
    \seq_clear:N \l_@@_label_types_seq
    \seq_sort:Nn \l_@@_zcref_labels_seq
      {
        \zref@ifrefundefined {##1}
          {
            \zref@ifrefundefined {##2}
              {
                % Neither label is defined.
                \sort_return_same:
              }
              {
                % Possibly store new label type.
                \@@_label_type_put_new_right:n {##2}

                % The second label is defined, but the first isn't, bring the
                % second forward.
                \sort_return_swapped:
              }
          }
          {
            % Possibly store new label type.
            \@@_label_type_put_new_right:n {##1}

            \zref@ifrefundefined {##2}
              {
                % The first label is defined, but the second isn't, keep the
                % second behind.
                \sort_return_same:
              }
              {
                % The interesting case: both labels are defined. The reference
                % to the "default" property/counter or to the page are quite
                % different from our perspective, they rely on different
                % fields and even use different information for sorting (and
                % compressing), so we branch them here to specialized
                % functions.
                \bool_if:NTF \l_@@_page_ref_bool
                  { \@@_sort_page_aux:nn {##1} {##2} }
                  { \@@_sort_default_aux:nn {##1} {##2} }
              }
          }
      }
  }

\cs_new_protected:Npn \@@_sort_default_aux:nn #1#2
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_type_b_tl
      { \zref@extractdefault {#2} { zc@type } { \c_empty_tl } }
    \bool_case_true:nF
      {
        % The second label has a type, but the first doesn't...
        {
          \tl_if_empty_p:N \l_@@_label_type_a_tl &&
          ! \tl_if_empty_p:N \l_@@_label_type_b_tl
        }
        % ... bring the second forward.
        { \sort_return_swapped: }

        % Both labels have a type...
        {
          ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
          ! \tl_if_empty_p:N \l_@@_label_type_b_tl
        }
        {
          \tl_if_eq:NNTF \l_@@_label_type_a_tl \l_@@_label_type_b_tl
            {
              % ... and it's the same type.

              \tl_set:Nx \l_@@_label_withincnt_a_tl
                { \zref@extractdefault {#1} { zc@withincnt } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_withincnt_a_tl
                { \tl_reverse_items:V \l_@@_label_withincnt_a_tl }
              \tl_set:Nx \l_@@_label_withincnt_b_tl
                { \zref@extractdefault {#2} { zc@withincnt } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_withincnt_b_tl
                { \tl_reverse_items:V \l_@@_label_withincnt_b_tl }
              \tl_set:Nx \l_@@_label_withinval_a_tl
                { \zref@extractdefault {#1} { zc@withinval } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_withinval_a_tl
                { \tl_reverse_items:V \l_@@_label_withinval_a_tl }
              \tl_set:Nx \l_@@_label_withinval_b_tl
                { \zref@extractdefault {#2} { zc@withinval } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_withinval_b_tl
                { \tl_reverse_items:V \l_@@_label_withinval_b_tl }

              \bool_set_false:N \l_@@_sort_decided_bool
              \tl_clear:N \l_tmpa_tl
              \tl_clear:N \l_tmpb_tl
              \bool_until_do:Nn \l_@@_sort_decided_bool
                {
                  \tl_set:Nx \l_tmpa_tl
                    { \tl_head:N \l_@@_label_withincnt_a_tl }
                  \tl_set:Nx \l_tmpb_tl
                    { \tl_head:N \l_@@_label_withincnt_b_tl }

                  \bool_case_true:nF
                    {
                      % Both are empty, meaning: neither labels have any
                      % (further) ``within counters'' (left).
                      {
                        \tl_if_empty_p:V \l_tmpa_tl &&
                        \tl_if_empty_p:V \l_tmpb_tl
                      }
                      {
                        \exp_args:Nxx \tl_if_eq:nnTF
                          { \zref@extractdefault {#1} { counter } { } }
                          { \zref@extractdefault {#2} { counter } { } }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \int_compare:nNnTF
                              { \zref@extractdefault {#1} { zc@cntval } {-1} }
                                >
                              { \zref@extractdefault {#2} { zc@cntval } {-1} }
                              { \sort_return_swapped: }
                              { \sort_return_same:    }
                          }
                          {
                            \msg_warning:nnnn { zref-clever }
                              { counters-not-nested } {#1} {#2}
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                      }

                      % `a' is empty (and `b' is not), meaning: `b' is
                      % (possibly) nested in `a'.
                      { \tl_if_empty_p:V \l_tmpa_tl }
                      {
                        \tl_set:Nx \l_tmpa_tl
                          { {\zref@extractdefault {#1} { counter } { }} }
                        \exp_args:NNx \tl_if_in:NnTF
                          \l_@@_label_withincnt_b_tl { \l_tmpa_tl }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                          {
                            \msg_warning:nnnn { zref-clever }
                              { counters-not-nested } {#1} {#2}
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                      }

                      % `b' is empty (and `a' is not), meaning: `a' is
                      % (possibly) nested in `b'.
                      { \tl_if_empty_p:V \l_tmpb_tl }
                      {
                        \tl_set:Nx \l_tmpb_tl
                          { {\zref@extractdefault {#2} { counter } { }} }
                        \exp_args:NNx \tl_if_in:NnTF
                          \l_@@_label_withincnt_a_tl { \l_tmpb_tl }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_swapped:
                          }
                          {
                            \msg_warning:nnnn { zref-clever }
                              { counters-not-nested } {#1} {#2}
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                      }
                    }
                    % None of the above matched, hence neither is empty,
                    % meaning: we can (possibly) compare the values of the
                    % current within counter in the loop, if they are equal,
                    % we are still in the loop, if they are not, a sorting
                    % decision can be made directly.
                    {
                      \tl_if_eq:NNTF \l_tmpa_tl \l_tmpb_tl
                        {
                          \int_compare:nNnTF
                            { \tl_head:N \l_@@_label_withinval_a_tl }
                              =
                            { \tl_head:N \l_@@_label_withinval_b_tl }
                            {
                              \tl_set:Nx \l_@@_label_withincnt_a_tl
                                { \tl_tail:N \l_@@_label_withincnt_a_tl }
                              \tl_set:Nx \l_@@_label_withincnt_b_tl
                                { \tl_tail:N \l_@@_label_withincnt_b_tl }
                              \tl_set:Nx \l_@@_label_withinval_a_tl
                                { \tl_tail:N \l_@@_label_withinval_a_tl }
                              \tl_set:Nx \l_@@_label_withinval_b_tl
                                { \tl_tail:N \l_@@_label_withinval_b_tl }
                            }
                            {
                              \bool_set_true:N \l_@@_sort_decided_bool
                              \int_compare:nNnTF
                                { \tl_head:N \l_@@_label_withinval_a_tl }
                                  >
                                { \tl_head:N \l_@@_label_withinval_b_tl }
                                { \sort_return_swapped: }
                                { \sort_return_same:    }
                            }
                        }
                        {
                          \msg_warning:nnnn { zref-clever }
                            { counters-not-nested } {#1} {#2}
                          \bool_set_true:N \l_@@_sort_decided_bool
                          \sort_return_same:
                        }

                    }
                }
            }
            {
              % ... and they are different types.

              % TODO Ditto.
              \int_set:Nn \l_@@_sort_prior_a_int { 0 }
              \int_set:Nn \l_@@_sort_prior_b_int { 0 }

              \bool_case_true:nF
                {
                  {
                    \l_@@_use_sort_prior_bool &&
                    \int_compare_p:nNn
                      { \l_@@_sort_prior_a_int } >
                      { \l_@@_sort_prior_b_int }
                  }
                  { \sort_return_same: }
                  {
                    \l_@@_use_sort_prior_bool &&
                    \int_compare_p:nNn
                      { \l_@@_sort_prior_a_int } <
                      { \l_@@_sort_prior_b_int }
                  }
                  { \sort_return_swapped: }
                }
                {
                  % Sort priorities are equal: the type that occurs first in
                  % \meta{labels}, as given by the user, is kept (or brought)
                  % forward.
                  \seq_map_inline:Nn \l_@@_label_types_seq
                    {
                      \tl_if_eq:NnTF \l_@@_label_type_a_tl {##1}
                        { \seq_map_break:n { \sort_return_same: } }
                        {
                          \tl_if_eq:NnT \l_@@_label_type_b_tl {##1}
                            { \seq_map_break:n { \sort_return_swapped: } }
                        }
                    }

                }
            }
        }
      }
      {
        % If none of the above cases match, we have either: i) neither of the
        % labels has a type; or ii) the first label has a type, but the second
        % doesn't.  In both cases the answer is:
        \sort_return_same:
      }
  }

\msg_new:nnn { zref-clever } { counters-not-nested }
  {
    Counters~not~nested~for~labels~'#1'~and~'#2' \iow_newline:
    on~input~line~\msg_line_number:.
  }

\cs_new_protected:Npn \@@_sort_page_aux:nn #1#2
  {
    % TODO Temporary.
    \sort_return_same:
  }


%    \end{macrocode}
%
%
%
%
% \section{Compressing}
%
% About possible alternatives to signal compression inhibition for individual
% labels, see \url{https://tex.stackexchange.com/q/611370} (thanks Enrico
% Gregorio, Phelype Oleinik, and Steven B.\ Segletes).  All in all, and
% rethinking this here, probably the best is to receive an optional argument
% with the label(s) not to be compressed.  This is a repetition, but keeps the
% syntax ``clean'', and I do expect the use case to be rare enough that this
% inconvenience is not too large.
%
%
%
%
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \PrintIndex
%
% \end{implementation}
%
