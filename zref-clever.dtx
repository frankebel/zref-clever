% \iffalse meta-comment
%
% File: zref-clever.dtx
%
% This file is part of the LaTeX package "zref-clever".
%
% Copyright (C) 2021  Gustavo Barros
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file:
%
%    https://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
%
% This work is "maintained" (as per LPPL maintenance status) by
% Gustavo Barros.
%
% This work consists of the files zref-clever.dtx,
%                                 zref-clever.ins,
%                                 zref-clever.tex,
%                                 zref-clever-code.tex,
%           and the derived files zref-clever.sty and
%                                 zref-clever.pdf,
%                                 zref-clever-code.pdf.
%
% The released version of this package is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the package can be found at
%
%    https://github.com/gusbrs/zref-clever
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}
% Have \GetFileInfo pick up date and version data
\usepackage{zref-clever}
\NewDocumentCommand\opt{m}{\texttt{#1}}
\MakeShortVerb{\|}
\begin{document}
  \DocInput{zref-clever.dtx}
\end{document}
%</driver>
% \fi
%
%
% \begin{documentation}
%
%
% \end{documentation}
%
%
%
% \begin{implementation}
%
% \section{Initial setup}
%
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=zrefclever>
%    \end{macrocode}
%
%
%
% Identify the package.
%    \begin{macrocode}
\ProvidesExplPackage {zref-clever} {2021-08-25} {0.1.0-alpha}
  {Do-what-I-mean cross-references based on zref}
%    \end{macrocode}
%
% \section{Dependencies}
%
%    \begin{macrocode}
\RequirePackage { zref-base }
\RequirePackage { zref-user }
\RequirePackage { translations }
%    \end{macrocode}
%
%
%
% \section{\pkg{zref} setup}
%
% We are (mostly) interested in three basic label elements: the reference
% itself, the page, and the counter.  The `page' and `counter' are
% respectively handled by modules \pkg{zref-base} and \pkg{zref-counter}.  The
% \pkg{zref-abspage} also provides the `abspage' property which gives us a
% safe and easy way to sort labels on page references.  But the reference
% itself, stored by \pkg{zref} in the `default' field, is somewhat a disputed
% real estate.  In particular, the use of \cs{labelformat} will include there
% the reference ``prefix'' and complicate the job we are trying to do here.
% Hence, we isolate \cs{the}\meta{counter} and store it ``clean'' in
% \texttt{zc@thecnt} for reserved use.  We also store the ``type'' of the
% label at this point (see Section~\ref{sec:reference-types}).
%
% However, the \pkg{zref-abspage} module is very simple, but loads
% \pkg{atbegshi}, which is no longer needed with a recent kernel, which we
% require here anyway.  So we can spare this additional dependency by
% providing the property internally.  Since only \pkg{zref-counter} remains,
% which is also trivial, we do that too, and thus ensure that all needed data
% is stored in ``internal'' properties.  The only exception is the
% \texttt{page} property, which is available by default (no extra module
% required), and is not tampered with by \cs{labelformat}, as the
% \texttt{default} property does.  Another exception which we don't need to
% handle at the data provision side, but need to cater for in the retrieval
% side, is the \texttt{url}/\texttt{urluse} property from \pkg{zref-xr}
% module, which is added to the labels imported from external documents, and
% needed to construct hyperlinks to them.
%
%
%    \begin{macrocode}
\zref@newprop { zc@counter } { \@currentcounter }
\zref@addprop \ZREF@mainlist { zc@counter }
\zref@newprop { zc@type }
  { \exp_args:NNo \prop_item:Nn \l_@@_counter_type_prop { \@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@type }
%    \end{macrocode}
%
% From the definition of \cs{@currentlabel} done inside \cs{refstepcounter} in
% 'texdoc source2e', section 'ltcounts.dtx'.  We just drop the \cs{p@...}
% prefix.
%    \begin{macrocode}
\zref@newprop { zc@thecnt } { \cs:w the \@currentcounter \cs_end: }
\zref@addprop \ZREF@mainlist { zc@thecnt }
%    \end{macrocode}
%
% However, the moment where the label is set is a privileged one, because at
% this point we have a lot of raw information available.  Information which
% may be difficult to retrieve later on by parsing the reference printed value
% of the counter, which we stored in \texttt{zc@thecnt} above.  Hence, we
% seize the opportunity to store some of that information in a way which eases
% significantly the task of processing the reference later on: i) the counter
% \emph{value}, as a number; ii) the counter values of the set of counters
% which may trigger a reset of the current counter.
%
% The first one is trivial, \cs{c@}\meta{counter} contains the counter's
% numerical value (see `texdoc source2e', section `ltcounts.dtx'), we just
% store it in \texttt{zc@cntval}.
%    \begin{macrocode}
\zref@newprop { zc@cntval } [0] { \int_use:c { c@\@currentcounter } }
\zref@addprop \ZREF@mainlist { zc@cntval }
%    \end{macrocode}
%
% And we need the same for the page and abspage.
%    \begin{macrocode}
\zref@newprop* { zc@pgval } [0] { \int_use:c { c@page } }
\zref@addprop \ZREF@mainlist { zc@pgval }
\int_new:N \g_@@_abspage_int
\AddToHook { shipout/before } { \int_gincr:N \g_@@_abspage_int }
\zref@newprop* { zc@abspg } [0] { \int_use:N \g_@@_abspage_int }
\zref@addprop \ZREF@mainlist { zc@abspg }
%    \end{macrocode}
%
% The second one is trickier.  For starters, the counters which may reset the
% current counter are not retrievable from the counter itself, because this
% information is stored with the counter that does the resetting, not with the
% one that gets reset (the list is stored in \cs{cl@}\meta{counter} with
% format |\@elt{countera}\@elt{counterb}\@elt{counterc}|, again see section
% `ltcounts.dtx' in `source2e').  Besides, there may be a chain of resetting
% counters, which must be taken into account.  The procedure below examines a
% set of counters, those included in \cs{l_@@_counter_resetters_seq}, and for
% each counter retrieves its ``enclosing counters'' recursively.  There is one
% relevant caveat to this procedure: \cs{l_@@_counter_resetters_seq} is
% populated by hand with the ``usual suspects'', there is no way (that I know
% of) to ensure it is exhaustive.  However, it is not that difficult to create
% a reasonable ``usual suspects'' list which, of course, should include the
% counters for the sectioning commands, to start with, and it is easy to add
% more counters to this list if needed.
%
% \begin{macro}[EXP]
%   {
%     \@@_get_enclosing_counters:n,
%     \@@_get_enclosing_counters_value:n
%   }
% Recursively generate a \emph{sequence} of ``enclosing counters'' and values,
% for a given \Arg{counter} and leave it in the input stream.  These functions
% must be expandable, since they get called from \cs{zref@newprop} and are the
% ones responsible for generating the desired information when the label is
% being set.  Note that the order in which we are getting this information is
% reversed, since we are navigating the counter reset chain bottom-up.  But it
% is very hard to do otherwise here where we need expandable functions, and
% easy to handle at the reading side.
%    \begin{macrocode}
\cs_new:Npn \@@_get_enclosing_counters:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \@@_counter_reset_by:n {#1} }
        \@@_get_enclosing_counters:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
\cs_new:Npn \@@_get_enclosing_counters_value:n #1
  {
    \cs_if_exist:cT { c@ \@@_counter_reset_by:n {#1} }
      {
        { \int_use:N \cs:w c@ \@@_counter_reset_by:n {#1} \cs_end: }
        \@@_get_enclosing_counters_value:e
          { \@@_counter_reset_by:n {#1} }
      }
  }
%    \end{macrocode}
% Both \texttt{e} and \texttt{f} expansions work for this particular recursive
% call.  For the time being, I'll stay with the \texttt{e} variant, since
% conceptually it is what I want (\texttt{x} itself is not expandable), and
% this package is unlikely to be used within the context of older kernels for
% which the performance penalty of the \texttt{e} expansion would ensue (see
% also \url{https://tex.stackexchange.com/q/611370/#comment1529282_611385},
% thanks Enrico Gregorio, aka `egreg').
%    \begin{macrocode}
\cs_generate_variant:Nn \@@_get_enclosing_counters:n { V , e }
\cs_generate_variant:Nn \@@_get_enclosing_counters_value:n { V , e }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]
%   {
%     \@@_counter_reset_by:n,
%     \@@_counter_reset_by_aux:nn,
%     \@@_counter_reset_by_auxi:nnn
%   }
% Auxiliary functions for \cs{@@_get_enclosing_counters:n} and
% \cs{@@_get_enclosing_counters_value:n}.  They are broken in parts to be able
% to use the expandable mapping functions.  In particular
% \cs{@@_counter_reset_by:n} leaves in the stream the ``enclosing counter''
% which resets \Arg{counter}.
%    \begin{macrocode}
\cs_new:Npn \@@_counter_reset_by:n #1
  {
    \bool_if:nTF
      { \prop_if_in_p:Nn \l_@@_counter_resetby_prop {#1} }
      { \prop_item:Nn  \l_@@_counter_resetby_prop {#1} }
      {
        \seq_map_tokens:Nn \l_@@_counter_resetters_seq
          { \@@_counter_reset_by_aux:nn {#1} }
      }
  }
\cs_new:Npn \@@_counter_reset_by_aux:nn #1#2
  {
    \cs_if_exist:cT { c@ #2 }
      {
        \tl_if_empty:cF { cl@ #2 }
          {
            \tl_map_tokens:cn { cl@ #2 }
              { \@@_counter_reset_by_auxi:nnn {#2} {#1} }
          }
      }
  }
\cs_new:Npn \@@_counter_reset_by_auxi:nnn #1#2#3
  {
    \str_if_eq:nnT {#2} {#3}
      { \tl_map_break:n { \seq_map_break:n {#1} } }
  }
%    \end{macrocode}
% \end{macro}
%
% Finally, add \texttt{zc@enclcnt} and \texttt{zc@enclval} to \pkg{zref}'s
% \texttt{main} property list.
%    \begin{macrocode}
\zref@newprop { zc@enclcnt }
  { \@@_get_enclosing_counters:V \@currentcounter }
\zref@newprop { zc@enclval }
  { \@@_get_enclosing_counters_value:V \@currentcounter }
\zref@addprop \ZREF@mainlist { zc@enclcnt }
\zref@addprop \ZREF@mainlist { zc@enclval }
%    \end{macrocode}
%
%
%
% A previous version of the same task.  Easier to implement, hence possibly
% more robust (for me to maintain, that is\dots{}), but which required to
% assess the state of the reset counters at \texttt{begindocument}, so does
% not get mid-document changes.  Keep it around for the time being, in case we
% face trouble with the expandable version.  The procedure here examines a set
% of counters, those included in \cs{g_@@_resetters_seq}, and for each counter
% each of those reset, defines a \texttt{tl} variable with name
% \cs{g_@@_counter_\meta{counter}_enclosing_tl} storing the value of its
% ``enclosing counter''.  These \texttt{tl} variables are then used by
% \cs{@@_get_enclosing_counters_value_old:n} to store the desired information
% when the label is actually set.
% \begin{verbatim}
% \cs_new:Npn \@@_get_enclosing_counters_value_old:n #1
%   {
%     \bool_lazy_and:nnT
%       { \tl_if_exist_p:c { g_@@_counter_ \tl_use:N #1 _enclosing_tl } }
%       {
%         \cs_if_exist_p:c
%           { c@ \use:c { g_@@_counter_ \tl_use:N #1 _enclosing_tl } }
%       }
%       {
%         { \int_use:c { c@ \use:c { g_@@_counter_ \tl_use:N #1 _enclosing_tl } } }
%         \@@_get_enclosing_counters_value_old:n
%           { \use:c { g_@@_counter_ \tl_use:N #1 _enclosing_tl } }
%       }
%   }
% \end{verbatim}
% Map through \cs{g_@@_resetters_seq} defining \texttt{tl} variables storing,
% for each counter that may be reset, the ``enclosing counter'' which may do
% so.
% \begin{verbatim}
% \cs_new:Npn \@@_set_enclosing_counters:
%   {
%     \group_begin:
%       \seq_map_inline:Nn \g_@@_resetters_seq
%         {
%           \cs_if_exist:cT { c@ ##1 }
%             {
%               \cs_set:Npn \@@_elt_aux:n ####1
%                 {
%                   \tl_if_exist:cF { g_@@_counter_ ####1 _enclosing_tl }
%                     { \tl_gset:cx { g_@@_counter_ ####1 _enclosing_tl } {##1} }
%                 }
%               \cs_set_eq:NN \@elt \@@_elt_aux:n
%               \use:c { cl@ ##1 }
%             }
%         }
%     \group_end:
%   }
% \end{verbatim}
% And run it at \texttt{begindocument}.
% \begin{verbatim}
% \AddToHook { begindocument } { \@@_set_enclosing_counters: }
% \end{verbatim}
%
%
% \begin{macro}[EXP]{\@@_page_numbering:}
%   Another piece of information we need is the page numbering format being
%   used by \cs{thepage}, so that we know when we can (or not) group a set of
%   page references in a range.  Unfortunately, the ``page'' is not a typical
%   counter in ways which complicates things.  First, it does commonly get
%   reset along the document, not necessarily by the usual counter reset
%   chains, but rather with \cs{pagenumbering} or variations thereof.  Second,
%   the format of the page number commonly changes in the document (roman,
%   arabic, etc.), not necessarily, though usually, together with a reset.
%   Trying to ``parse'' \cs{thepage} to retrieve such information is bound to
%   go wrong: we don't know, and can't know, what is within that macro, and
%   that's the business of the user, or of the documentclass, or of the loaded
%   packages.  The technique used by \pkg{cleveref}, which we borrow here, is
%   simple and smart: store with the label what \cs{thepage} would return, if
%   the counter \cs{c@page} was ``1''.  That does not allow us to \emph{sort}
%   the references, luckily however, we have \texttt{abspage} which can be
%   used for that.  But we can decide whether two labels can be compressed or
%   not based on this format: if they are identical, we can compress them,
%   otherwise, we can't.  \pkg{cleveref} actually resets the counter to ``1''
%   with \cs{setcounter}, which is a global operation, and restores it in
%   sequence.  Here we adopt a more cautious approach of locally redefining
%   \cs{c@page} to return ``1'', thus avoiding any global spillovers of this
%   trick.  Since this operation is not expandable we cannot run it directly
%   from the property definition.  Hence, we use a shipout hook, and set
%   \cs{g_@@_page_format_tl}, which can then be retrieved by the starred
%   definition of |\zref@newprop*{zc@pgfmt}|.
%    \begin{macrocode}
\tl_new:N \g_@@_page_format_tl
\cs_new_protected:Npx \@@_page_format_aux: { \int_eval:n { 1 } }
\AddToHook { shipout / before }
  {
    \group_begin:
    \cs_set_eq:NN \c@page \@@_page_format_aux:
    \exp_args:NNx \tl_gset:Nn \g_@@_page_format_tl { \thepage }
    \group_end:
  }
\zref@newprop* { zc@pgfmt } { \g_@@_page_format_tl }
\zref@addprop \ZREF@mainlist { zc@pgfmt }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Plumbing}
%
% \subsection{Reference Types}
% \label{sec:reference-types}
%
% Let's start with a bit of terminology, to avoid confusion.  A ``reference
% type'' is the basic \pkg{zref-clever} setup unit for specifying how a
% cross-reference group of a certain kind is to be typeset.  Though, usually,
% it will have the same name as the underlying \LaTeX{} \emph{counter}, they
% are conceptually different.  \pkg{zref-clever} defines \emph{reference
% types} and an association between each \emph{counter} and its \emph{type},
% it does not define the counters themselves, which are defined by your
% document.  One \emph{reference type} can be associated with one or more
% \emph{counters}, but each counter can only have one \emph{type}
% (locally\dots{}), and that determines how the reference is typeset.
% References to different \emph{counters} of the same \emph{type} are grouped
% together, and treated alike by \pkg{zref-clever}.  A \emph{reference type}
% may exist even when the \emph{counter} it is associated with is not actually
% defined, and this inconsequential.  In practice, the contrary may also
% happen, a \emph{counter} may be defined but we have no \emph{type} for it,
% but this must be handled by \pkg{zref-clever} as a ``missing type'' error
% (at least, if we try to refer to it).
%
% A \emph{reference type} can be associated with multiple counters because we
% may want to refer to different document elements, with different
% \emph{counters}, with a single name, as a single \emph{type}.  One prominent
% case of this are sectioning commands.  \cs{section}, \cs{subsection}, and
% \cs{subsubsection} have each their counter, but we'd like to refer to all of
% them by ``section''.  The same for \cs{paragraph} and \cs{subparagraph}.
% There is one relevant subtlety to grouping multiple counters under the same
% type: in order for us to be able to meaningfully sort and compress this
% group, the set of counters contained therein cannot be arbitrary.  Indeed,
% all of the \emph{counters} grouped in the same \emph{type} must belong to
% the same counter reset chain, and must be nested within each other (they
% cannot even just share the same parent).  The need to check this (?) has
% some implications to the data we store in the label.  Since we cannot do
% this verification when we set up the \emph{reference type}, because at this
% point we could only check existing counters, and they may be defined
% ``later'' or ``never'', the counter reset chain must be stored (names and
% values) with the label itself (this is done in properties
% \texttt{zc@enclcnt} and \texttt{zc@enclval}).
%
%
% There are also cases in which we may want to use different \emph{reference
% types} to refer to document objects sharing the same \emph{counter}.
% Prominently, the environments created with the kernel's \cs{newtheorem}
% command and the \cs{appendix}, but we'll try to consider, and handle, the
% case generally.
%
% Regarding \cs{newtheorem}, \pkg{cleveref} deals with this by redefining its
% internals and retrieving the environment's name, to infer the type and do an
% ``automatic definition'' of theorem-like environments with a reasonable
% default.  But even then, it can only provide the singular form of the
% cross-reference name, and if the plural is ever needed, the name has to be
% provided manually anyway.  It also imposes the restriction of
% \cs{newtheorem} only being used in the preamble, which in itself would be
% good practice, but \cs{newtheorem} is documented to be allowed anywhere in
% the document (see \texttt{texdoc source2e}, section `ltthm.dtx', comment at
% the definition of \cs{newtheorem}).  And the calls to \cs{newtheorem} must
% also come after \pkg{cleveref} is loaded.  And for this to work, either
% \pkg{ntheorem} or \pkg{amsthm} must be loaded (as stated in the ``Non-Bugs''
% section of the documentation).  This automatism is, of course, a good thing,
% but the restrictions are considerable.
%
% A related mechanism \pkg{cleveref} provides for overriding individual labels
% is by adding optional arguments to both \cs{label} and \cs{refstepcounter}
% which receives a ``counter override label type'' and stores that
% \emph{instead} of regular counter with the \cs{newlabel} in the \file{.aux}
% file.  This affords for a fully manual ``one time'' counter override for
% that particular label.
%
% Another relevant use case of the same general problem of different types for
% the same counter is the \cs{appendix} which in some document classes,
% including the standard ones, change the sectioning commands looks but, of
% course, keep using the same counter (\file{book.cls} and \file{report.cls}
% reset counters \texttt{chapter} and \texttt{section} to 0, change
% \cs{@chapapp} to use \cs{appendixname} and use \cs{@Alph} for
% \cs{thechapter}; \file{article.cls} resets counters \texttt{section} and
% \texttt{subsection} to 0, and uses \cs{@Alph} for \cs{thesection};
% \file{memoir.cls}, \file{scrbook.cls} and \file{scrarticle.cls} do the same
% as their corresponding standard classes, and sometimes a little more, but
% what interests us here is pretty much the same; see also the \pkg{appendix}
% package).
%
% All in all, and since \pkg{zref} spares us of the need to redefine such core
% commands, I think a more general approach, even if a little less automatic,
% is the best for us here.  \pkg{zref}'s data flexibility also helps us in
% this.  As it turns out, we can also use \cs{l_@@_counter_type_prop} for this
% purpose (hence it was made locally scoped).  And we do so by storing, with
% the label, the ``type'' value of the ``counter'' key in
% \cs{l_@@_counter_type_prop} when the label is set.  If it was not for the
% need to distinguish different \emph{types} of the same \emph{counter} this
% information could be kept in the variable alone, but since we need to
% leverage other document information in the process, storing it with the
% label is not a bad idea.  And it makes some things simpler even for the
% general case, since we don't have to control whether there is a type
% property in the label or not.  (The property would have to be included
% anyway, since the \cs{appendix} case offers little in terms of hooks or
% grouping, the only choice is whether to populate this property for every
% label or just for the ones we'd like to ``override'').  With that in hand,
% \cs{l_@@_counter_type_prop} can be set at appropriate times, and the
% information gets stored in the label.  For environments, it is trivial with
% a hook to \texttt{env/\meta{env}/begin}.  This can be used for
% \cs{newtheorem} environments to start with.  In principle, with a recent
% kernel, a hook to \cs{appendix} could also be used, otherwise some (simple)
% user intervention may be required.
%
% The use case for the optional argument for \cs{label} and
% \cs{refstepcounter} I do not quite grasp, and it does introduce ample
% opportunity for users to shoot themselves in the foot.  Still, an equivalent
% could be provided by, for example, defining a document command
% \cs{zclabel}\oarg{type}\marg{label} which makes a group, sets the type
% variable, and calls \cs{zlabel} with \meta{label}.  Anyway, for the time
% being, I'll provide the higher level infrastructure, covering
% \cs{newtheorem} and \cs{appendix}, and only introduce a manual override of
% the sort if the need indeed arises and is well justified.
%
%
%
% \subsection{Translations aux}
%
% Just some wrappers around \pkg{translations} functions, so that we
% can generate variants with expansion control for arguments.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_translation:nn #1#2 { p , TF }
  {
    \IfTranslation {#1} {#2}
      { \prg_return_true:  }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn \@@_if_translation:nn { xx } { p , TF }
\cs_new_protected:Npn \@@_get_translation_for:nnn #1#2#3
  { \SaveTranslationFor{#1}{#2}{#3} }
\cs_generate_variant:Nn \@@_get_translation_for:nnn { nxx }
\cs_new_protected:Npn \@@_declare_translation:nnn #1#2#3
  { \declaretranslation {#1} {#2} {#3} }
\cs_generate_variant:Nn \@@_declare_translation:nnn { xxn }
%    \end{macrocode}
%
%
% For use in dictionary files.
%    \begin{macrocode}

% The dictionary file commands cannot rely on expl3 syntax, so we define
% ``document'' ones.
% <string><transl>
\NewDocumentCommand \zcDicDefaultTransl { m m }
  { \ProvideDictTranslation { zrefclever-default- #1 } {#2} }

% <type><string><transl>
\NewDocumentCommand \zcDicTypeTransl { m m m }
  { \ProvideDictTranslation { zrefclever-type- #1 - #2 } {#3} }

% <lang><string><transl>
\cs_new_protected:Npn \@@_add_default_translation:nnn #1#2#3
  { \addtranslation {#1} { zrefclever-default- #2 } {#3} }

% <lang><type><string><transl>
\cs_new_protected:Npn \@@_add_type_translation:nnnn #1#2#3#4
  { \addtranslation {#1} { zrefclever-type- #2 - #3 } {#4} }


%    \end{macrocode}
%
%
% \subsection{Type format}
%
%
% \subsubsection{\cs{zcRefTypeSetup}}
%
%
% \begin{variable}{\l_@@_ref_type_language_tl}
%   Variable storing the language and type to be used in \cs{zcRefTypeSetup}
%   and \cs{zcDeclareTranslations}.
%    \begin{macrocode}
\tl_new:N \l_@@_setup_language_tl
\tl_new:N \l_@@_setup_type_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\zcRefTypeSetup}
%   Provide \cs{zcRefTypeSetup}.
%    \begin{macrocode}
\NewDocumentCommand \zcRefTypeSetup { m m }
  {
    \prop_if_exist:cF { l_@@_type_ #1 _strings_prop }
      { \prop_new:c { l_@@_type_ #1 _strings_prop } }
    \tl_set:Nn \l_@@_setup_type_tl {#1}
    \keys_set:nn { zref-clever / typesetup } {#2}
  }
%    \end{macrocode}
% \end{macro}
%
%
%    \begin{macrocode}
\keys_define:nn { zref-clever / typesetup }
  {
    % A special convenience ``short'' way to set name strings.
    % Necessarily type-specific strings.
    name .code:n =
      {
        \int_case:nnF { \clist_count:n {#1} }
          {
            { 2 }
            {
              \clist_map_inline:nn
                {
                  name-sg ,
                  Name-sg ,
                  name-ab-sg ,
                  Name-ab-sg ,
                }
                {
                  \prop_put:cnx
                    { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                    { ##1 } { \clist_item:nn {#1} { 1 } }
                }
              \clist_map_inline:nn
                {
                  name-pl ,
                  Name-pl ,
                  name-ab-pl ,
                  Name-ab-pl ,
                }
                {
                  \prop_put:cnx
                    { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                    { ##1 } { \clist_item:nn {#1} { 2 } }
                }
            }

            { 4 }
            {
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { name-sg } { \clist_item:nn {#1} { 1 } }
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { name-ab-sg } { \clist_item:nn {#1} { 1 } }
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { name-pl } { \clist_item:nn {#1} { 2 } }
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { name-ab-pl } { \clist_item:nn {#1} { 2 } }
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { Name-sg } { \clist_item:nn {#1} { 3 } }
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { Name-ab-sg } { \clist_item:nn {#1} { 3 } }
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { Name-pl } { \clist_item:nn {#1} { 4 } }
              \prop_put:cnx
                { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
                { Name-ab-pl } { \clist_item:nn {#1} { 4 } }
            }
          }
          {
            \msg_warning:nnx { zref-clever } { type-name-length }
              { \clist_count:n {#1} }
          }
      } ,
    name .value_required:n = true ,
  }
\msg_new:nnn { zref-clever } { type-name-length }
  {
    Type~'name'~can~only~receive~2~or~4~values~\msg_line_context:.~
    Don't~know~what~to~do~with~#1.
  }

%    \end{macrocode}
%
%    \begin{macrocode}


% Not type-specific strings.
\clist_map_inline:nn
  {
    tpairsep ,
    tlistsep ,
    tlastsep ,
  }
  {
    \keys_define:nn { zref-clever / typesetup }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \msg_warning:nnn { zref-clever } { string-not-type-specific } {#1}
          } ,
      }
  }

% Possibly or necessarily type-specific strings.
\clist_map_inline:nn
  {
    % Possibly type-specific strings.
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    refpre ,
    refpos ,
    refpre-in ,
    refpos-in ,
    % Necessarily type-specific strings.
    name-sg ,
    name-pl ,
    Name-sg ,
    Name-pl ,
    name-ab-sg ,
    name-ab-pl ,
    Name-ab-sg ,
    Name-ab-pl ,
  }
  {
    \keys_define:nn { zref-clever / typesetup }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \prop_put:cnn
              { l_@@_type_ \l_@@_setup_type_tl _strings_prop }
              { #1 } {##1}
          } ,
      }
  }

\msg_new:nnn { zref-clever } { string-not-type-specific }
  {
    String~'#1'~is~not~type-specific~\msg_line_context:.~
    Set~it~in~'\exp_not:N \zcDeclareTranslations'~before~first~'type'~switch~
    or~as~package~option.
  }

%    \end{macrocode}

%
% \subsubsection{\cs{zcDeclareTranslations}}
%
%
% CHECK Should I make \zcDeclareTranslations preamble only? (I don't even know
% if the translations definitions are local or global, presumably local but, I
% don't think this needs to be used in the document body).
%
% \begin{macro}[int]{\zcDeclareTranslations}
%   Provide \cs{zcDeclareTranslations}.
%    \begin{macrocode}
\NewDocumentCommand \zcDeclareTranslations { m m }
  {
    \tl_set:Nn \l_@@_setup_language_tl {#1}
    \tl_clear:N \l_@@_setup_type_tl
    \keys_set:nn { zref-clever / translations } {#2}
  }
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\keys_define:nn { zref-clever / translations }
  {
    type .code:n =
      {
        \tl_if_empty:nTF {#1}
          { \tl_clear:N \l_@@_setup_type_tl }
          {
            \prop_if_exist:cF { l_@@_type_ #1 _strings_prop }
              { \prop_new:c { l_@@_type_ #1 _strings_prop } }
            \tl_set:Nn \l_@@_setup_type_tl {#1}
          }
      } ,
    type .value_required:n = true ,
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}

% Not type-specific strings.
\clist_map_inline:nn
  {
    tpairsep ,
    tlistsep ,
    tlastsep ,
  }
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \@@_declare_translation:xxn { \l_@@_setup_language_tl }
                  { zrefclever-default- #1 } {##1}
              }
              {
                \msg_warning:nnn { zref-clever }
                  { string-not-type-specific } { tpairsep }
              }
          } ,
      }
  }

% Possibly type-specific strings.
\clist_map_inline:nn
  {
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    refpre ,
    refpos ,
    refpre-in ,
    refpos-in ,
  }
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \@@_declare_translation:xxn { \l_@@_setup_language_tl }
                  { zrefclever-default- #1 } {##1}
              }
              {
                \@@_declare_translation:xxn { \l_@@_setup_language_tl }
                  { zrefclever-type- \l_@@_setup_type_tl - #1 } {##1}
              }
          } ,
      }
  }

% Necessarily type-specific strings.
\clist_map_inline:nn
  {
    name-sg ,
    name-pl ,
    Name-sg ,
    Name-pl ,
    name-ab-sg ,
    name-ab-pl ,
    Name-ab-sg ,
    Name-ab-pl ,
  }
  {
    \keys_define:nn { zref-clever / translations }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l_@@_setup_type_tl
              {
                \msg_warning:nnn { zref-clever }
                  { string-only-type-specific } {#1}
              }
              {
                \@@_declare_translation:xxn { \l_@@_setup_language_tl }
                  { zrefclever-type- \l_@@_setup_type_tl - #1 } {##1}
              }
          } ,
      }
  }

\msg_new:nnn { zref-clever } { string-only-type-specific }
  {
    No~type~specified~for~string~'#1'~\msg_line_context:.~
    Set~it~after~'type'~switch~or~in~'\exp_not:N \zcRefTypeSetup'.
  }

%    \end{macrocode}

%
%
% \subsection{Options}
%

% \subsubsection*{\opt{countertype} option}
%
% \begin{variable}{\l_@@_counter_type_prop}
%   Variable storing a mapping from ``counter'' to ``reference type''.
%    \begin{macrocode}
\prop_new:N \l_@@_counter_type_prop
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_prop_put_non_empty:Nnn #1#2#3
  {
    \tl_if_empty:nTF {#3}
      { \prop_remove:Nn #1 {#2} }
      { \prop_put:Nnn #1 {#2} {#3} }
  }
\keys_define:nn { zref-clever }
  {
    countertype .code:n =
      {
        \keyval_parse:nnn
          { \msg_warning:nnn { zref-clever } { countertype-requires-value } }
          { \@@_prop_put_non_empty:Nnn \l_@@_counter_type_prop }
          {#1}
      } ,
    countertype .value_required:n = true ,
    countertype .initial:n =
      {
        part          = part ,
        chapter       = chapter ,
        section       = section ,
        subsection    = section ,
        subsubsection = section ,
        paragraph     = paragraph ,
        subparagraph  = paragraph ,
        figure        = figure ,
        table         = table ,
        equation      = equation ,
        enumi         = item ,
        enumii        = item ,
        enumiii       = item ,
        enumiv        = item ,
      } ,
  }
\msg_new:nnn  { zref-clever } { countertype-requires-value }
  { The~'countertype'~key~'#1'~requires~a~value. }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{counterresetters} option}
%
% \begin{variable}{\l_@@_counter_resetters_seq}
%   Stores the list of counters which are potential ``enclosing counters'' for
%   other counters.
%    \begin{macrocode}
\seq_new:N \l_@@_counter_resetters_seq
%    \end{macrocode}
% \end{variable}
%
%
%    \begin{macrocode}
\keys_define:nn { zref-clever }
  {
    counterresetters .code:n =
      {
        \seq_set_from_clist:Nn \l_@@_counter_resetters_seq {#1}
      } ,
    counterresetters .initial:n =
      {
        part ,
        chapter ,
        section ,
        subsection ,
        subsubsection ,
        paragraph ,
        subparagraph ,
      },
    typesort .value_required:n = true ,
  }
%    \end{macrocode}
%
%
%
%
% \subsubsection*{\opt{counterresetby} option}
%
% \begin{variable}{\l_@@_counter_resetby_prop}
%   Variable storing a mapping from ``counter'' to the counter which resets
%   it.
%    \begin{macrocode}
\prop_new:N \l_@@_counter_resetby_prop
%    \end{macrocode}
% \end{variable}
%
%
%    \begin{macrocode}
\keys_define:nn { zref-clever }
  {
    counterresetby .code:n =
      {
        \keyval_parse:nnn
          { \msg_warning:nnn { zref-clever } { counterresetby-requires-value } }
          { \@@_prop_put_non_empty:Nnn \l_@@_counter_resetby_prop }
          {#1}
      } ,
    counterresetby .value_required:n = true ,
    counterresetby .initial:n =
      {
%    \end{macrocode}
% The counters for the \texttt{enumerate} environment do not use the regular
% counter machinery for resetting on each level, but are nested nevertheless
% by other means, treat them as exception.  TODO This list should probably be
% extended for `enumitem', conditioned on it being loaded.
%    \begin{macrocode}
        enumii  = enumi   ,
        enumiii = enumii  ,
        enumiv  = enumiii ,
      } ,
  }
\msg_new:nnn  { zref-clever } { counterresetby-requires-value }
  { The~'counterresetby'~key~'#1'~requires~a~value. }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{ref} option}

% Stores whether this reference is to the page, or to the default counter.
%    \begin{macrocode}
\tl_new:N \l_@@_ref_property_tl
\bool_new:N \l_@@_page_ref_bool
\keys_define:nn { zref-clever }
  {
    ref .choice: ,
    ref / zc@thecnt .code:n =
      {
        \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt }
        \bool_set_false:N \l_@@_page_ref_bool
      } ,
    ref / page .code:n =
      {
        \tl_set:Nn \l_@@_ref_property_tl { page }
        \bool_set_true:N \l_@@_page_ref_bool
      } ,
    ref / title .code:n =
      {
        \AddToHook { begindocument }
          {
            \@ifpackageloaded { zref-titleref }
              {
                \tl_set:Nn \l_@@_ref_property_tl { title }
                \bool_set_false:N \l_@@_page_ref_bool
              }
              {
                \msg_warning:nn { zref-clever } { missing-zref-titleref }
                \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt }
                \bool_set_false:N \l_@@_page_ref_bool
              }
          }
      } ,
    ref .initial:n = zc@thecnt ,
    ref .value_required:n = true ,
    page .meta:n = { ref = page },
    page .value_forbidden:n = true ,
  }

\AddToHook { begindocument }
  {
    \@ifpackageloaded { zref-titleref }
      {
        \keys_define:nn { zref-clever }
          {
            ref / title .code:n =
              {
                \tl_set:Nn \l_@@_ref_property_tl { title }
                \bool_set_false:N \l_@@_page_ref_bool
              }
          }
      }
      {
        \keys_define:nn { zref-clever }
          {
            ref / title .code:n =
              {
                \msg_warning:nn { zref-clever } { missing-zref-titleref }
                \tl_set:Nn \l_@@_ref_property_tl { zc@thecnt }
                \bool_set_false:N \l_@@_page_ref_bool
              }
          }
      }
  }

\msg_new:nnn { zref-clever } { missing-zref-titleref }
  {
    Option~'ref=title'~requested~\msg_line_context:.~
    But~package~'zref-titleref'~is~not~loaded,~falling-back~to~default~'ref'.
  }

\msg_new:nnn { zref-clever } { prop-not-defined }
  {
    Property~'#1'~undefined~\msg_line_context:.~
    Falling-back~to~default~'ref'.
  }

%    \end{macrocode}
%
% Currently, I have restricted `ref=' to these two (or three) alternatives,
% but there might be a case for making this more flexible.  The infrastructure
% can already handle receiving an arbitrary property, as long as one is
% satisfied with sorting and compressing from the default counter.  If more
% flexibility is granted, one thing \emph{must} be handled at this point: the
% existence of the property itself, as far as \pkg{zref} is concerned.  This
% because typesetting relies on the check \cs{zref@ifrefcontainsprop}, which
% \emph{presumes} the property is defined and silently expands the \emph{true}
% branch if it is not (see \url{https://github.com/ho-tex/zref/issues/13},
% thanks Ulrike Fischer).  Therefore, before adding anything to
% \cs{l_@@_ref_property_tl}, check if first here with
% \cs{zref@ifpropundefined}: close it at the door.
%
%
% \subsubsection*{\opt{typeset} option}

%    \begin{macrocode}
\bool_new:N \l_@@_typeset_ref_bool
\bool_new:N \l_@@_typeset_name_bool
\keys_define:nn { zref-clever }
  {
    typeset .choice: ,
    typeset / both .code:n =
      {
        \bool_set_true:N \l_@@_typeset_ref_bool
        \bool_set_true:N \l_@@_typeset_name_bool
      } ,
    typeset / ref .code:n =
      {
        \bool_set_true:N \l_@@_typeset_ref_bool
        \bool_set_false:N \l_@@_typeset_name_bool
      } ,
    typeset / name .code:n =
      {
        \bool_set_false:N \l_@@_typeset_ref_bool
        \bool_set_true:N \l_@@_typeset_name_bool
      } ,
    typeset .initial:n = both ,
    typeset .value_required:n = true ,

    name .meta:n = { typeset = name },
    name .value_forbidden:n = true ,
    noname .meta:n = { typeset = ref },
    noname .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{sort} option}
%
% User option, sort labels ranges or not
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_sort_bool
\keys_define:nn { zref-clever }
  {
    sort .bool_set:N = \l_@@_typeset_sort_bool ,
    sort .initial:n = true ,
    sort .default:n = true ,
    nosort .meta:n = { sort = false },
    nosort .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{typesort} option}
%
%    \begin{macrocode}
\seq_new:N \l_@@_typesort_seq
\keys_define:nn { zref-clever }
  {
    typesort .code:n =
      {
        \seq_set_from_clist:Nn \l_@@_typesort_seq {#1}
        % Reverse the sequence, since the sort priorities are computed in the
        % negative range, so that we can implicitly rely on `0' being the
        % ``last value''.
        \seq_reverse:N \l_@@_typesort_seq
      } ,
    typesort .initial:n =
      { part , chapter , section , paragraph },
    typesort .value_required:n = true ,
    notypesort .code:n =
      { \seq_clear:N \l_@@_typesort_seq } ,
    notypesort .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{comp} option}
%
% User option, compress ranges or not
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_compress_bool
\keys_define:nn { zref-clever }
  {
    comp .bool_set:N = \l_@@_typeset_compress_bool ,
    comp .initial:n = true ,
    comp .default:n = true ,
    nocomp .meta:n = { comp = false },
    nocomp .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{range} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_range_bool
\keys_define:nn { zref-clever }
  {
    range .bool_set:N = \l_@@_typeset_range_bool ,
    range .initial:n = false ,
    range .default:n = true ,
  }
%    \end{macrocode}
%
%
%
% \subsubsection*{\opt{hyperref} option}
%
% \begin{variable}{\l_@@_use_hyperref_bool, \l_@@_warn_hyperref_bool}
%    \begin{macrocode}
\bool_new:N \l_@@_use_hyperref_bool
\bool_new:N \l_@@_warn_hyperref_bool
\keys_define:nn { zref-clever }
  {
    hyperref .choice: ,
    hyperref / auto .code:n =
      {
        \bool_set_true:N \l_@@_use_hyperref_bool
        \bool_set_false:N \l_@@_warn_hyperref_bool
      } ,
    hyperref / true .code:n =
      {
        \bool_set_true:N \l_@@_use_hyperref_bool
        \bool_set_true:N \l_@@_warn_hyperref_bool
      } ,
    hyperref / false .code:n =
      {
        \bool_set_false:N \l_@@_use_hyperref_bool
        \bool_set_false:N \l_@@_warn_hyperref_bool
      } ,
    hyperref .initial:n = auto ,
    hyperref .default:n = auto
  }
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\AddToHook { begindocument }
  {
    \@ifpackageloaded { hyperref }
      {
        \bool_if:NT \l_@@_use_hyperref_bool
          { \RequirePackage { zref-hyperref } }
      }
      {
        \bool_if:NT \l_@@_warn_hyperref_bool
          { \msg_warning:nn { zref-clever } { missing-hyperref } }
        \bool_set_false:N \l_@@_use_hyperref_bool
      }
    \keys_define:nn { zref-clever }
      {
        hyperref .code:n =
          { \msg_warning:nn { zref-clever } { hyperref-preamble-only } }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { zref-clever } { hyperref-preamble-only }
  {
    Option~'hyperref'~only~available~in~the~preamble. \iow_newline:
    Use~the~starred~version~of~'\noexpand\zcheck'~instead.
  }
\msg_new:nnn { zref-clever } { missing-hyperref }
  { Missing~'hyperref'~package. \iow_newline: Setting~'hyperref=false'. }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{nameinlink} option}
%
% \begin{variable}{\l_@@_nameinlink_tl}
%    \begin{macrocode}
\str_new:N \l_@@_nameinlink_str
\keys_define:nn { zref-clever }
  {
    nameinlink .choice: ,
    nameinlink / true .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { true } } ,
    nameinlink / false .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { false } } ,
    nameinlink / single .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { single } } ,
    nameinlink / tsingle .code:n =
      { \str_set:Nn \l_@@_nameinlink_str { tsingle } } ,
    nameinlink .initial:n = tsingle ,
    nameinlink .default:n = true ,
  }
%    \end{macrocode}
% \end{variable}
%
%
% \subsubsection*{\opt{cap} \opt{capfirst} options}
%
%    \begin{macrocode}
\bool_new:N \l_@@_capitalize_bool
\bool_new:N \l_@@_capitalize_first_bool
\keys_define:nn { zref-clever }
  {
    cap .bool_set:N = \l_@@_capitalize_bool ,
    cap .initial:n = false ,
    cap .default:n = true ,
    nocap .meta:n = { cap = false },
    nocap .value_forbidden:n = true ,

    capfirst .bool_set:N = \l_@@_capitalize_first_bool ,
    capfirst .initial:n = false ,
    capfirst .default:n = true ,

    C .meta:n =
      { capfirst = true , noabbrevfirst = true },
    C .value_forbidden:n = true ,
  }
%    \end{macrocode}
%
%
% \subsubsection*{\opt{abbrev} \opt{noabbrevfirst} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_abbrev_bool
\bool_new:N \l_@@_noabbrev_first_bool
\keys_define:nn { zref-clever }
  {
    abbrev .bool_set:N = \l_@@_abbrev_bool ,
    abbrev .initial:n = false ,
    abbrev .default:n = true ,
    noabbrev .meta:n = { abbrev = false },
    noabbrev .value_forbidden:n = true ,

    noabbrevfirst .bool_set:N = \l_@@_noabbrev_first_bool ,
    noabbrevfirst .initial:n = false ,
    noabbrevfirst .default:n = true ,
  }
%    \end{macrocode}
%
%
%
%
% \subsubsection*{\opt{lang} option}
%
%
%    \begin{macrocode}
\tl_new:N \l_@@_ref_language_tl
\NewHook { zref-clever / reflanguage }
\keys_define:nn { zref-clever }
  {
    lang .code:n =
      {
        \AddToHook { zref-clever / reflanguage }
          {
            \str_case:nnF {#1}
              {
                { main }
                {
                  \tl_set_eq:NN
                    \l_@@_ref_language_tl \l_@@_main_language_tl
                }

                { current }
                {
                  \tl_set_eq:NN
                    \l_@@_ref_language_tl \l_@@_current_language_tl
                }
              }
              { \tl_set:Nn \l_@@_ref_language_tl {#1} }
          }
      } ,
    lang .initial:n = main ,
    lang .value_required:n = true ,
  }
% \cs{AtEndOfPackage} so that it comes after
% \cs{ProcessKeysOptions}\texttt{{zref-clever}}.
\AtEndOfPackage
  {
    \AddToHook { zref-clever / reflanguage }
      {
        \keys_define:nn { zref-clever }
          {
            lang .code:n =
              {
                \str_case:nnF {#1}
                  {
                    { main }
                    {
                      \tl_set_eq:NN
                        \l_@@_ref_language_tl \l_@@_main_language_tl
                    }

                    { current }
                    {
                      \tl_set_eq:NN
                        \l_@@_ref_language_tl \l_@@_current_language_tl
                    }
                  }
                  { \tl_set:Nn \l_@@_ref_language_tl {#1} }
              } ,
            lang .initial:n = main ,
            lang .value_required:n = true ,
          }
      }
  }
%
%
%
% See \url{https://tex.stackexchange.com/a/233178} (including Javier Bezos'
% comment).  Also \url{https://tex.stackexchange.com/a/281220} (including
% PLK's comments).
%    \begin{macrocode}
% \LoadDictionaryFor{english}{zref-clever}
\AddToHook { begindocument / before }
  {
    % An internal alias for \pkg{translations}'s internal macro
    % \cs{@trnslt@current@language}.
    \tl_set_eq:NN \l_@@_current_language_tl \@trnslt@current@language
    % Getting main languages and, for each babel/polyglossia loaded language,
    % load corresponding zref-clever dictionary.
    \@ifpackageloaded{babel}
      {
        \tl_set_eq:NN \l_@@_main_language_tl \bbl@main@language
        \clist_map_inline:Nn \bbl@loaded
          { \LoadDictionaryFor {#1} { zref-clever } }
      }
      {
        \@ifpackageloaded{polyglossia}
          {
            \tl_set_eq:NN \l_@@_main_language_tl \xpg@main@language
            \clist_map_inline:Nn \xpg@loaded
              { \LoadDictionaryFor {#1} { zref-clever } }
          }
          {
            \tl_new:N \l_@@_main_language_tl
            \tl_set:Nn \l_@@_main_language_tl { english }
            \LoadDictionaryFor { english } { zref-clever }
          }
      }
    % *Then* we execute the package options stored in the 'reflanguage' hook.
    \UseHook { zref-clever / reflanguage }
  }
%    \end{macrocode}
%
%
% \subsubsection*{Strings options}
%
%
%    \begin{macrocode}

\prop_new:N \l_@@_ref_strings_prop

% Only not necessarily type-specific strings are pertinent here.
\clist_map_inline:nn
  {
    % Not type-specific strings.
    tpairsep ,
    tlistsep ,
    tlastsep ,
    % Possibly type-specific strings.
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    refpre ,
    refpos ,
    refpre-in ,
    refpos-in ,
  }
  {
    \keys_define:nn { zref-clever }
      {
        #1 .prop_put:N = \l_@@_ref_strings_prop ,
        #1 .value_required:n = true ,
      }
  }

%    \end{macrocode}
%
%
%
%
% \subsubsection*{Package options}
%
% Process load-time package options
% (\url{https://tex.stackexchange.com/a/15840}).
%    \begin{macrocode}
\RequirePackage { l3keys2e }
\ProcessKeysOptions { zref-clever }
%    \end{macrocode}
%
%
% \begin{macro}[int]{\zcsetup}
%   Provide \cs{zcsetup}.
%    \begin{macrocode}
\NewDocumentCommand \zcsetup { m }
  { \keys_set:nn { zref-clever } {#1} }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \section{\cs{zcref}}
%
%
% \begin{macro}[int]{\zcheck}
%   \begin{syntax}
%     \cs{zcref}\meta{*}\oarg{options}\marg{labels}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \zcref { s O { } m }
  { \zref@wrapper@babel \@@_zcref:nnn {#3} {#1} {#2} }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {
%     \l_@@_link_star_bool
%   }
%    \begin{macrocode}
\bool_new:N \l_@@_link_star_bool
%    \end{macrocode}
% \end{variable}

%
% \begin{macro}{\@@_zcref:nnnn}
%   An intermediate internal function, which does the actual heavy lifting,
%   and places \Arg{labels} as first argument, so that it can be protected by
%   \cs{zref@wrapper@babel} in \cs{zcref}.
%   \begin{syntax}
%     \cs{@@_zcref:nnnn} \Arg{labels} \Arg{*} \Arg{options}
%   \end{syntax}
%    \begin{macrocode}
\seq_new:N \l_@@_zcref_labels_seq
\cs_new_protected:Npn \@@_zcref:nnn #1#2#3
  {
    \group_begin:
      \keys_set:nn { zref-clever } {#3}
      \seq_set_from_clist:Nn \l_@@_zcref_labels_seq {#1}
      \bool_set:Nn \l_@@_link_star_bool {#2}
      \bool_lazy_or:nnT
        { \l_@@_typeset_sort_bool }
        { \l_@@_typeset_range_bool }
        { \@@_sort_labels: }
      \@@_typeset_refs:
    \group_end:
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \section{Sorting}
%
%
%    \begin{macrocode}
\int_new:N \l_@@_sort_prior_a_int
\int_new:N \l_@@_sort_prior_b_int
%    \end{macrocode}
%
%
% \begin{variable}
%   {
%     \l_@@_label_a_tl ,
%     \l_@@_label_b_tl ,
%     \l_@@_label_type_a_tl ,
%     \l_@@_label_type_b_tl ,
%     \l_@@_label_enclcnt_a_tl ,
%     \l_@@_label_enclcnt_b_tl ,
%     \l_@@_label_enclval_a_tl ,
%     \l_@@_label_enclval_b_tl
%   }
% Aux variables, for use in sorting and typesetting.  I could probably let go
% some of them in favor of \texttt{tmpa}/\texttt{tmpb}, but they do improve
% code readability.
%    \begin{macrocode}
\tl_new:N \l_@@_label_a_tl
\tl_new:N \l_@@_label_b_tl
\tl_new:N \l_@@_label_type_a_tl
\tl_new:N \l_@@_label_type_b_tl
\tl_new:N \l_@@_label_enclcnt_a_tl
\tl_new:N \l_@@_label_enclcnt_b_tl
\tl_new:N \l_@@_label_enclval_a_tl
\tl_new:N \l_@@_label_enclval_b_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_label_types_seq}
%   Stores the order in which reference types appear in the label list
%   supplied by the user in \cs{zcref}.  This order is required as a ``last
%   resort'' sort criterion between the reference types, for use in
%   \cs{@@_sort_default_aux:nn}.
%    \begin{macrocode}
\seq_new:N \l_@@_label_types_seq
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\@@_sort_labels:}
%   The main sorting function.  It does not receive arguments, but it is
%   expected to be run inside \cs{@@_zcref:nnnn} where a number of environment
%   variables are to be set appropriately.  In particular,
%   \cs{l_@@_zcref_labels_seq} should contain the labels received as argument
%   to \cs{zcheck}, and the function performs its task by sorting this
%   variable.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_labels:
  {
%    \end{macrocode}
% Store label types sequence.
%    \begin{macrocode}
    \seq_clear:N \l_@@_label_types_seq
    \bool_if:NF \l_@@_page_ref_bool
      {
        \seq_map_function:NN
          \l_@@_zcref_labels_seq \@@_label_type_put_new_right:n
      }
%    \end{macrocode}
% Sort.
%    \begin{macrocode}
    \seq_sort:Nn \l_@@_zcref_labels_seq
      {
        \zref@ifrefundefined {##1}
          {
            \zref@ifrefundefined {##2}
              {
%    \end{macrocode}
% Neither label is defined.
%    \begin{macrocode}
                \sort_return_same:
              }
              {
%    \end{macrocode}
% The second label is defined, but the first isn't, leave the undefined first
% (to be more visible).
%    \begin{macrocode}
                \sort_return_same:
              }
          }
          {
            \zref@ifrefundefined {##2}
              {
%    \end{macrocode}
% The first label is defined, but the second isn't, bring the second forward.
%    \begin{macrocode}
                \sort_return_swapped:
              }
              {
%    \end{macrocode}
% The interesting case: both labels are defined. The reference to the
% "default" property/counter or to the page are quite different from our
% perspective, they rely on different fields and even use different
% information for sorting, so we branch them here to specialized functions.
%    \begin{macrocode}
                \bool_if:NTF \l_@@_page_ref_bool
                  { \@@_sort_page_aux:nn {##1} {##2} }
                  { \@@_sort_default_aux:nn {##1} {##2} }
              }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_label_type_put_new_right:n}
%   Auxiliary function used to store ``new'' label types (in order) as the
%   sorting proceeds.  It is expected to be run inside \cs{@@_sort_labels:},
%   and stores new types in \cs{l_@@_label_types_seq}.
%   \begin{syntax}
%     \cs{@@_label_type_put_new_right:n} \Arg{label}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_label_type_put_new_right:n #1
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \tl_if_empty:NF \l_@@_label_type_a_tl
      {
        \seq_if_in:NVF \l_@@_label_types_seq \l_@@_label_type_a_tl
          {
            \seq_put_right:NV
              \l_@@_label_types_seq \l_@@_label_type_a_tl
          }
      }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{variable}{\l_@@_sort_decided_bool}
%   Auxiliary variable for \cs{@@_sort_default_aux:nn}, signals if the sorting
%   between two labels has been decided or not.
%    \begin{macrocode}
\bool_new:N \l_@@_sort_decided_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\tl_reverse_items:V}
%   Variant not provided by the kernel.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_reverse_items:n { V }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_sort_default_aux:nn}
%   The heavy-lifting function for sorting of existing labels for ``default''
%   references (that is, a standard reference, not to ``page'' etc.).  This
%   function is expected to be called within the sorting loop of
%   \cs{@@_sort_labels:} and receives the pair of labels being considered for
%   a change of order or not.  It should \emph{always} ``return'' either
%   \cs{sort_return_same:} or \cs{sort_return_swapped:}.
%   \begin{syntax}
%     \cs{@@_sort_default_aux:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_default_aux:nn #1#2
  {
    \tl_set:Nx \l_@@_label_type_a_tl
      { \zref@extractdefault {#1} { zc@type } { \c_empty_tl } }
    \tl_set:Nx \l_@@_label_type_b_tl
      { \zref@extractdefault {#2} { zc@type } { \c_empty_tl } }
    \bool_case_true:nF
      {
%    \end{macrocode}
% The second label has a type, but the first doesn't, leave the undefined
% first (to be more visible).
%    \begin{macrocode}
        {
          \tl_if_empty_p:N \l_@@_label_type_a_tl &&
          ! \tl_if_empty_p:N \l_@@_label_type_b_tl
        }
        { \sort_return_same: }
%    \end{macrocode}
% The first label has a type, but the second doesn't, bring the second
% forward.
%    \begin{macrocode}
        {
          ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
          \tl_if_empty_p:N \l_@@_label_type_b_tl
        }
        { \sort_return_swapped: }
%    \end{macrocode}
% Both labels have a type\dots{}
%    \begin{macrocode}
        {
          ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
          ! \tl_if_empty_p:N \l_@@_label_type_b_tl
        }
        {
          \tl_if_eq:NNTF \l_@@_label_type_a_tl \l_@@_label_type_b_tl
            {
%    \end{macrocode}
% \dots{} and it's the same type.
%    \begin{macrocode}
              \tl_set:Nx \l_@@_label_enclcnt_a_tl
                { \zref@extractdefault {#1} { zc@enclcnt } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_enclcnt_a_tl
                { \tl_reverse_items:V \l_@@_label_enclcnt_a_tl }
              \tl_set:Nx \l_@@_label_enclcnt_b_tl
                { \zref@extractdefault {#2} { zc@enclcnt } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_enclcnt_b_tl
                { \tl_reverse_items:V \l_@@_label_enclcnt_b_tl }
              \tl_set:Nx \l_@@_label_enclval_a_tl
                { \zref@extractdefault {#1} { zc@enclval } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_enclval_a_tl
                { \tl_reverse_items:V \l_@@_label_enclval_a_tl }
              \tl_set:Nx \l_@@_label_enclval_b_tl
                { \zref@extractdefault {#2} { zc@enclval } { \c_empty_tl } }
              \tl_set:Nx \l_@@_label_enclval_b_tl
                { \tl_reverse_items:V \l_@@_label_enclval_b_tl }

              \bool_set_false:N \l_@@_sort_decided_bool
              % CHECK should I replace the tmp variables here?
              \tl_clear:N \l_tmpa_tl
              \tl_clear:N \l_tmpb_tl
              \bool_until_do:Nn \l_@@_sort_decided_bool
                {
                  \tl_set:Nx \l_tmpa_tl
                    { \tl_head:N \l_@@_label_enclcnt_a_tl }
                  \tl_set:Nx \l_tmpb_tl
                    { \tl_head:N \l_@@_label_enclcnt_b_tl }

                  \bool_case_true:nF
                    {
                      % Both are empty, meaning: neither labels have any
                      % (further) ``enclosing counters'' (left).
                      {
                        \tl_if_empty_p:V \l_tmpa_tl &&
                        \tl_if_empty_p:V \l_tmpb_tl
                      }
                      {
                        \exp_args:Nxx \tl_if_eq:nnTF
                          { \zref@extractdefault {#1} { zc@counter } { } }
                          { \zref@extractdefault {#2} { zc@counter } { } }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \int_compare:nNnTF
                              { \zref@extractdefault {#1} { zc@cntval } {-1} }
                                >
                              { \zref@extractdefault {#2} { zc@cntval } {-1} }
                              { \sort_return_swapped: }
                              { \sort_return_same:    }
                          }
                          {
                            \msg_warning:nnnn { zref-clever }
                              { counters-not-nested } {#1} {#2}
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                      }

                      % `a' is empty (and `b' is not), meaning: `b' is
                      % (possibly) nested in `a'.
                      { \tl_if_empty_p:V \l_tmpa_tl }
                      {
                        \tl_set:Nx \l_tmpa_tl
                          { {\zref@extractdefault {#1} { zc@counter } { }} }
                        \exp_args:NNx \tl_if_in:NnTF
                          \l_@@_label_enclcnt_b_tl { \l_tmpa_tl }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                          {
                            \msg_warning:nnnn { zref-clever }
                              { counters-not-nested } {#1} {#2}
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                      }

                      % `b' is empty (and `a' is not), meaning: `a' is
                      % (possibly) nested in `b'.
                      { \tl_if_empty_p:V \l_tmpb_tl }
                      {
                        \tl_set:Nx \l_tmpb_tl
                          { {\zref@extractdefault {#2} { zc@counter } { }} }
                        \exp_args:NNx \tl_if_in:NnTF
                          \l_@@_label_enclcnt_a_tl { \l_tmpb_tl }
                          {
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_swapped:
                          }
                          {
                            \msg_warning:nnnn { zref-clever }
                              { counters-not-nested } {#1} {#2}
                            \bool_set_true:N \l_@@_sort_decided_bool
                            \sort_return_same:
                          }
                      }
                    }
                    % None of the above matched, hence neither is empty,
                    % meaning: we can (possibly) compare the values of the
                    % current enclosing counter in the loop, if they are
                    % equal, we are still in the loop, if they are not, a
                    % sorting decision can be made directly.
                    {
                      \tl_if_eq:NNTF \l_tmpa_tl \l_tmpb_tl
                        {
                          \int_compare:nNnTF
                            { \tl_head:N \l_@@_label_enclval_a_tl }
                              =
                            { \tl_head:N \l_@@_label_enclval_b_tl }
                            {
                              \tl_set:Nx \l_@@_label_enclcnt_a_tl
                                { \tl_tail:N \l_@@_label_enclcnt_a_tl }
                              \tl_set:Nx \l_@@_label_enclcnt_b_tl
                                { \tl_tail:N \l_@@_label_enclcnt_b_tl }
                              \tl_set:Nx \l_@@_label_enclval_a_tl
                                { \tl_tail:N \l_@@_label_enclval_a_tl }
                              \tl_set:Nx \l_@@_label_enclval_b_tl
                                { \tl_tail:N \l_@@_label_enclval_b_tl }
                            }
                            {
                              \bool_set_true:N \l_@@_sort_decided_bool
                              \int_compare:nNnTF
                                { \tl_head:N \l_@@_label_enclval_a_tl }
                                  >
                                { \tl_head:N \l_@@_label_enclval_b_tl }
                                { \sort_return_swapped: }
                                { \sort_return_same:    }
                            }
                        }
                        {
                          \msg_warning:nnnn { zref-clever }
                            { counters-not-nested } {#1} {#2}
                          \bool_set_true:N \l_@@_sort_decided_bool
                          \sort_return_same:
                        }

                    }
                }
            }
            {
%    \end{macrocode}
% \dots{} and they are different types.
%    \begin{macrocode}
              \int_zero:N \l_@@_sort_prior_a_int
              \int_zero:N \l_@@_sort_prior_b_int
              % \cs{l_@@_typesort_seq} was stored in reverse sequence, and we
              % compute the sort priorities in the negative range, so that we
              % can implicitly rely on `0' being the ``last value''.
              \seq_map_indexed_inline:Nn \l_@@_typesort_seq
                {
                  \tl_if_eq:nnTF {##2} {{othertypes}}
                    {
                      \int_compare:nNnT { \l_@@_sort_prior_a_int } = { 0 }
                        { \int_set:Nn \l_@@_sort_prior_a_int { - ##1 } }
                      \int_compare:nNnT { \l_@@_sort_prior_b_int } = { 0 }
                        { \int_set:Nn \l_@@_sort_prior_b_int { - ##1 } }
                    }
                    {
                      \tl_if_eq:NnTF \l_@@_label_type_a_tl {##2}
                        { \int_set:Nn \l_@@_sort_prior_a_int { - ##1 } }
                        {
                          \tl_if_eq:NnT \l_@@_label_type_b_tl {##2}
                            { \int_set:Nn \l_@@_sort_prior_b_int { - ##1 } }
                        }
                    }
                }
              \bool_case_true:nF
                {
                  {
                    \int_compare_p:nNn
                      { \l_@@_sort_prior_a_int } <
                      { \l_@@_sort_prior_b_int }
                  }
                  { \sort_return_same: }
                  {
                    \int_compare_p:nNn
                      { \l_@@_sort_prior_a_int } >
                      { \l_@@_sort_prior_b_int }
                  }
                  { \sort_return_swapped: }
                }
                {
%    \end{macrocode}
% Sort priorities are equal for different types: the type that occurs first in
% \meta{labels}, as given by the user, is kept (or brought) forward.
%    \begin{macrocode}
                  \seq_map_inline:Nn \l_@@_label_types_seq
                    {
                      \tl_if_eq:NnTF \l_@@_label_type_a_tl {##1}
                        { \seq_map_break:n { \sort_return_same: } }
                        {
                          \tl_if_eq:NnT \l_@@_label_type_b_tl {##1}
                            { \seq_map_break:n { \sort_return_swapped: } }
                        }
                    }

                }
            }
        }
      }
      {
%    \end{macrocode}
% If none of the above cases match, then neither of the labels has a type.  We
% can't do much of meaningful here, but if it's the same counter, compare it.
%    \begin{macrocode}
        \exp_args:Nxx \tl_if_eq:nnTF
          { \zref@extractdefault {#1} { zc@counter } { } }
          { \zref@extractdefault {#2} { zc@counter } { } }
          {
            \int_compare:nNnTF
              { \zref@extractdefault {#1} { zc@cntval } {-1} }
                >
              { \zref@extractdefault {#2} { zc@cntval } {-1} }
              { \sort_return_swapped: }
              { \sort_return_same:    }
          }
          { \sort_return_same: }

      }
  }
%    \end{macrocode}
% \end{macro}
%
% Warning message used in \cs{@@_sort_default_aux:nn}.
%    \begin{macrocode}
\msg_new:nnn { zref-clever } { counters-not-nested }
  { Counters~not~nested~for~labels~'#1'~and~'#2'~\msg_line_context:. }
%    \end{macrocode}
%
%
% \begin{macro}{\@@_sort_page_aux:nn}
%   The sorting function for sorting of existing labels for references to
%   ``page''.  This function is expected to be called within the sorting loop
%   of \cs{@@_sort_labels:} and receives the pair of labels being considered
%   for a change of order or not.  It should \emph{always} ``return'' either
%   \cs{sort_return_same:} or \cs{sort_return_swapped:}.  Compared to the
%   sorting of default labels, this is a piece of cake (thanks to
%   \texttt{abspage}).
%   \begin{syntax}
%     \cs{@@_sort_page_aux:nn} \Arg{label a} \Arg{label b}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_page_aux:nn #1#2
  {
    \int_compare:nNnTF
      { \zref@extractdefault {#1} { zc@abspg } {-1} }
        >
      { \zref@extractdefault {#2} { zc@abspg } {-1} }
      { \sort_return_swapped: }
      { \sort_return_same:    }
  }
%    \end{macrocode}
% \end{macro}
%
%
%
%
% \section{Typesetting}
%
% About possible alternatives to signal compression inhibition for individual
% labels, see \url{https://tex.stackexchange.com/q/611370} (thanks Enrico
% Gregorio, Phelype Oleinik, and Steven B.\ Segletes).  Yet another
% alternative would be to receive an optional argument with the label(s) not
% to be compressed.  This would be a repetition, but would keep the syntax
% ``clean''.  All in all, and rethinking this here, probably the best is
% simply to not allow individual inhibition of compression.  We can already
% control compression of each individual call of \cs{zcref} with existing
% options, this should be enough.  I don't think the small extra flexibility
% this would grant is worth the syntax disruption it entails.  Anyway, I have
% kept a ``handle'' to deal with this in case the need arises, in the form of
% \cs{l_@@_range_inhibit_next_bool}, which is currently no-op, but is in
% place.
%
%
%
%
% \begin{variable}{\l_@@_typeset_last_bool, \l_@@_last_of_type_bool}
%   Auxiliary variables for \cs{@@_typeset_refs:}.
%   \cs{l_@@_typeset_last_bool} signals if the label list is over so that we
%   can leave the loop.  \cs{l_@@_last_of_type_bool} signals if we are
%   processing the last label of the current reference type.
%    \begin{macrocode}
\bool_new:N \l_@@_typeset_last_bool
\bool_new:N \l_@@_last_of_type_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_typeset_queue_prev_tl ,
%     \l_@@_typeset_queue_curr_tl ,
%     \l_@@_type_first_label_tl ,
%     \l_@@_type_first_label_type_tl
%   }
%   Auxiliary variables for \cs{@@_typeset_refs:}.  They store, respectively
%   the ``previous'' and the ``current'' reference type information while they
%   are being processed, since we cannot typeset them directly, given we can
%   only know certain things when the (next) type list is over.  The ``queue''
%   stores all references but the first of the type, and they are stored ready
%   to be typeset.  The ``first_label'' stores the \emph{label} of the first
%   reference for the type, because the name can only be determined at the
%   end, and its (potential) hyperlink must be handled at that point.
%    \begin{macrocode}
\tl_new:N \l_@@_typeset_queue_prev_tl
\tl_new:N \l_@@_typeset_queue_curr_tl
\tl_new:N \l_@@_type_first_label_tl
\tl_new:N \l_@@_type_first_label_type_tl
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}
%   {
%     \l_@@_label_count_int ,
%     \l_@@_type_count_int ,
%   }
%   Main counters for \cs{@@_typeset_refs:}.  They track the state of the
%   parsing of the labels list.  \cs{l_@@_label_count_int} is stepped for every
%   reference/label in the list, and reset at the start of a new type.
%   \cs{l_@@_type_count_int} is stepped at every reference type change.
%    \begin{macrocode}
\int_new:N \l_@@_label_count_int
\int_new:N \l_@@_type_count_int
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}
%   {
%     \l_@@_range_count_int ,
%     \l_@@_range_same_count_int ,
%     \l_@@_range_beg_label_tl ,
%     \l_@@_next_maybe_range_bool ,
%     \l_@@_next_is_same_bool ,
%     \l_@@_range_inhibit_next_bool
%   }
%   Range related auxiliary variables for \cs{@@_typeset_refs:}.
%   \cs{l_@@_range_count_int} counts how many references/labels are in the
%   current ongoing range.  \cs{l_@@_range_same_count_int} counts how many of
%   the references in the current ongoing range are repeated ones.
%   \cs{l_@@_range_beg_label_tl} stores the label of the reference that starts
%   a range.  \cs{l_@@_next_maybe_range_bool} signals whether the next element
%   is in sequence to the current one.  \cs{l_@@_next_is_same_bool} signals
%   whether the next element repeats the current one.
%   \cs{l_@@_range_inhibit_next_bool} allows to control/track compression
%   inhibition of the next label.
%    \begin{macrocode}
\int_new:N \l_@@_range_count_int
\int_new:N \l_@@_range_same_count_int
\tl_new:N \l_@@_range_beg_label_tl
\bool_new:N \l_@@_next_maybe_range_bool
\bool_new:N \l_@@_next_is_same_bool
\bool_new:N \l_@@_range_inhibit_next_bool
%    \end{macrocode}
% \end{variable}
%
%
% \begin{variable}{}
%   Aux variables for \cs{@@_typeset_refs:}.  Store separators and refpre/pos
%   strings.
%    \begin{macrocode}
\tl_new:N \l_@@_namesep_tl
\tl_new:N \l_@@_rangesep_tl
\tl_new:N \l_@@_pairsep_tl
\tl_new:N \l_@@_listsep_tl
\tl_new:N \l_@@_lastsep_tl
% `t' for ``type''
\tl_new:N \l_@@_tpairsep_tl
\tl_new:N \l_@@_tlistsep_tl
\tl_new:N \l_@@_tlastsep_tl
\tl_new:N \l_@@_refpre_out_tl
\tl_new:N \l_@@_refpos_out_tl
\tl_new:N \l_@@_refpre_in_tl
\tl_new:N \l_@@_refpos_in_tl
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\@@_get_ref:n}
%   Auxiliary function to \cs{@@_typeset_refs:}.  Handles a complete
%   ``ref-block'', including ``pre'' and ``pos'' elements, and
%   \emph{hyperlinking}.  It does not handle the reference type ``name'', for
%   that use \cs{@@_get_ref_first:}.  It should get the reference with
%   \cs{zref@extractdefault} as usual but, if the reference is not available,
%   should put \cs{zref@default} on the stream protected, so that it can be
%   accumulated in the queue.  \cs{hyperlink} must also be protected from
%   expansion for the same reason.
%    \begin{macrocode}
\cs_new:Npn \@@_get_ref:n #1
  {
    \zref@ifrefcontainsprop {#1} { \l_@@_ref_property_tl }
      {
        \bool_if:nTF
          { \l_@@_use_hyperref_bool && ! \l_@@_link_star_bool }
          {
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_refpre_out_tl
            \exp_not:N \group_begin:
            % It's two '@s', but escaped for DocStrip.
            \exp_not:N \hyper@@@@link
              {
                \zref@ifrefcontainsprop {#1} { urluse }
                  {
                    \zref@extractdefault {#1} { urluse } {}
                  }
                  {
                    \zref@extractdefault {#1} { url } {}
                  }
              }
              { \zref@extractdefault {#1} { anchor } {} }
              {
                \exp_not:V \l_@@_refpre_in_tl
                \zref@extractdefault {#1} { \l_@@_ref_property_tl } {}
                \exp_not:V \l_@@_refpos_in_tl
              }
            \exp_not:N \group_end:
            \exp_not:V \l_@@_refpos_out_tl
            \exp_not:N \group_end:
          }
          {
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_refpre_out_tl
            \exp_not:N \group_begin:
            \exp_not:V \l_@@_refpre_in_tl
            \zref@extractdefault {#1} { \l_@@_ref_property_tl } {}
            \exp_not:V \l_@@_refpos_in_tl
            \exp_not:N \group_end:
            \exp_not:V \l_@@_refpos_out_tl
            \exp_not:N \group_end:
          }
      }
      { \exp_not:N \zref@default }
  }
\cs_generate_variant:Nn \@@_get_ref:n { V }
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{variable}
%   {
%     \l_@@_type_name_tl ,
%     \l_@@_name_in_link_bool
%   }
%   Auxiliary variables for \cs{@@_get_ref_first:}.
%    \begin{macrocode}
\tl_new:N \l_@@_type_name_tl
\bool_new:N \l_@@_name_in_link_bool
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\@@_get_ref_first:}
%   Auxiliary function to \cs{@@_typeset_refs:}.  Handles a complete
%   ``ref-block'', including ``pre'' and ``pos'' elements,
%   \emph{hyperlinking}, and the reference type ``name''.  For use on the
%   first reference of each type.
%    \begin{macrocode}
\bool_new:N \l_@@_name_capitalize_bool
\bool_new:N \l_@@_name_abbrev_bool
\tl_new:N \l_@@_name_maybe_plural_tl
% Variant not provided by the kernel.
\prg_generate_conditional_variant:Nnn \prop_get:NnN { cxN } { F }

\cs_new_protected:Npn \@@_type_name_setup:
  {
%    \end{macrocode}
% Determine whether we should use capitalization and abbreviation.
%    \begin{macrocode}
    \bool_lazy_or:nnTF
      { \l_@@_capitalize_bool }
      {
        \l_@@_capitalize_first_bool &&
        \int_compare_p:nNn { \l_@@_type_count_int } = { 0 }
      }
      { \bool_set_true:N \l_@@_name_capitalize_bool  }
      { \bool_set_false:N \l_@@_name_capitalize_bool }

    \bool_lazy_or:nnTF
      { ! \l_@@_abbrev_bool }
      {
        \l_@@_noabbrev_first_bool &&
        \int_compare_p:nNn { \l_@@_type_count_int } = { 0 }
      }
      { \bool_set_false:N \l_@@_name_abbrev_bool }
      { \bool_set_true:N \l_@@_name_abbrev_bool  }
%    \end{macrocode}
% Set the type name variable \cs{l_@@_type_name_tl}.  When it cannot be found,
% clear it.
%    \begin{macrocode}
    \zref@ifrefundefined { \l_@@_type_first_label_tl }
      { \tl_clear:N \l_@@_type_name_tl }
      {
        \tl_if_empty:nTF \l_@@_type_first_label_type_tl
          { \tl_clear:N \l_@@_type_name_tl }
          {
            \tl_if_empty:NTF \l_@@_typeset_queue_curr_tl
              % Singular
              { \tl_set:Nn \l_@@_name_maybe_plural_tl { -sg } }
              % Plural
              { \tl_set:Nn \l_@@_name_maybe_plural_tl { -pl } }

            \bool_case_true:nF
              {
                { ! \l_@@_name_abbrev_bool && ! \l_@@_name_capitalize_bool }
                {
                  % name(-pl)
                  \prop_get:cxNF
                    { l_@@_type_ \l_@@_type_first_label_type_tl _strings_prop }
                    { name \l_@@_name_maybe_plural_tl }
                    \l_@@_type_name_tl
                    {
                      \@@_if_translation:xxTF
                        { \l_@@_ref_language_tl }
                        {
                          zrefclever-type- \l_@@_type_first_label_type_tl
                          -name \l_@@_name_maybe_plural_tl
                        }
                        {
                          \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                            { \l_@@_ref_language_tl }
                            {
                              zrefclever-type- \l_@@_type_first_label_type_tl
                              -name \l_@@_name_maybe_plural_tl
                            }
                        }
                        {
                          \tl_clear:N \l_@@_type_name_tl
                          \msg_warning:nnx { zref-clever } { missing-name }
                            { \l_@@_type_first_label_type_tl }
                        }
                    }
                }

                { ! \l_@@_name_abbrev_bool } % but capitalize
                {
                  % Name(-pl)
                  \prop_get:cxNF
                    { l_@@_type_ \l_@@_type_first_label_type_tl _strings_prop }
                    { Name \l_@@_name_maybe_plural_tl }
                    \l_@@_type_name_tl
                    {
                      \@@_if_translation:xxTF
                        { \l_@@_ref_language_tl }
                        {
                          zrefclever-type- \l_@@_type_first_label_type_tl
                          -Name \l_@@_name_maybe_plural_tl
                        }
                        {
                          \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                            { \l_@@_ref_language_tl }
                            {
                              zrefclever-type- \l_@@_type_first_label_type_tl
                              -Name \l_@@_name_maybe_plural_tl
                            }
                        }
                        {
                          \@@_if_translation:xxTF
                            { \l_@@_ref_language_tl }
                            {
                              zrefclever-type- \l_@@_type_first_label_type_tl
                              -name \l_@@_name_maybe_plural_tl
                            }
                            {
                              \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                                { \l_@@_ref_language_tl }
                                {
                                  zrefclever-type- \l_@@_type_first_label_type_tl
                                  -name \l_@@_name_maybe_plural_tl
                                }
                              \tl_set:Nx \l_@@_type_name_tl
                                { \text_titlecase_first:n { \l_@@_type_name_tl } }
                            }
                            {
                              \tl_clear:N \l_@@_type_name_tl
                              \msg_warning:nnx { zref-clever } { missing-name }
                                { \l_@@_type_first_label_type_tl }
                            }
                        }
                    }
                }

                { ! \l_@@_name_capitalize_bool } % but abbrev
                {
                  % name-ab(-pl)
                  \prop_get:cxNF
                    { l_@@_type_ \l_@@_type_first_label_type_tl _strings_prop }
                    { name-ab \l_@@_name_maybe_plural_tl }
                    \l_@@_type_name_tl
                    {
                      \@@_if_translation:xxTF
                        { \l_@@_ref_language_tl }
                        {
                          zrefclever-type- \l_@@_type_first_label_type_tl
                          -name-ab \l_@@_name_maybe_plural_tl
                        }
                        {
                          \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                            { \l_@@_ref_language_tl }
                            {
                              zrefclever-type- \l_@@_type_first_label_type_tl
                              -name-ab \l_@@_name_maybe_plural_tl
                            }
                        }
                        {
                          \@@_if_translation:xxTF
                            { \l_@@_ref_language_tl }
                            {
                              zrefclever-type- \l_@@_type_first_label_type_tl
                              -name \l_@@_name_maybe_plural_tl
                            }
                            {
                              \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                                { \l_@@_ref_language_tl }
                                {
                                  zrefclever-type- \l_@@_type_first_label_type_tl
                                  -name \l_@@_name_maybe_plural_tl
                                }
                            }
                            {
                              \tl_clear:N \l_@@_type_name_tl
                              \msg_warning:nnx { zref-clever } { missing-name }
                                { \l_@@_type_first_label_type_tl }
                            }
                        }
                    }
                }
              }
              {
                % Name-ab(-pl)
                \prop_get:cxNF
                  { l_@@_type_ \l_@@_type_first_label_type_tl _strings_prop }
                  { Name-ab \l_@@_name_maybe_plural_tl }
                  \l_@@_type_name_tl
                  {
                    \@@_if_translation:xxTF
                      { \l_@@_ref_language_tl }
                      {
                        zrefclever-type- \l_@@_type_first_label_type_tl
                        -Name-ab \l_@@_name_maybe_plural_tl
                      }
                      {
                        \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                          { \l_@@_ref_language_tl }
                          {
                            zrefclever-type- \l_@@_type_first_label_type_tl
                            -Name-ab \l_@@_name_maybe_plural_tl
                          }
                      }
                      {
                        \@@_if_translation:xxTF
                          { \l_@@_ref_language_tl }
                          {
                            zrefclever-type- \l_@@_type_first_label_type_tl
                            -name-ab \l_@@_name_maybe_plural_tl
                          }
                          {
                            \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                              { \l_@@_ref_language_tl }
                              {
                                zrefclever-type- \l_@@_type_first_label_type_tl
                                -name-ab \l_@@_name_maybe_plural_tl
                              }
                            \tl_set:Nx \l_@@_type_name_tl
                              { \text_titlecase_first:n { \l_@@_type_name_tl } }
                          }
                          {
                            % We don't try to fallback to `Name' here, and
                            % spare a branching with it going directly to
                            % `name', which is expected to exist.  It is not
                            % really that meaningful to attempt to retrieve
                            % the last bit of information if the user does not
                            % want to specify it.
                            \@@_if_translation:xxTF
                              { \l_@@_ref_language_tl }
                              {
                                zrefclever-type- \l_@@_type_first_label_type_tl
                                -name \l_@@_name_maybe_plural_tl
                              }
                              {
                                \@@_get_translation_for:nxx { \l_@@_type_name_tl }
                                  { \l_@@_ref_language_tl }
                                  {
                                    zrefclever-type- \l_@@_type_first_label_type_tl
                                    -name \l_@@_name_maybe_plural_tl
                                  }
                                \tl_set:Nx \l_@@_type_name_tl
                                  { \text_titlecase_first:n { \l_@@_type_name_tl } }
                              }
                              {
                                \tl_clear:N \l_@@_type_name_tl
                                \msg_warning:nnx { zref-clever } { missing-name }
                                  { \l_@@_type_first_label_type_tl }
                              }
                          }
                      }
                  }
              }
          }
      }
%    \end{macrocode}
% Signal whether the type name is to be included in the hyperlink or not.
%    \begin{macrocode}
    \bool_case_true:nF
      {
        { ! \l_@@_use_hyperref_bool }
        { \bool_set_false:N \l_@@_name_in_link_bool }

        { \l_@@_link_star_bool }
        { \bool_set_false:N \l_@@_name_in_link_bool }

        { \tl_if_empty_p:N \l_@@_type_name_tl }
        { \bool_set_false:N \l_@@_name_in_link_bool }

        { \str_if_eq_p:Vn \l_@@_nameinlink_str { false } }
        { \bool_set_false:N \l_@@_name_in_link_bool }

        { \str_if_eq_p:Vn \l_@@_nameinlink_str { true } }
        { \bool_set_true:N \l_@@_name_in_link_bool }

        {
          \str_if_eq_p:Vn \l_@@_nameinlink_str { tsingle } &&
          \tl_if_empty_p:N \l_@@_typeset_queue_curr_tl
        }
        { \bool_set_true:N \l_@@_name_in_link_bool }

        {
          \str_if_eq_p:Vn \l_@@_nameinlink_str { single } &&
          \tl_if_empty_p:N \l_@@_typeset_queue_curr_tl &&
          \l_@@_typeset_last_bool &&
          \int_compare_p:nNn { \l_@@_type_count_int } = { 0 }
        }
        { \bool_set_true:N \l_@@_name_in_link_bool }
      }
      { \bool_set_false:N \l_@@_name_in_link_bool }
  }

\cs_new:Npn \@@_get_ref_first:
  {
    \zref@ifrefundefined { \l_@@_type_first_label_tl }
      { \exp_not:N \zref@default }
      {
        \bool_if:NTF \l_@@_name_in_link_bool
          {
            \zref@ifrefcontainsprop
              { \l_@@_type_first_label_tl } { \l_@@_ref_property_tl }
              {
                % It's two '@s', but escaped for DocStrip.
                \exp_not:N \hyper@@@@link
                  {
                    \zref@ifrefcontainsprop
                      { \l_@@_type_first_label_tl } { urluse }
                      {
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { urluse } {}
                      }
                      {
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { url } {}
                      }
                  }
                  {
                    \zref@extractdefault { \l_@@_type_first_label_tl }
                      { anchor } {}
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_type_name_tl
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_namesep_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_refpre_in_tl
                    \zref@extractdefault { \l_@@_type_first_label_tl }
                      { \l_@@_ref_property_tl } {}
                    \exp_not:V \l_@@_refpos_in_tl
                    \exp_not:N \group_end:
                  }
                \exp_not:V \l_@@_refpos_out_tl
                \exp_not:N \group_end:
              }
              {
                \exp_not:N \group_begin:
                \exp_not:V \l_@@_type_name_tl
                \exp_not:N \group_end:
                \exp_not:V \l_@@_namesep_tl
                \exp_not:N \zref@default
              }
          }
          {
            \tl_if_empty:NTF \l_@@_type_name_tl
              {
                \exp_not:N \zref@default
                \exp_not:V \l_@@_namesep_tl
              }
              {
                \exp_not:N \group_begin:
                \exp_not:V \l_@@_type_name_tl
                \exp_not:N \group_end:
                \exp_not:V \l_@@_namesep_tl
              }
            \zref@ifrefcontainsprop
              { \l_@@_type_first_label_tl } { \l_@@_ref_property_tl }
              {
                \bool_if:nTF
                  {
                    \l_@@_use_hyperref_bool &&
                    ! \l_@@_link_star_bool
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    % It's two '@s', but escaped for DocStrip.
                    \exp_not:N \hyper@@@@link
                      {
                        \zref@ifrefcontainsprop
                          { \l_@@_type_first_label_tl } { urluse }
                          {
                            \zref@extractdefault { \l_@@_type_first_label_tl }
                              { urluse } {}
                          }
                          {
                            \zref@extractdefault { \l_@@_type_first_label_tl }
                              { url } {}
                          }
                      }
                      {
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { anchor } {}
                      }
                      {
                        \exp_not:V \l_@@_refpre_in_tl
                        \zref@extractdefault { \l_@@_type_first_label_tl }
                          { \l_@@_ref_property_tl } {}
                        \exp_not:V \l_@@_refpos_in_tl
                      }
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_refpos_out_tl
                    \exp_not:N \group_end:
                  }
                  {
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_refpre_out_tl
                    \exp_not:N \group_begin:
                    \exp_not:V \l_@@_refpre_in_tl
                    \zref@extractdefault { \l_@@_type_first_label_tl }
                      { \l_@@_ref_property_tl } {}
                    \exp_not:V \l_@@_refpos_in_tl
                    \exp_not:N \group_end:
                    \exp_not:V \l_@@_refpos_out_tl
                    \exp_not:N \group_end:
                  }
              }
              { \exp_not:N \zref@default }
          }
      }
  }
%    \end{macrocode}
% \end{macro}




%    \begin{macrocode}
% \Arg{string} \Arg{var to store result}
\cs_new_protected:Npn \@@_get_string:nN #1#2
  {
    % First attempt options stored in \cs{l_@@_ref_strings_prop}.
    \prop_get:NnNF \l_@@_ref_strings_prop {#1} #2
      {
        % If not found, try the type specific strings.
        \bool_lazy_all:nTF
          {
            { ! \tl_if_empty_p:N \l_@@_label_type_a_tl }
            {
              \prop_if_exist_p:c
                { l_@@_type_ \l_@@_label_type_a_tl _strings_prop }
            }
            {
              \prop_if_in_p:cn
                { l_@@_type_ \l_@@_label_type_a_tl _strings_prop } {#1}
            }
          }
          {
            \prop_get:cnN
              { l_@@_type_ \l_@@_label_type_a_tl _strings_prop } {#1} #2
          }
          {
            % If not found, try the type specific translations.
            \@@_if_translation:xxTF
              { \l_@@_ref_language_tl }
              { zrefclever-type- \l_@@_label_type_a_tl - #1 }
              {
                \@@_get_translation_for:nxx {#2}
                  { \l_@@_ref_language_tl }
                  { zrefclever-type- \l_@@_label_type_a_tl - #1 }
              }
              {
                % If not found, try general translations.  We are not
                % controlling for their existence, but we must make sure all
                % strings being retrieved with \cs{@@_get_string:nN} have
                % their values set for `English' and `fallback'.
                \@@_get_translation_for:nxx {#2}
                  { \l_@@_ref_language_tl }
                  { zrefclever-default- #1 }
              }
          }
      }
  }
%    \end{macrocode}
%

%    \begin{macrocode}



% Sets \cs{l_@@_next_maybe_range_bool} to true if label `1' comes in immediate
% sequence from label `2'.  And sets both \cs{l_@@_next_maybe_range_bool} and
% \cs{l_@@_next_is_same_bool} if the labels are the ``same''.
\cs_new_protected:Npn \@@_labels_in_sequence:nn #1#2
  {
    \bool_if:NTF \l_@@_page_ref_bool
      {
        \exp_args:Nxx \tl_if_eq:nnT
          { \zref@extractdefault {#1} { zc@pgfmt } { } }
          { \zref@extractdefault {#2} { zc@pgfmt } { } }
          {
            \int_compare:nNnTF
              { \zref@extractdefault {#1} { zc@pgval } {-2} + 1 }
                =
              { \zref@extractdefault {#2} { zc@pgval } {-1} }
              { \bool_set_true:N \l_@@_next_maybe_range_bool }
              {
                \int_compare:nNnT
                  { \zref@extractdefault {#1} { zc@pgval } {-1} }
                    =
                  { \zref@extractdefault {#2} { zc@pgval } {-1} }
                  {
                    \bool_set_true:N \l_@@_next_maybe_range_bool
                    \bool_set_true:N \l_@@_next_is_same_bool
                  }
              }
          }
      }
      {
        \exp_args:Nxx \tl_if_eq:nnT
          { \zref@extractdefault {#1} { zc@counter } { } }
          { \zref@extractdefault {#2} { zc@counter } { } }
          {
            \exp_args:Nxx \tl_if_eq:nnT
              { \zref@extractdefault {#1} { zc@enclval } { } }
              { \zref@extractdefault {#2} { zc@enclval } { } }
              {
                \int_compare:nNnTF
                  { \zref@extractdefault {#1} { zc@cntval } {-2} + 1 }
                    =
                  { \zref@extractdefault {#2} { zc@cntval } {-1} }
                  { \bool_set_true:N \l_@@_next_maybe_range_bool }
                  {
                    \int_compare:nNnT
                      { \zref@extractdefault {#1} { zc@cntval } {-1} }
                        =
                      { \zref@extractdefault {#2} { zc@cntval } {-1} }
                      {
                        \bool_set_true:N \l_@@_next_maybe_range_bool
                        \bool_set_true:N \l_@@_next_is_same_bool
                      }
                  }
              }
          }
      }
  }

\cs_new_protected:Npn \@@_typeset_refs:
  {
    \tl_clear:N \l_@@_typeset_queue_prev_tl
    \tl_clear:N \l_@@_typeset_queue_curr_tl
    \tl_clear:N \l_@@_type_first_label_tl
    \tl_clear:N \l_@@_type_first_label_type_tl
    \tl_clear:N \l_@@_range_beg_label_tl
    \int_zero:N \l_@@_label_count_int
    \int_zero:N \l_@@_type_count_int
    \int_zero:N \l_@@_range_count_int
    \int_zero:N \l_@@_range_same_count_int

    % Get not-type-specific separators and refpre/pos strings.
    \@@_get_string:nN {tpairsep} \l_@@_tpairsep_tl
    \@@_get_string:nN {tlistsep} \l_@@_tlistsep_tl
    \@@_get_string:nN {tlastsep} \l_@@_tlastsep_tl

    % Loop over the label list in sequence.
    \bool_set_false:N \l_@@_typeset_last_bool
    \bool_until_do:Nn \l_@@_typeset_last_bool
      {
        \seq_pop_left:NN \l_@@_zcref_labels_seq \l_@@_label_a_tl
        \seq_if_empty:NTF \l_@@_zcref_labels_seq
          {
            \tl_clear:N \l_@@_label_b_tl
            \bool_set_true:N \l_@@_typeset_last_bool
          }
          { \seq_get_left:NN \l_@@_zcref_labels_seq \l_@@_label_b_tl }

        \bool_if:NTF \l_@@_page_ref_bool
          {
            \tl_set:Nn \l_@@_label_type_a_tl { page }
            \tl_set:Nn \l_@@_label_type_b_tl { page }
          }
          {
            \tl_set:Nx \l_@@_label_type_a_tl
              {
                \zref@extractdefault
                  { \l_@@_label_a_tl } { zc@type } { \c_empty_tl }
              }
            \tl_set:Nx \l_@@_label_type_b_tl
              {
                \zref@extractdefault
                  { \l_@@_label_b_tl } { zc@type } { \c_empty_tl }
              }
          }

        % First, we establish whether the ``current label'' (i.e. `a') is the
        % last one of its type.  This can happen because the ``next label''
        % (i.e. `b') is of a different type (or different definition status),
        % or because we are at the end of the list.
        \bool_if:NTF \l_@@_typeset_last_bool
          { \bool_set_true:N \l_@@_last_of_type_bool }
          {
            \zref@ifrefundefined { \l_@@_label_a_tl }
              {
                \zref@ifrefundefined { \l_@@_label_b_tl }
                  { \bool_set_false:N \l_@@_last_of_type_bool }
                  { \bool_set_true:N \l_@@_last_of_type_bool  }
              }
              {
                \zref@ifrefundefined { \l_@@_label_b_tl }
                  { \bool_set_true:N \l_@@_last_of_type_bool }
                  {
                    % Neither is undefined, we must check the types.
                    \bool_case_true:nF
                      {
                        % Both empty: same ``type''.
                        {
                          \tl_if_empty_p:N \l_@@_label_type_a_tl &&
                          \tl_if_empty_p:N \l_@@_label_type_b_tl
                        }
                        { \bool_set_false:N \l_@@_last_of_type_bool }

                        % Neither empty: compare types.
                        {
                          ! \tl_if_empty_p:N \l_@@_label_type_a_tl &&
                          ! \tl_if_empty_p:N \l_@@_label_type_b_tl
                        }
                        {
                          \tl_if_eq:NNTF
                            \l_@@_label_type_a_tl \l_@@_label_type_b_tl
                            { \bool_set_false:N \l_@@_last_of_type_bool }
                            { \bool_set_true:N \l_@@_last_of_type_bool  }
                        }
                      }
                      % One empty, the other not: different ``types''.
                      { \bool_set_true:N \l_@@_last_of_type_bool }
                  }
              }
          }

        % Handle warnings in case of reference or type undefined.
        \zref@refused { \l_@@_label_a_tl }
        \zref@ifrefundefined { \l_@@_label_a_tl }
          {}
          {
            \tl_if_empty:NT \l_@@_label_type_a_tl
              {
                \msg_warning:nnx { zref-clever } { missing-type }
                  { \l_@@_label_a_tl }
              }
          }

        % Get type-specific separators and refpre/pos strings, once per type.
        \int_compare:nNnT { \l_@@_label_count_int } = { 0 }
          {
            \@@_get_string:nN {namesep}   \l_@@_namesep_tl
            \@@_get_string:nN {rangesep}  \l_@@_rangesep_tl
            \@@_get_string:nN {pairsep}   \l_@@_pairsep_tl
            \@@_get_string:nN {listsep}   \l_@@_listsep_tl
            \@@_get_string:nN {lastsep}   \l_@@_lastsep_tl
            \@@_get_string:nN {refpre}    \l_@@_refpre_out_tl
            \@@_get_string:nN {refpos}    \l_@@_refpos_out_tl
            \@@_get_string:nN {refpre-in} \l_@@_refpre_in_tl
            \@@_get_string:nN {refpos-in} \l_@@_refpos_in_tl
          }

        % Here we send this to a couple of auxiliary functions for no other
        % reason than to keep this long function a little less unreadable.
        \bool_if:NTF \l_@@_last_of_type_bool
          {
            % There exists no next label of the same type as the current.
            \@@_typeset_refs_aux_last_of_type:
          }
          {
            % There exists a next label of the same type as the current.
            \@@_typeset_refs_aux_not_last_of_type:
          }
      }
  }

\cs_new_protected:Npn \@@_typeset_refs_aux_last_of_type:
  {
    % Process the current label to the current queue.
    \int_case:nnF { \l_@@_label_count_int }
      {
        % It is the last label of its type, but also the first one, and that's
        % what matters here: just store it.
        { 0 }
        {
          \tl_set:NV \l_@@_type_first_label_tl \l_@@_label_a_tl
          \tl_set:NV \l_@@_type_first_label_type_tl \l_@@_label_type_a_tl
        }

        % The last is the second: we have a pair (if not repeated).
        { 1 }
        {
          \int_compare:nNnF { \l_@@_range_same_count_int } = {1}
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  \exp_not:V \l_@@_pairsep_tl
                  \@@_get_ref:V \l_@@_label_a_tl
                }
            }
        }
      }
      % If neither the first, nor the second: we have the last label
      % on the current type list (if not repeated).
      {
        \int_case:nnF { \l_@@_range_count_int }
          {
            % There was no range going on.
            {0}
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  \exp_not:V \l_@@_lastsep_tl
                  \@@_get_ref:V \l_@@_label_a_tl
                }
            }
            % Last in the range is also the second in it.
            {1}
            {
              \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                {
                  % We know `range_beg_label' is not empty, since this is the
                  % second element in the range, but the third or more in the
                  % type list.
                  \exp_not:V \l_@@_listsep_tl
                  \@@_get_ref:V \l_@@_range_beg_label_tl
                  \int_compare:nNnF { \l_@@_range_same_count_int } = {1}
                    {
                      \exp_not:V \l_@@_lastsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
            }
          }
          % Last in the range is third or more in it.
          {
            \int_case:nnF
              { \l_@@_range_count_int - \l_@@_range_same_count_int }
              {
                % Repetition, not a range.
                {0}
                {
                  % If `range_beg_label' is empty, it means it was also the
                  % first of the type, and hence was already handled.
                  \tl_if_empty:VF \l_@@_range_beg_label_tl
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \exp_not:V \l_@@_lastsep_tl
                          \@@_get_ref:V \l_@@_range_beg_label_tl
                        }
                    }
                }
                % A ``range'', but with no skipped value, treat as list.
                {1}
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      % Ditto.
                      \tl_if_empty:VF \l_@@_range_beg_label_tl
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_range_beg_label_tl
                        }
                      \exp_not:V \l_@@_lastsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
              }
              {
                % An actual range.
                \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                  {
                    % Ditto.
                    \tl_if_empty:VF \l_@@_range_beg_label_tl
                      {
                        \exp_not:V \l_@@_lastsep_tl
                        \@@_get_ref:V \l_@@_range_beg_label_tl
                      }
                    \exp_not:V \l_@@_rangesep_tl
                    \@@_get_ref:V \l_@@_label_a_tl
                  }
              }
          }
      }

    % Handle ``range'' option.  The idea is simple: if the queue is not empty,
    % we replace it with the end of the range (or pair).  We can still
    % retrieve the end of the range from \cs{l_@@_label_a_tl} since we know to
    % be processing the last label of its type at this point.
    \bool_if:NT \l_@@_typeset_range_bool
      {
        \tl_if_empty:NTF \l_@@_typeset_queue_curr_tl
          {
            \zref@ifrefundefined { \l_@@_type_first_label_tl }
              { }
              {
                \msg_warning:nnx { zref-clever } { single-element-range }
                  { \l_@@_type_first_label_type_tl }
              }
          }
          {
            \bool_set_false:N \l_@@_next_maybe_range_bool
            \zref@ifrefundefined { \l_@@_type_first_label_tl }
              { }
              {
                \@@_labels_in_sequence:nn
                  { \l_@@_type_first_label_tl } { \l_@@_label_a_tl }
              }
            \tl_set:Nx \l_@@_typeset_queue_curr_tl
              {
                \bool_if:NTF \l_@@_next_maybe_range_bool
                  { \exp_not:V \l_@@_pairsep_tl }
                  { \exp_not:V \l_@@_rangesep_tl }
                \@@_get_ref:V \l_@@_label_a_tl
              }
          }
      }

    % Now that the type is finished, we can add the name and the first ref to
    % the queue.  Or, if ``typset'' option is not ``both'', handle it here
    % too.
    \@@_type_name_setup:
    \bool_case_true:nF
      {
        { \l_@@_typeset_ref_bool && \l_@@_typeset_name_bool }
        {
          \tl_put_left:Nx \l_@@_typeset_queue_curr_tl
            { \@@_get_ref_first: }
        }

        { \l_@@_typeset_ref_bool }
        {
          \tl_put_left:Nx \l_@@_typeset_queue_curr_tl
            { \@@_get_ref:V \l_@@_type_first_label_tl }
        }

        { \l_@@_typeset_name_bool }
        {
          \tl_set:Nx \l_@@_typeset_queue_curr_tl
            {
              \bool_if:NTF \l_@@_name_in_link_bool
                {
                  \exp_not:N \group_begin:
                  % It's two '@s', but escaped for DocStrip.
                  \exp_not:N \hyper@@@@link
                    {
                      \zref@ifrefcontainsprop
                        { \l_@@_type_first_label_tl } { urluse }
                        {
                          \zref@extractdefault { \l_@@_type_first_label_tl }
                            { urluse } {}
                        }
                        {
                          \zref@extractdefault { \l_@@_type_first_label_tl }
                            { url } {}
                        }
                    }
                    {
                      \zref@extractdefault
                        { \l_@@_type_first_label_tl } { anchor } {}
                    }
                    { \exp_not:V \l_@@_type_name_tl }
                  \exp_not:N \group_end:
                }
                {
                  \exp_not:N \group_begin:
                  \exp_not:V \l_@@_type_name_tl
                  \exp_not:N \group_end:
                }
            }
        }
      }
      {
        % This case should not happen, given how the options are set up, but a
        % sensible fallback, equal to the behavior of ``both''.
        \tl_put_left:Nx
          \l_@@_typeset_queue_curr_tl { \@@_get_ref_first: }
      }

    % Typeset the previous type, if there is one.
    \int_compare:nNnT { \l_@@_type_count_int } > { 0 }
      {
        \int_compare:nNnT { \l_@@_type_count_int } > { 1 }
          { \l_@@_tlistsep_tl }
        \l_@@_typeset_queue_prev_tl
      }

    % Wrap up loop, or prepare for next iteration.
    \bool_if:NTF \l_@@_typeset_last_bool
      {
        % We are finishing, typeset the current queue.
        \int_case:nnF { \l_@@_type_count_int }
          {
            % Single type.
            { 0 }
            { \l_@@_typeset_queue_curr_tl }
            % Pair of types.
            { 1 }
            {
              \l_@@_tpairsep_tl
              \l_@@_typeset_queue_curr_tl
            }
          }
          {
            % Last in list of types.
            \l_@@_tlastsep_tl
            \l_@@_typeset_queue_curr_tl
          }
      }
      {
        % There are further labels, set variables for next iteration.
        \tl_set_eq:NN
          \l_@@_typeset_queue_prev_tl \l_@@_typeset_queue_curr_tl
        \tl_clear:N \l_@@_typeset_queue_curr_tl
        \tl_clear:N \l_@@_type_first_label_tl
        \tl_clear:N \l_@@_type_first_label_type_tl
        \tl_clear:N \l_@@_range_beg_label_tl
        \int_zero:N \l_@@_label_count_int
        \int_incr:N \l_@@_type_count_int
        \int_zero:N \l_@@_range_count_int
        \int_zero:N \l_@@_range_same_count_int
      }
  }

\cs_new_protected:Npn \@@_typeset_refs_aux_not_last_of_type:
  {
    % Signal if next label may form a range with the current one (of
    % course, only considered if compression is enabled in the first
    % place).
    \bool_set_false:N \l_@@_next_maybe_range_bool
    \bool_set_false:N \l_@@_next_is_same_bool
    \bool_lazy_and:nnT
      { \l_@@_typeset_compress_bool }
      % Currently no-op, but kept as ``handle'' to inhibit compression of
      % individual labels.
      { ! \l_@@_range_inhibit_next_bool }
      {
        \zref@ifrefundefined { \l_@@_label_a_tl }
          { }
          {
            \@@_labels_in_sequence:nn
              { \l_@@_label_a_tl } { \l_@@_label_b_tl }
          }
      }

    % Process the current label to the current queue.
    \int_compare:nNnTF { \l_@@_label_count_int } = { 0 }
      {
        % Current label is the first of its type (also not the last, but it
        % doesn't matter here): just store the label.
        \tl_set:NV \l_@@_type_first_label_tl \l_@@_label_a_tl
        \tl_set:NV \l_@@_type_first_label_type_tl \l_@@_label_type_a_tl

        % If the next label may be part of a range, we set `range_beg_label'
        % to ``empty'' (we deal with it as the ``first'', and must do it
        % there, to handle hyperlinking), but also step the range counters.
        \bool_if:NT \l_@@_next_maybe_range_bool
          {
            \tl_clear:N \l_@@_range_beg_label_tl
            \int_incr:N \l_@@_range_count_int
            \bool_if:NT \l_@@_next_is_same_bool
              { \int_incr:N \l_@@_range_same_count_int }
         }
      }
      {
        % Current label is neither the first (nor the last) of its
        % type.
        \bool_if:NTF \l_@@_next_maybe_range_bool
          {
            % Starting, or continuing a range.
            \int_compare:nNnTF
              { \l_@@_range_count_int } = {0}
              {
                % There was no range going, we are starting one.
                \tl_set:NV \l_@@_range_beg_label_tl \l_@@_label_a_tl
                \int_incr:N \l_@@_range_count_int
                \bool_if:NT \l_@@_next_is_same_bool
                  { \int_incr:N \l_@@_range_same_count_int }
              }
              {
                % Second or more in the range, but not the last.
                \int_incr:N \l_@@_range_count_int
                \bool_if:NT \l_@@_next_is_same_bool
                  { \int_incr:N \l_@@_range_same_count_int }
              }
          }
          {
            % Next element is not in sequence, meaning: there was no range, or
            % we are closing one.
            \int_case:nnF { \l_@@_range_count_int }
              {
                % There was no range going on.
                {0}
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      \exp_not:V \l_@@_listsep_tl
                      \@@_get_ref:V \l_@@_label_a_tl
                    }
                }
                % Last is second in the range: if `range_same_count' is also
                % `1', it's a repetition (drop it), otherwise, it's a ``pair
                % within a list'', treat as list.
                {1}
                {
                  \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                    {
                      \tl_if_empty:VF \l_@@_range_beg_label_tl
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_range_beg_label_tl
                        }
                      \int_compare:nNnF { \l_@@_range_same_count_int } = {1}
                        {
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_label_a_tl
                        }
                    }
                }
              }
              {
                % Last is third or more in the range: if `range_count' and
                % `range_same_count' are the same, its a repetition (drop it),
                % if they differ by `1', its a list, if they differ by more,
                % it is a real range.
                \int_case:nnF
                  { \l_@@_range_count_int - \l_@@_range_same_count_int }
                  {
                    {0}
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \tl_if_empty:VF \l_@@_range_beg_label_tl
                            {
                              \exp_not:V \l_@@_listsep_tl
                              \@@_get_ref:V \l_@@_range_beg_label_tl
                            }
                        }
                    }
                    {1}
                    {
                      \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                        {
                          \tl_if_empty:VF \l_@@_range_beg_label_tl
                            {
                              \exp_not:V \l_@@_listsep_tl
                              \@@_get_ref:V \l_@@_range_beg_label_tl
                            }
                          \exp_not:V \l_@@_listsep_tl
                          \@@_get_ref:V \l_@@_label_a_tl
                        }
                    }
                  }
                  {
                    \tl_put_right:Nx \l_@@_typeset_queue_curr_tl
                      {
                        \tl_if_empty:VF \l_@@_range_beg_label_tl
                          {
                            \exp_not:V \l_@@_listsep_tl
                            \@@_get_ref:V \l_@@_range_beg_label_tl
                          }
                        \exp_not:V \l_@@_rangesep_tl
                        \@@_get_ref:V \l_@@_label_a_tl
                      }
                  }
              }
            % Reset counters.
            \int_zero:N \l_@@_range_count_int
            \int_zero:N \l_@@_range_same_count_int
          }
      }
    % Step label counter for next iteration.
    \int_incr:N \l_@@_label_count_int
  }

\msg_new:nnn { zref-clever } { missing-type }
  { Reference~type~undefined~for~label~'#1'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-name }
  { Name~undefined~for~type~'#1'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { single-element-range }
  { Range~for~type~'#1'~resulted~in~single~element~\msg_line_context:. }

%    \end{macrocode}
%
%
%
%
% \section{Declare Strings}
%
%
%    \begin{macrocode}

% All strings retrieved with \cs{@@_get_string:nN} must have their values set
% for `fallback', since this is what will be retrieved if \pkg{babel} or
% \pkg{polyglossia} is loaded and sets a language which \pkg{zref-clever} does
% not know.  On the other hand type-specific strings are not looked for in
% `fallback'.
\@@_add_default_translation:nnn { fallback } { namesep   } {\nobreakspace}
\@@_add_default_translation:nnn { fallback } { pairsep   } {,~}
\@@_add_default_translation:nnn { fallback } { listsep   } {,~}
\@@_add_default_translation:nnn { fallback } { lastsep   } {,~}
\@@_add_default_translation:nnn { fallback } { tpairsep  } {,~}
\@@_add_default_translation:nnn { fallback } { tlistsep  } {,~}
\@@_add_default_translation:nnn { fallback } { tlastsep  } {,~}
\@@_add_default_translation:nnn { fallback } { rangesep  } {\textendash}
\@@_add_default_translation:nnn { fallback } { refpre    } {}
\@@_add_default_translation:nnn { fallback } { refpos    } {}
\@@_add_default_translation:nnn { fallback } { refpre-in } {}
\@@_add_default_translation:nnn { fallback } { refpos-in } {}

%    \end{macrocode}
%
%
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%

% \section{Localization}

%    \begin{macrocode}
%<*lang-english>
%    \end{macrocode}
%
%
% All strings retrieved with \cs{@@_get_string:nN} must have their values set
% for `English', since this is what will be retrieved if no language package
% is loaded.
%    \begin{macrocode}
\ProvideDictionaryFor{English}{zref-clever}

\zcDicDefaultTransl{namesep}{\nobreakspace}
\zcDicDefaultTransl{pairsep}{~and\nobreakspace}
\zcDicDefaultTransl{listsep}{,~}
\zcDicDefaultTransl{lastsep}{~and\nobreakspace}
\zcDicDefaultTransl{tpairsep}{~and\nobreakspace}
\zcDicDefaultTransl{tlistsep}{,~}
\zcDicDefaultTransl{tlastsep}{,~and\nobreakspace}
\zcDicDefaultTransl{rangesep}{~to\nobreakspace}
\zcDicDefaultTransl{refpre}{}
\zcDicDefaultTransl{refpos}{}
\zcDicDefaultTransl{refpre-in}{}
\zcDicDefaultTransl{refpos-in}{}

\zcDicTypeTransl{part}{name-sg}{part}
\zcDicTypeTransl{part}{name-pl}{parts}
\zcDicTypeTransl{part}{Name-sg}{Part}
\zcDicTypeTransl{part}{Name-pl}{Parts}
\zcDicTypeTransl{part}{name-ab-sg}{part}
\zcDicTypeTransl{part}{name-ab-pl}{parts}
\zcDicTypeTransl{part}{Name-ab-sg}{Part}
\zcDicTypeTransl{part}{Name-ab-pl}{Parts}

\zcDicTypeTransl{chapter}{name-sg}{chapter}
\zcDicTypeTransl{chapter}{name-pl}{chapters}
\zcDicTypeTransl{chapter}{Name-sg}{Chapter}
\zcDicTypeTransl{chapter}{Name-pl}{Chapters}
\zcDicTypeTransl{chapter}{name-ab-sg}{chapter}
\zcDicTypeTransl{chapter}{name-ab-pl}{chapters}
\zcDicTypeTransl{chapter}{Name-ab-sg}{Chapter}
\zcDicTypeTransl{chapter}{Name-ab-pl}{Chapters}

\zcDicTypeTransl{section}{name-sg}{section}
\zcDicTypeTransl{section}{name-pl}{sections}
\zcDicTypeTransl{section}{Name-sg}{Section}
\zcDicTypeTransl{section}{Name-pl}{Sections}
\zcDicTypeTransl{section}{name-ab-sg}{section}
\zcDicTypeTransl{section}{name-ab-pl}{sections}
\zcDicTypeTransl{section}{Name-ab-sg}{Section}
\zcDicTypeTransl{section}{Name-ab-pl}{Sections}

\zcDicTypeTransl{paragraph}{name-sg}{paragraph}
\zcDicTypeTransl{paragraph}{name-pl}{paragraphs}
\zcDicTypeTransl{paragraph}{Name-sg}{Paragraph}
\zcDicTypeTransl{paragraph}{Name-pl}{Paragraphs}
\zcDicTypeTransl{paragraph}{name-ab-sg}{par.}
\zcDicTypeTransl{paragraph}{name-ab-pl}{par.}
\zcDicTypeTransl{paragraph}{Name-ab-sg}{Par.}
\zcDicTypeTransl{paragraph}{Name-ab-pl}{Par.}

\zcDicTypeTransl{page}{name-sg}{page}
\zcDicTypeTransl{page}{name-pl}{pages}
\zcDicTypeTransl{page}{Name-sg}{Page}
\zcDicTypeTransl{page}{Name-pl}{Pages}
\zcDicTypeTransl{page}{name-ab-sg}{p.}
\zcDicTypeTransl{page}{name-ab-pl}{pp.}
\zcDicTypeTransl{page}{Name-ab-sg}{Page}
\zcDicTypeTransl{page}{Name-ab-pl}{Pages}

\zcDicTypeTransl{figure}{name-sg}{figure}
\zcDicTypeTransl{figure}{name-pl}{figures}
\zcDicTypeTransl{figure}{Name-sg}{Figure}
\zcDicTypeTransl{figure}{Name-pl}{Figures}
\zcDicTypeTransl{figure}{name-ab-sg}{fig.}
\zcDicTypeTransl{figure}{name-ab-pl}{figs.}
\zcDicTypeTransl{figure}{Name-ab-sg}{Fig.}
\zcDicTypeTransl{figure}{Name-ab-pl}{Figs.}

\zcDicTypeTransl{table}{name-sg}{table}
\zcDicTypeTransl{table}{name-pl}{tables}
\zcDicTypeTransl{table}{Name-sg}{Table}
\zcDicTypeTransl{table}{Name-pl}{Tables}
\zcDicTypeTransl{table}{name-ab-sg}{table}
\zcDicTypeTransl{table}{name-ab-pl}{tables}
\zcDicTypeTransl{table}{Name-ab-sg}{Table}
\zcDicTypeTransl{table}{Name-ab-pl}{Tables}

\zcDicTypeTransl{equation}{name-sg}{equation}
\zcDicTypeTransl{equation}{name-pl}{equations}
\zcDicTypeTransl{equation}{Name-sg}{Equation}
\zcDicTypeTransl{equation}{Name-pl}{Equations}
\zcDicTypeTransl{equation}{name-ab-sg}{eq.}
\zcDicTypeTransl{equation}{name-ab-pl}{eqs.}
\zcDicTypeTransl{equation}{Name-ab-sg}{Eq.}
\zcDicTypeTransl{equation}{Name-ab-pl}{Eqs.}
\zcDicTypeTransl{equation}{refpre-in}{(}
\zcDicTypeTransl{equation}{refpos-in}{)}

\zcDicTypeTransl{item}{name-sg}{item}
\zcDicTypeTransl{item}{name-pl}{items}
\zcDicTypeTransl{item}{Name-sg}{Item}
\zcDicTypeTransl{item}{Name-pl}{Items}
\zcDicTypeTransl{item}{name-ab-sg}{item}
\zcDicTypeTransl{item}{name-ab-pl}{items}
\zcDicTypeTransl{item}{Name-ab-sg}{Item}
\zcDicTypeTransl{item}{Name-ab-pl}{Items}
%    \end{macrocode}
%
%    \begin{macrocode}
%</lang-english>
%    \end{macrocode}


% \PrintIndex
%
% \end{implementation}
%
